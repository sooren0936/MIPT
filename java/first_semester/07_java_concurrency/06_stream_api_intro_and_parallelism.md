# Stream API

Java 8 предоставила нам возможность писать некоторые вещи в красивом и лаконичном функциональном
стиле. В релизе есть такие функциональные вещи,
как [лямбда-функции](https://www.geeksforgeeks.org/lambda-expressions-java-8/), 
[функциональные интерфейсы](https://www.geeksforgeeks.org/functional-interfaces-java/) и
предмет сегодняшней темы, Stream'ы. Стримы позволяют нам компактно и понятно описать обработку
последовательности элементов. Давайте посмотрим, что и как можно сделать, используя стримы.

## Порядок исполнения

Стримы несколько похожи на конвейеры на заводе. Что нужно, чтобы получить конвейер, готовый к работе?

Во-первых, нам нужны вещи или данные, с которыми конвейер будет работать: детали машин, числа,
строки. Поэтому первым делом нам нужно настроить поток элементов.

Во-вторых, нужно что-то с этими вещами сделать: смешать, отфильтровать, преобразовать. На этом этапе
нам на помощь приходят _промежуточные_ операции. Логично, что на промежуточных операциях конвейер не
заканчивается. Например, мы покрасили деталь машины, нам нужно передать ее дальше, чтобы ее можно
было посушить. Если говорить чуть более техническим языком, это значит, что любые промежуточные операции
принимают `Stream<T>` и возвращают `Stream<T>`.

Наконец, когда мы закончили с обработкой элементов, нам нужно их собрать, упаковать или разослать
клиентам. Здесь мы используем _терминальные_ операции: они приводят элементы стрима к финальному
виду и закрывают стрим. После того как мы собрали нашу машину, уже нет потока деталей, и нельзя с
ними ничего сделать, также мы не можем обратиться к стриму после его закрытия.

## Как создать стрим

Есть множество вариантов того, как можно создать стрим. Рассмотрим самые часто употребимые из них.

### Из существующей коллекции

Допустим, у нас в коде уже есть коллекция элементов, которые мы хотим обработать:

```java
public class Main {

  public static void main(String[] args) {
    List<String> strings = List.of("a", "b", "c");
    Stream<String> stream = strings.stream();
  }
}
```

### Генератор

Если мы хотим создать поток элементов, то можно использовать генератор. Генератору на вход нужно
дать так называемый `Supplier`, единственной задачей которого является предоставление нового
элемента стриму:

```java
public class Main {

  public static void main(String[] args) {
    // сгенерирует 10 приветствий Марку
    Stream.generate(() -> "Hi, Mark!")
        .limit(10);

    // сгенерирует 3 случайных числа с плавающей точкой 
    Stream.generate(new Random()::nextFloat)
        .limit(3);
  }
}
```

Заметим, что в конце мы поставили `limit()`, иначе бы мы сгенерировали _бесконечный_ поток
элементов.

### Стрим из примитивов

В Java есть возможность гибкого получения стрима для `Int`  и `Long`. Можно задать начальный и
конечный элемент с помощью методов `range(firstElement, lastElement)`
и `rangeClosed(firstElement, lastElement)`: первый исключает `lastElement` из стрима, второй -
включает.

```java
public class Main {

  public static void main(String[] args) {
    IntStream.range(0, 3);           // 0, 1, 2
    LongStream.rangeClosed(0L, 3L);  // 0L, 1L, 2L, 3L
  }
}
```

### Билдер

Со стримами можно использовать паттерн builder и наполнять стрим постепенно:

```java
public class Main {

  public static void main(String[] args) {
    Stream<Integer> builtStream = Stream.<Integer>builder()
        .add(1)
        .add(2)
        .add(3)
        .build();

    Stream<Object> builtStream = Stream.builder()
        .add(1)
        .add("hi")
        .add(List.of(1, 2, 3))
        .build();
  }
}
```

Здесь стоит обратить внимание на то, что в первой строчке мы указываем тип данных, который мы будем
класть в стрим, иначе автоматически подставится тип `Object`, и проверка типов элементов не будет
осуществляться, как во втором случае.

Также нужно не забыть "собрать" наш стрим методом `build()`, в противном случае будет тип
не `Stream<DataType>`, а `Stream.Builder<DataType>`.

## Промежуточные методы

Отлично, теперь мы умеем делать стримы. Давайте посмотрим, как устроена обработка элементов.

После того как мы получили поток элементов, можно этот поток преобразовать с помощью
промежуточных (_intermediate_) методов. Эти методы "знают", как применить функцию, которую мы
передаем как аргумент, к элементам стрима. То есть разработчик только описывает, **что** сделать с
элементами, а **как** это делать - ответственность промежуточных методов.

Разберем на примерах.

### filter

Методу `filter()` нужно указать функцию `Predicate`: она требует один аргумент и должна
возвращать `boolean`. Если для какого-то элемента предикат вернул `true`, он остается в
потоке, `false` - удаляется.

```java
public class Main {

  public static void main(String[] args) {
    Set<String> pizzaIngredients = Set.of("tomato", "flour", "water", "cheese");
    pizzaIngredients.stream()
        .filter(ingredient -> ingredient.contains("e"));
    // water, cheese
  }
}
```

### sorted

Метод `sorted()` принимает в качестве аргумента некоторый `Comparator`: это функция, которая
указывает, как сравнивать два элемента. Интересно, что у всех классов, имплементирующих
интерфейс `Comparable`, уже есть встроенный компаратор. Это значит, что для строчек, разных типов
чисел и почти всех классов стандартной библиотеки необязательно писать свои правила сравнения.

```java
public class Main {

  public static void main(String[] args) {
    Set<String> pizzaIngredients = Set.of("tomato", "flour", "water", "cheese");
    pizzaIngredients.stream()
        .sorted()
        .forEach(System.out::println);
    // cheese, flour, tomato, water

    Stream.of(2, 3, 1, 0)
        .sorted()
        .forEach(System.out::println);
    // 0, 1, 2, 3
  }
}
```

Давайте посмотрим, как выглядит компаратор для `int`:

```java
public class Integer {

  public static int compare(int x, int y) {
    return (x < y) ? -1 : ((x == y) ? 0 : 1);
  }
}
```

Если числа равны, нужно вернуть `0`, если первое больше второго - `1`, если второе больше первого - `-1`. 
Точно так же пишут и другие компараторы, нужно только определить, что больше, а что меньше.

Напишем свой собственный компаратор. Допустим, есть такой класс:

```java
public class Pizza implements Comparable<Pizza> {

  private String name;
  private List<String> ingredients;

  //other methods
}
```

Допустим, лучше ("больше") будет та пицца, в которой есть ананас, и если в обеих пиццах есть ананас, то
они одинаковые. Добавим в наш класс следующий метод:

```java
public class Pizza implements Comparable<Pizza> {
  /* поля класса */

  @Override
  public int compareTo(Pizza otherPizza) {
    return hasPineapple(this) == hasPineapple(otherPizza) ? 0
        : (hasPineapple(this) ? 1 : -1);
  }

  private boolean hasPineapple(Pizza pizza) {
    return pizza.ingredients.contains("pineapple");
  }
}
```

Теперь сравним две пиццы:

```java
public class Main {

  public static void main(String[] args) {
    Pizza margarita = new Pizza("Margarita", List.of("tomato", "flour", "water", "cheese"));
    Pizza hawaiian = new Pizza("Hawaiian",
        List.of("tomato", "flour", "water", "cheese", "pineapple"));

    Stream.of(margarita, hawaiian)
        .sorted();
    // Margarita, Hawaiian
  }
}
```

Итак, пицца с ананасом лучше, поэтому она идет позднее.

### map

`map` принимает функцию-преобразование с одним аргументом, в которой описывается, как сделать из
элемента другой элемент.

```java
public class Main {

  public static void main(String[] args) {
    IntStream.rangeClosed(0, 3)
        .map(e -> e * 2);       // 0, 2, 4, 6   
  }
}
```

## Терминальные методы

### reduce

Операция `reduce()` принимает очень интересную функцию. Она требует два аргумента, первый
представляет собой элемент нашего потока, второй аргумент - аккумулятор, куда мы собираем все наши
элементы. Сама функция - правило, как сложить первый элемент в аккумулятор.

Давайте просуммируем все элементы нашего потока:

```java
public class Main {

  public static void main(String[] args) {
    IntStream.range(0, 4)
        .reduce((el, acc) -> el + acc); // 6
  }
}
```

### collect

Позволяет собрать стрим в коллекцию, например, `Set` или `List`. Удобно, что уже есть готовые методы
для создания коллекции из потока. Посмотрим некоторые примеры.

```java
public class Main {

  public static void main(String[] args) {
    Set<Integer> integerSet = Stream.of(1, 2, 3, 4, 5, 4, 3, 2, 1)
        .collect(Collectors.toSet()); // [1, 2, 3, 4, 5]
  }
}
```

Теперь сделаем мапу с ключами (элемент) и значениям (количество вхождений элемента).

```java
public class Main {

  public static void main(String[] args) {
    Map<Integer, Integer> integerMap = Stream.of(1, 1, 1, 2, 3, 3, 3, 3, 3)
        .collect(Collectors.toMap(e -> e, e -> 1, Integer::sum));
    // {1=3, 2=1, 3=5}
  }
}
```

В `Collectors.toMap` первым аргументом мы указали функцию, которая устанавливает ключи в мапе, в данном
случае это просто наши элементы потока. Вторым аргументом - функцию, которая устанавливает
значения: нам нужно, чтобы при каждом вхождении элемента в значение клалась `1`, третий аргумент
отвечает за то, что делать с той `1`, которую нам дала вторая функция, здесь мы просто суммируем.

Когда обработалась первая единица, по ключу `1` записалась `1`, когда обработалась вторая единица,
вторая функция `e -> 1` тоже пытается записать `1` по ключу `1`, 
и происходит коллизия, потому что у нас уже есть значение по этому ключу. В таком
случае будет вызываться третья функция, которая принимает два аргумента:
уже установленное значение и новое. Результат выполнения этой функции будет записан в значение по
ключу, в данном примере `sum(1,1)`.

Есть еще много терминальных операций, мы посмотрели самые распространенные.

## Ленивость промежуточных операций

Вероятно, самая главна фича стримов - ленивость промежуточных операций. Она заключается в том, что
промежуточные операции будут исполнены, только если этого требует терминальная операция. Посмотрим
на примерах:

```java
public class Main {

  public static void main(String[] args) {
    Set.of("tomato", "flour", "water", "cheese", "pineapple")
        .stream()
        .filter(e -> {
          System.out.println("I did something");
          return e.contains("e");
        });
  }
}
```

Как вы думаете, сколько раз в консоль будет выведено сообщение? Ответ: ни разу. Потому что у нас нет
терминальной операции. Давайте добавим!

```java
public class Main {

  public static void main(String[] args) {
    Set.of("tomato", "flour", "water", "cheese", "pineapple")
        .stream()
        .filter(e -> {
          System.out.println("I did something");
          return e.contains("e");
        })
        .collect(Collectors.toList());
  }
}
```

В этом случае наше сообщение будет напечатано уже все 5 раз. А если добавить еще один фильтр?

```java
public class Main {

  public static void main(String[] args) {
    Set.of("tomato", "flour", "water", "cheese", "pineapple")
        .stream()
        .filter(e -> {
          System.out.println("I did something");
          return e.contains("e");
        })
        .filter(e -> {
          System.out.println("I did something too");
          return e.startsWith("p");
        })
        .collect(Collectors.toList());
  }
}
```

Сообщение для второго фильтра напечатается только для тех элементов, которые прошли первый фильтр.

## Почему стримы?

Теперь, когда мы разобрались с теорией, давайте поймем, зачем вообще использовать стримы, как и
когда они помогают?

1. Stream API - удобный инструмент для декларативного описания обработки данных.
2. Используя стримы, можно легко работать с большими данными из разных источников, например, из
   файлов или баз данных, не беспокоясь при этом о затраченной памяти.
3. Ленивость промежуточных методов оптимизирует количество необходимых операций.
4. С помощью стримов можно без труда параллелить обработку. Как? Об этом сейчас и поговорим.

# Параллелизм

Мы с вами успели рассмотреть, как работать со стримами, которые обрабатывают элементы
последовательно один за другим. Теперь разберемся, как устроены параллельные стримы: те, которые
могут работать с элементами в разных потоках.

## Параллельный стрим из последовательного

Итак, допустим, у нас есть обычный последовательный стрим. Сделать из него параллельный можно с
помощью метода
`parallel()`.

```java
public class Main {

  public static void main(String[] args) {
    Stream.of(1, 2, 3)
        .parallel()
        .map(e -> e * 2)
        .forEach(System.out::println); // 2, 6, 4
  }
}
```

Параллельный стрим можно получить не только из последовательного стрима, но и из коллекции,
используя метод `parallelStream()`:

```java
public class Main {

  public static void main(String[] args) {
    List.of(1, 2, 3)
        .parallelStream()
        .map(e -> e * 2)
        .forEach(System.out::println); // 6, 4, 2
  }
}
```

Посмотрите на порядок вывода: при использовании параллельных стримов нет гарантии, что
обрабатываться элементы будут в том же порядке, в котором они указаны. Более того, порядок вывода
будет меняться от запуска к запуску.

## Последовательный стрим из параллельного

Stream API нам также позволяет собрать параллельные потоки в один. Для этого достаточно
указать `sequential()`:

```java
public class Main {

  public static void main(String[] args) {
    List.of(1, 2, 3)
        .parallelStream()
        .map(e -> e * 2)
        .sequential()
        .forEach(System.out::println); //2, 4, 6
  }
}
```

В этом случае порядок вывода элементов будет совпадать с порядком их ввода.

Методы `parallel()` и `sequential()` - промежуточные операции, они лишь указывают терминальной
операции, как обрабатывать элементы, и сами не создают параллельных или последовательных потоков.
Вот реализация этих методов:

```java
public interface Stream<S> {

  S parallel() {
    sourceStage.parallel = true;
    return (S) this;
  }

  S sequential() {
    sourceStage.parallel = false;
    return (S) this;
  }
}
```

Здесь был поменян булевый флажок `sorceStage.parallel` и не было никаких преобразований стримов.

## Внутреннее устройство

Когда-то давным-давно, до Java 8, в синтаксисе языка еще не было Stream API, и для создания
параллельных потоков разработчики использовали fork-join framework. Сегодня он скрыт за Stream API,
и программистам уже необязательно писать на fork-join framework`е, хотя с ним все же стоит быть
знакомым для корректного использования параллелизма в стримах.

Как мы уже видели, `parallel()` и `parallelStream()` запускают обработку в отдельных потоках. За
организацию потоков отвечает
`ForkJoinPool`, по умолчанию количество потоков в пуле равно количеству ядер.

> Если все потоки ForkJoinPool заняты, то методы `parallel()` и `parallelStream()` вернут не параллельный стрим,
> а последовательный.

Чтобы проверить, какой у вас стрим, можно использовать метод `isParallel()`.

Как сделать, чтобы гарантированно распараллелить стрим? Просто - создать свой пул потоков.

```java
public class Main {

  public static void main(String[] args) {
    ForkJoinPool pool = new ForkJoinPool(3);
    List<Integer> list = List.of(1, 2, 3);

    pool.submit(() -> list.parallelStream()
        .map(e -> e * 2)
        .forEach(System.out::println)
    ).get();
    pool.shutdown();
  }
}
```

## Use cases

Несмотря на внешнюю лаконичность параллельных стримов, они могут сильно влиять на
производительность: потоки вашего стрима могут отнимать процессорное время у соседних потоков,
частое переключение между потоками ведет к частой смене контекста исполнения.

Поэтому использовать параллельные стримы нужно только при сильной необходимости и с подходящими
задачами. Какие задачи можно считать подходящими?

- те, что не зависят от соседних задач и которым необходим только один элемент стрима
- те, что используют источник данных, который можно вычитывать в несколько потоков
- те, которые тратят много времени для работы с каждым элементом, иначе расходы на обслуживание
  потоков могут "съесть" прирост производительности от параллельности
- те, что не требуют больших затрат на соединение результатов работы каждого потока

