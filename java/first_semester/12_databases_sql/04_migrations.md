# Миграция данных

Как бы хорошо вы ни спроектировали схему БД, в какой-то момент придется вносить изменения в ее
структуру (и, как следствие, данные), так как требования могут меняться со временем. Переход от
старой схемы базы к новой называется миграцией. Изменения структуры применяются прямо к живой
продакшен-базе.

Необходимость мигрировать базу влечет возникновение проблем в случае, если накаты производятся
"руками", не автоматически:

1. Как в каждый момент времени понять, была ли уже накачена миграция или нет? Без этого знания можно
   легко потерять что-то важное или ошибочно промигрировать дважды. Например, добавление поля в
   таблицу делается с помощью команды `ALTER TABLE ADD`. Выполнять это выражение имеет смысл ровно
   один раз, когда в таблице поле ещё отсутствует, а необходимость в нём уже есть. В другие моменты
   запуск команды приведёт либо сразу к ошибке, либо, что хуже, к неправильному состоянию структуры
   базы данных.
2. Миграций обычно много. Некоторые могут зависеть друг от друга. Нужно тратить временя и силы на
   поддержание "правильного порядка" наката скриптов.
3. Вы работаете в команде с другими разработчикам, из-за этого могут возникать конфликты в миграциях
   или перезатирания изменений друг друга.

Что мы хотим получить в итоге:

* Любую версию базы данных можно обновить до любой (обычно самой последней) версии.
* Набор SQL-запросов, реализующих миграцию между любыми двумя версиями, можно получить как можно быстрее и проще.
* Всегда можно создать с нуля базу данных со структурой самой последней версии.
* Возможность одновременной работы нескольких людей.
* Откатить БД на более раннюю версию так же просто, как и обновить на более новую.

Один из вариантов организации процесса работы с миграциями БД, который разрешает перечисленные
проблемы, это *метод инкрементальных изменений*. Внесение изменений в БД производится через
специальный новый файл миграции (*changeset*). Он подключается в главный файл (*changeLog*), который
контролирует версии и управляет всеми изменениями.

Каждый *changeset* имеет уникальный идентификатор, для простоты обычно берется путь файла. На
стороне БД создается таблица, дублирующая наш *changeLog*-файл (*databasechangelog*). При накате
изменений на БД анализируется *changeLog*-файл и для каждого *changeset*'а проверяется таблица *databasechangelog*. 
Если в таблице есть запись с таким же id, то *changeset* считается выполненным и
будет пропущен. Если записи нет, то выполняются команды из *changeset*'а, а в *databasechangelog*
сохраняется запись о завершенном *changeset*'е. После просмотра всего *changeLog* БД перейдет в
актуальное состояние. *changeLog* и все *changeset*'ы можно хранить в git'е вместе с исходным кодом
приложения.

Этот подход реализует система управления миграциями [Liquibase](https://www.liquibase.org/). ***Liquibase*** — 
это независимая от базы данных библиотека для отслеживания, управления и применения
изменений схем базы данных. В качестве описания структуры и изменений базы данных используется XML,
YAML, JSON и SQL форматы. Существуют и другие системы управления миграциями (DBDeploy, Doctrine 2
migrations и т.д.), некоторые из них платформозависимые, некоторые не обладают таким широким
функционалом, как Liquibase.

Liquibase можно использовать как обычное Java приложение. Для этого нужно просто скачать
соответствующий JAR-файл и вызывать `java -jar liquibase.jar`, передав в аргументах путь до *changeLog*-файла 
и параметры подключения к БД. Но удобней
использовать [liquibase-maven-plugin](https://mvnrepository.com/artifact/org.liquibase/liquibase-maven-plugin).
Тогда можно будет встроить управление миграциями в жизненный цикл вашего приложения. Например,
накатывать новую версию БД перед деплоем приложения.

В следующем модуле мы рассмотрим Flyway (альтернативу Liquibase), а также способ его подключения к Java-проекту.