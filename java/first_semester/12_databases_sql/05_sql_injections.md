# SQL-инъекции
SQL-инъекция - это способ атаки сайтов, которые работают с базами данных.
Также этим термином называют уязвимость, которая используется в ходе такой атаки.
Согласно [рейтингу OWASP](https://owasp.org/www-project-top-ten/), SQL-инъекции входят в тройку самых распространённых уязвимостей.

Суть уязвимости заключается в том, что данные, вводимые пользователем на сайте, конкатенируются в SQL-запросе без валидации и санитизации.
Благодаря этому злоумышленник может подобрать такую строку, выполнение которой в качестве SQL-запроса удалит данные, 
либо предоставит злоумышленнику несанкционированный доступ к информации.      

## Примеры
### Удаление данных
Предположим, что на сайте есть форма подписки на новости, где пользователь должен ввести имя и почту. 
Когда пользователь заполняет эту форму, на сервере формируется SQL-запрос: 
```java
String query = "INSERT INTO subscription VALUES ('" + userName + "', '" + email + "')"
```

Если в качестве email в форме мы введём следующее:
```sql
mail@serer.com'); DROP TABLE user; --
```
то это превратится в следующий SQL:
```sql
INSERT INTO subscription (name, email) VALUES ('Хакер', 'mail@serer.com'); DROP TABLE subscription; --')
```
То есть первый SQL-запрос будет сформирован корректно, а затем через точку с запятой будет добавлен второй, вредоносный запрос.

"--" - это комментарий в SQL, поэтому всё, что следует после этих символов, будет проигнорировано. 
Комментарий здесь нужен для того, чтобы проигнорировалась последняя скобка, т.к. с ней SQL-запрос будет невалидным.  

В результате выполнения получившихся SQL-запросов будет удалена таблица subscription.

### Несанкционированный доступ
Предположим, что на сайте есть страница, где отображаются банковские счета пользователя.
Допустим, что данные для этой страницы считываются из БД следующим запросом:
```java
String query = "SELECT * FROM account WHERE user_id = " + userId;
```
Тогда, если подставить в качестве userId строку "42 OR 1=1", SQL-запрос станет таким:  
```java
String query = "SELECT * FROM account WHERE user_id = 42 OR 1=1";
```
В результате будут считаны все строки таблицы account. 

## Защита от SQL-инъекций
Необходимо избегать конкатенации SQL-запросов и строк, введённых пользователем.
Предпочтительно использовать PreparedStatement.

```java
String query = "INSERT INTO subscription (name, email) VALUES (?, ?)";

PreparedStatement statement = connection.prepareStatement(query);
statement.setString(1, person.getName());
statement.setInt(2, person.getEmail());
statement.executeUpdate();
```

Во-первых, появляется защита от SQL-инъекций, поскольку данные от пользователей вставляются в запрос в качестве параметров, но не меняют сам запрос.    

Во-вторых, повысится быстродействие, поскольку PreparedStatement использует предварительную компиляцию запроса. 
Когда база данных получает SQL-запрос, она ищет такой запрос у себя в кеше и, если не находит, компилирует этот запрос и помещает в кеш.
При использовании PreparedStatement код запроса отделяется от данных. 
Поэтому последующие вызовы этого запроса (даже с другими данными в качестве параметров) не приведут к повторной компиляции: 
будет использован скомпилированный запрос из кеша.

В-третьих, PreparedStatement предоставляет возможность пакетного выполнения:
```java
String query = "INSERT INTO subscription (name, email) VALUES (?, ?)";

PreparedStatement statement = connection.prepareStatement(query);
for (Person person: persons) {
    statement.setString(1, person.getName());
    statement.setInt(2, person.getEmail());
    statement.addBatch();
}
statement.executeBatch();
```

В-четвёртых, код становится чище.
