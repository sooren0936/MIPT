
# Командная разработка

Вообще говоря, разработка — это автоматизация определенного бизнес -процесса, решение какой -то проблемы. Хотя понятие более абстрактное, но по факту это происходит вот так. И вообще говоря, сам код, он никого не интересует. То есть не важно, насколько красиво, быстро он написали код, сколько тестами он покрыт, важно лишь то, ну бизнесу, вашему заказчику важно лишь то, что это решается, какая -то конкретная проблема, и насколько правильно она решается. Можем даже сказать, что разработка кода изображена с многими проблемами типа багов, поддерживаемости и многие проблемы хорошо бы решить без написания кода вообще.
Если в университете вы чаще всего пишете код в одиночку, то в реальном мире, особенно в мире enterprise-Java, **сценарий кардинально меняется**.

-  **Масштаб проектов:** Современные системы — это не один класс `Main` и десять вспомогательных классов. Это десятки микросервисов, сотни API-эндпоинтов, сложнейшая инфраструктура (базы данных, кеши, очереди сообщений, шлюзы). Один человек физически не может удерживать всю систему в голове и быть экспертом во всех ее частях.
- **Скорость разработки:** Бизнес требует быстрого вывода features на рынок. Параллельная работа команды из 5-10 разработчиков в разы ускоряет этот процесс.
- **Качество и надежность:** Один разработчик может допустить ошибку в архитектуре или реализации. Команда, через процессы код-ревью и коллективное владение кодом (collective code ownership), выступает в роли системы сдержек и противовесов, что drastically повышает качество конечного продукта.
- **Никто не незаменим:** Если разработчик уходит в отпуск, заболевает или покидает проект, его знания и обязанности распределены внутри команды. Проект не останавливается.

### Роли:
1) **Team Lead / Tech Lead (Технический лидер):  
 -  **Ответственность**: Не самый крутой программист, а тот, кто отвечает за техническое видение проекта, архитектурные решения, техническое состояние кода и рост разработчиков в команде.
 - **Задачи:** Разработка архитектуры, разрешение технических споров, менторинг, код-ревью, планирование нагрузок, коммуникация с архитекторами и менеджерами.

2) **Backend Developer (Java-разработчик):**
 - **Ядро команды.** Его зона ответственности — бизнес-логика, работа с данными, API.
 - **Технологический стек:** Java 17+, Spring (Boot, MVC, Data, Security), Hibernate/JPA, REST API, SQL (PostgreSQL, Oracle), NoSQL (Redis, MongoDB), системы очередей (Kafka, RabbitMQ).

3) **Frontend Developer:**
 - Создает то, что видит пользователь. Тесно взаимодействует с бэкендером по контрактам API.
 - Технологии:  JavaScript/TypeScript, React, Angular, Vue.js.

1) **QA Engineer (Тестировщик):**
- **Не "тот, кто ловит баги", а гарант качества.** Пишет автотесты (unit, integration, e2e), настраивает CI/CD пайплайны для автоматического прогона тестов, составляет тест-планы и проводит ручное тестирование сложных сценариев.
- **Технологии**: Selenium, JUnit, TestNG, Cucumber, Selenide, Postman.

5) **DevOps Engineer:**
-   **Мост между разработкой и эксплуатацией.** Его задача — автоматизировать все: сборку, тестирование, развертывание и мониторинг приложения.
-  **Технологии:** Docker, Kubernetes, Jenkins/GitLab CI, Ansible, Terraform, облачные платформы (AWS, Yandex Cloud, Azure).

6)  **Product Manager / Product Owner (Владелец продукта):
- Представляет интересы бизнеса и пользователей. Формирует видение продукта, составляет roadmap и приоритизирует задачи (составляет backlog). Отвечает на вопрос "ЧТО мы делаем?".

7)   **Project Manager / Scrum Master:**
 - Отвечает за процессы внутри команды. Следит за сроками, устраняет организационные препятствия (блокеры),facilitates митинги. Отвечает на вопрос "КАК мы это делаем?".

### Софт и хард скиллы

Чтобы быть эффективным в такой командной среде, Java-разработчику нужен сбалансированный набор навыков.

**Hard Skills (Технические навыки):**
- **Ядро Java:** Многопоточность, коллекции, JVM, память.
- **Spring Framework:** Без этого в enterprise никуда.
- **Базы данных:** SQL, оптимизация запросов, ORM (Hibernate).
- **Инструменты**: Git (и понимание workflows like GitFlow), Maven/Gradle, IDE (IntelliJ IDEA).
- **Тестирование:** Умение писать unit-тесты (JUnit, Mockito).
- **API:** Умение проектировать RESTful API, понимание OpenAPI.
- **Базовые знания DevOps:** Умение собрать Docker-образ, понять логику CI/CD пайплайна — это huge плюс.

**Soft Skills (Гибкие навыки):**
- **Коммуникация:** Умение четко и ясно выражать мысли, аргументировать свою позицию, задавать правильные вопросы и активно слушать. _Это навык №1._
- **Работа в команде:** Нет эгоизму, есть "мы". Умение договариваться, идти на компромиссы, помогать коллегам.
- **Критическое мышление и решение проблем:** Умение анализировать задачу, разбивать ее на части и находить оптимальное решение, а не просто писать код.
- **Код-ревью:** И давать, и получать конструктивную обратную сторону. Понимать, что это не личная атака, а процесс улучшения кода.
- **Тайм-менеджмент:** Оценка задач, приоритизация, работа в рамках спринта.
- **Адаптивность:** Технологии и требования меняются быстро. Нужно быть готовым постоянно учиться.

# Введение в систему контроля версий <a name="введение"></a>

Система контроля версий (Version Control System, VCS) — это фундаментальный инструмент в современной разработке программного обеспечения.
### Исторический контекст
До появления современных VCS разработчики использовали различные методы для контроля версий:

1. **Ручное копирование файлов** с добавлением дат и версий в имена
2. **Локальные базы данных** версий (например, RCS, SCCS)
3. **Централизованные системы** (CVS, Subversion)

Каждый из этих подходов имел серьезные ограничения. Централизованные системы создавали единую точку отказа, а отсутствие возможности работать оффлайн серьезно замедляло разработку.

### Зачем нужна система контроля версий?

1. **История изменений** - возможность видеть, кто, когда и зачем изменил код
2. **Откат изменений** - возможность вернуться к предыдущей версии при обнаружении ошибок
3. **Параллельная разработка** - несколько разработчиков могут работать над одним проектом
4. **Резервное копирование** - код хранится в нескольких экземплярах

## Что такое Git и зачем он нужен <a name="что-такое-git"></a>

Git — это распределенная система контроля версий, созданная Линусом Торвальдсом в 2005 году для разработки ядра Linux. В отличие от централизованных систем, в Git каждый разработчик имеет полную копию репозитория со всей историей изменений.

### Философия Git

Git построен на нескольких ключевых принципах:

1. **Распределенность** - нет единой точки отказа
2. **Целостность данных** - все объекты в Git идентифицируются по хешу
3. **Скорость** - операции выполняются локально
4. **Неизменяемость данных** - once committed, never changed

## Основные концепции Git <a name="основные-концепции"></a>

### Три состояния файлов

В Git файлы могут находиться в одном из трех состояний:
1. **Modified** - файл изменен, но изменения не зафиксированы
2. **Staged** - файл подготовлен к коммиту
3. **Committed** - файл сохранен в локальной базе данных

### Рабочий процесс Git

1. Вы вносите изменения в файлы в рабочей директории
2. Подготавливаете файлы, добавляя их в staging area
3. Делаете коммит, который сохраняет файлы в Git-директории

## Работа с репозиторием <a name="работа-с-репозиторием"></a>

### Создание репозитория

```bash
# Инициализация нового репозитория
$ git init my-project
$ cd my-project

# Клонирование существующего репозитория
$ git clone https://github.com/user/repo.git
$ git clone https://github.com/user/repo.git my-directory
```

### Базовые команды

```bash
# Проверка статуса
$ git status

# Добавление файлов в staging area
$ git add file.txt
$ git add .  # все файлы
$ git add *.java  # все java файлы

# Создание коммита
$ git commit -m "Initial commit"

# Просмотр истории коммитов
$ git log
$ git log --oneline
$ git log --graph --oneline --all
```

### Работа с удаленными репозиториями

```bash
# Добавление удаленного репозитория
$ git remote add origin https://github.com/user/repo.git

# Просмотр удаленных репозиториев
$ git remote -v

# Отправка изменений на сервер
$ git push origin master

# Получение изменений с сервера
$ git pull origin master
$ git fetch origin  # только загрузка изменений
```

## Ветвление и слияние <a name="ветвление-и-слияние"></a>

### Создание и переключение веток

```bash
# Создание новой ветки
$ git branch feature-branch

# Переключение на ветку
$ git checkout feature-branch
# или
$ git switch feature-branch

# Создание и переключение за одну команду
$ git checkout -b feature-branch
# или
$ git switch -c feature-branch
```

### Типы веток

1. **Main/Master** - основная ветка для production кода
2. **Develop** - ветка для разработки
3. **Feature branches** - ветки для разработки новых функций
4. **Release branches** - ветки для подготовки релиза
5. **Hotfix branches** - ветки для срочных исправлений

### Слияние веток

```bash
# Переключение на ветку, в которую нужно влить изменения
$ git checkout main

# Слияние feature ветки в main
$ git merge feature-branch
```

### Перебазирование (Rebase)

```bash
# Перебазирование текущей ветки на main
$ git rebase main

# Интерактивное перебазирование
$ git rebase -i HEAD~3
```

## Решение конфликтов <a name="решение-конфликтов"></a>

Конфликты слияния — неизбежная часть работы с Git. 
### Типы конфликтов
1. **Конфликты содержимого** - разные изменения в одних и тех же строках
2. **Конфликты переименования** - файл переименован в одной ветке и изменен в другой
3. **Конфликты удаления** - файл удален в одной ветке и изменен в другой

### Процесс решения конфликтов

```bash
# При возникновении конфликта Git покажет:
Auto-merging file.txt
CONFLICT (content): Merge conflict in file.txt
Automatic merge failed; fix conflicts and then commit the result.
```

### Ручное решение конфликтов

Git помечает конфликтующие участки в файлах:

```java
public class Example {
<<<<<<< HEAD
    public void newMethod() {
        // новый код из текущей ветки
    }
=======
    public void oldMethod() {
        // старый код из merging ветки
    }
>>>>>>> feature-branch
}
```

### Инструменты для решения конфликтов

1. **Встроенные инструменты** - git mergetool
2. **IDE** - IntelliJ IDEA, VS Code

## 7. Продвинутые техники Git <a name="продвинутые-техники"></a>

### Stashing - временное сохранение изменений

```bash
# Сохранение текущих изменений
$ git stash

# Просмотр списка stash
$ git stash list

# Восстановление изменений
$ git stash pop
$ git stash apply
```

### Работа с тегами

```bash
# Создание легковесного тега
$ git tag v1.0.0

# Создание аннотированного тега
$ git tag -a v1.0.0 -m "Version 1.0.0"

# Пуш тегов на сервер
$ git push origin --tags
```

### Поиск в истории

```bash
# Поиск по сообщению коммита
$ git log --grep="bugfix"

# Поиск по содержимому файлов
$ git grep "functionName"

# Поиск коммитов, где менялся конкретный файл
$ git log --follow -p file.java
```

## Введение в CI/CD <a name="введение-в-cicd"></a>

Continuous Integration (Непрерывная интеграция) и Continuous Delivery/Deployment (Непрерывная доставка/развертывание) — это практики, которые кардинально изменили процесс разработки за последние 15 лет.
### Исторический контекст

До CI/CD:
- Интеграция кода происходила редко (раз в неделю/месяц)
- Процесс деплоя был ручным и подвержен ошибкам
- Обнаружение проблем на поздних стадиях

### Определения

**Continuous Integration (CI)** - практика частого слияния кода в основную ветку с автоматизированной сборкой и тестированием.
**Continuous Delivery (CD)** - практика подготовки кода к релизу в любое время.
**Continuous Deployment** - автоматическое развертывание кода после успешного прохождения тестов.

### Benefits of CI/CD

1. **Раннее обнаружение ошибок**
2. **Сокращение времени доставки**
3. **Увеличение confidence в коде**
4. **Автоматизация рутинных задач**

CI/CD — это не просто инструменты, а **культура разработки и набор практик**, направленных на автоматизацию и оптимизацию жизненного цикла программного обеспечения.

- **Непрерывная интеграция (CI)** предполагает **частую автоматизированную сборку и тестирование** кода. Разработчики регулярно сливают свои изменения в общую ветку, что позволяет быстро находить и устранять конфликты и ошибки. Это решает проблему "ад слияния" (merge hell), когда множество изменений накапливаются и интегрируются вручную в конце цикла разработки.
    
- **Непрерывная доставка (CD)** автоматизирует процесс **релиза** проверенного кода в среды тестирования и, после ручного подтверждения, в продакшен. Это обеспечивает наличие всегда готового к развертыванию артефакта.
    
- **Непрерывное развертывание** — это дальнейшее расширение непрерывной доставки, где **каждое изменение, прошедшее тесты, автоматически выкатывается в продакшен** без явного человеческого вмешательства. Это позволяет максимально быстро получать обратную связь от пользователей.

Основная цель CI/CD — **сократить время между написанием кода и его доставкой пользователям**, обеспечивая при этом **высокое качество и стабильность** продукта. Это достигается за счет автоматизации, раннего обнаружения дефектов и повышения предсказуемости процесса.

CI/CD является техническим ядром философии **DevOps**, стирая границы между разработкой (Development) и эксплуатацией (Operations).

- **Разработчики** получают быструю обратную связь о качестве кода и могут сосредоточиться на реализации функциональности, а не на рутинных задачах сборки и деплоя.

- **Операционные команды** (Ops) получают надежные и предсказуемые механизмы для развертывания приложений, что снижает риски и нагрузку.

В современном мире также растет важность **DevSecOps** — интеграции практик безопасности (Security) непосредственно в CI/CD-конвейер для раннего выявления уязвимостей ("shift left security")

Типичный конвейер состоит из нескольких последовательных этапов, большая часть которых автоматизирована:

1. **Сборка (Build):** Компиляция исходного кода и создание артефакта (например, JAR-файла для Java или Docker-образа) 7.
    
2. **Тестирование (Test):** Запуск автоматизированных тестов разных уровней:
    - **Модульные (Unit tests)** проверяют отдельные компоненты.
    - **Интеграционные (Integration tests)** проверяют взаимодействие между модулями.
    - **Приемочные (Acceptance tests)** проверяют соответствие бизнес-требованиям.
        
3. **Статический анализ кода:** Проверка на соответствие стандартам, уязвимости и "запахи" кода (code smells) с помощью инструментов вроде SonarQube.
    
4. **Деплой на тестовые среды:** Автоматическое развертывание артефакта на среды, максимально приближенные к продакшену, для дальнейшего тестирования.
    
5. **Релиз и развертывание:** Пуш готового артефакта в продакшен-среду. На этом этапе может требоваться ручное подтверждение (Continuous Delivery) или быть полностью автоматическим (Continuous Deployment).

6. **Мониторинг:** После деплоя важно отслеживать поведение приложения в реальных условиях, чтобы оперативно обнаруживать проблемы.

### Почему CI/CD так важен? Ключевые преимущества

| Преимущество                        | Описание                                                                                                                                                               |
| ----------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Скорость и частота релизов**      | Автоматизация позволяет выпускать обновления чаще, иногда по много раз в день, что ускоряет получение обратной связи и вывод продукта на рынок.                        |
| **Повышение качества кода**         | Автоматическое тестирование на каждом шаге обнаруживает ошибки на самых ранних стадиях, когда их исправление наименее затратно.                                        |
| **Снижение рисков**                 | Частые и небольшие изменения сделать проще и безопаснее, чем редкие и крупные релизы. В случае проблемы всегда можно быстро откатиться к предыдущей стабильной версии. |
| **Автоматизация рутины**            | Высвобождает время разработчиков для более важных задач, снижая вероятность человеческих ошибок при ручном деплое.                                                     |
| **Повышение прозрачности**          | Все участники процесса видят статус сборок, тестов и деплоев, что улучшает коммуникацию и понимание состояния проекта.                                                 |
| **Быстрое исправление уязвимостей** | Позволяет оперативно выпускать патчи для критических уязвимостей безопасности.                                                                                         |


## Принципы непрерывной интеграции <a name="принципы-ci"></a>

### Основные практики CI
1. **Частые коммиты в основную ветку**
2. **Автоматизированная сборка**
3. **Автоматизированное тестирование**
4. **Быстрая обратная связь**
5. **Видимость процесса для всей команды**
### Pipeline непрерывной интеграции

Типичный CI pipeline включает следующие этапы:
1. **Сборка** - компиляция кода
2. **Статический анализ** - проверка code style, поиск уязвимостей
3. **Unit тесты** - проверка отдельных компонентов
4. **Integration тесты** - проверка взаимодействия компонентов
5. **Создание артефакта** - подготовка пакета для deployment

## Принципы непрерывной доставки <a name="принципы-cd"></a>

### Ключевые элементы CD
1. **Конфигурация как код** - инфраструктура описывается в коде
2. **Идемпотентность** - deployment можно повторять без side effects
3. **Версионирование** - все артефакты имеют уникальные версии
4. **Откат изменений** - возможность быстро откатиться к предыдущей версии

## Настройка pipeline <a name="настройка-pipeline"></a>

### Jenkins pipeline example

```groovy
pipeline {
    agent any
    
    stages {
        stage('Build') {
            steps {
                sh 'mvn clean compile'
            }
        }
        
        stage('Test') {
            steps {
                sh 'mvn test'
            }
            post {
                always {
                    junit 'target/surefire-reports/*.xml'
                }
            }
        }
        
        stage('Deploy') {
            when {
                branch 'main'
            }
            steps {
                sh 'mvn deploy'
            }
        }
    }
}
```

### GitLab CI example

```yaml
stages:
  - build
  - test
  - deploy

build:
  stage: build
  script:
    - mvn clean compile
  artifacts:
    paths:
      - target/

unit-test:
  stage: test
  script:
    - mvn test
  artifacts:
    reports:
      junit: target/surefire-reports/*.xml

deploy-prod:
  stage: deploy
  script:
    - mvn deploy
  only:
    - main
```

### GitHub Actions example

```yaml
name: Java CI

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v2
    
    - name: Set up JDK 11
      uses: actions/setup-java@v2
      with:
        java-version: '11'
        distribution: 'adopt'
        
    - name: Build with Maven
      run: mvn clean compile
      
    - name: Run tests
      run: mvn test
      
    - name: Upload test results
      uses: actions/upload-artifact@v2
      with:
        name: test-results
        path: target/surefire-reports/
```


CI/CD — это не просто модная аббревиатура, а **фундаментальная практика** современной разработки ПО. Она позволяет командам создавать программное обеспечение быстрее, качественнее и предсказуемее. Внедрение CI/CD — это путешествие, которое начинается с малого (автоматизация сборки и тестов) и постепенно охватывает весь процесс доставки ПО пользователю, трансформируя культуру команды в сторону большей автоматизации, сотрудничества и ответственности.

## Лучшие практики <a name="лучшие-практики"></a>

### Лучшие практики Git

1. **Частые маленькие коммиты**
2. **Осмысленные сообщения коммитов**
3. **Одна логическая единица изменения на коммит**
4. **Тестирование перед коммитом**
5. **Использование .gitignore**

### Лучшие практики CI/CD

1. **Быстрые pipeline** - обратная связь должна быть максимально быстрой
2. **Идемпотентность** - pipeline должен давать одинаковый результат при повторном запуске
3. **Версионирование артефактов** - каждый артефакт должен иметь уникальную версию
4. **Security scanning** - проверка на уязвимости в процессе CI
5. **Infrastructure as Code** - инфраструктура должна описываться в коде

## Типичные ошибки <a name="типичные-ошибки"></a>

### Ошибки в работе с Git

1. **Коммит больших бинарных файлов**
2. **Force push в общие ветки**
3. **Неполные сообщения коммитов**
4. **Игнорирование конфликтов**

### Ошибки в CI/CD

1. **Долгие pipeline** - разработчики перестают ждать результаты
2. **Хрупкие тесты** - tests that fail randomly
3. **Отсутствие rollback стратегии**
4. **Ручные steps в pipeline**
