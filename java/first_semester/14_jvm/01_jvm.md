# Принцип работы JVM

## O JVM

### Java Virtual Machine

Виртуальная машина Java (JVM) – это механизм, обеспечивающий среду выполнения для управления Java-кодом или
приложениями. Он преобразует байт-код Java в машинный язык. JVM является частью Java Run Environment (JRE). В других
языках программирования, к примеру, в C, C++ компилятор создает машинный код для конкретной системы. Однако компилятор
Java создает код для виртуальной машины, известной как виртуальная машина Java.

### Немного предыстории

До появления Java, примерно в январе 1996 года, многие приложения писали на С или С++. У этих языков есть проблема:
разработчику приходится думать, на какой операционке и архитектуре процессора будет работать его код. Например, если он
пишет программу под Linux, то, скорее всего, она не запустится на Windows или MacOS. Поэтому код приходилось пичкать
директивами условной компиляции или писать отдельную версию для каждой операционки.

Самую сильную боль вызывали приложения с GUI — код графических компонентов для разных операционок был совершенно разным.
Причина в том, что C и C++ довольно близки к железу, а значит, сишник должен учитывать архитектуру процессора и тип
операционной системы. Понятно, что никакой кроссплатформенностью здесь и не пахнет.

> Ещё в 1960-е годы у инженеров появилась идея: писать программы не для конкретного железа, а для абстрактного «исполнителя».
> Программы на Java как раз пишутся для такого исполнителя — виртуальной машины, или Java Virtual Machine (JVM).
> Java-разработчик не задумывается, на какой платформе будет запускаться его код.
> В то же время виртуальная машина не знает, что исполняет инструкции на Java, ведь она принимает и исполняет байт-код

### Две основные функции JVM:

1. Позволяет запускать Java-приложения на любых устройствах или операционных системах (принцип — «Написал один раз,
   запускай везде»)
2. Управляет и оптимизирует память, используемую приложением

## Архитектура JVM

Архитектура jvm состоит из нескольких частей

1. Загрузчик классов
2. JVM-память
3. Исполнительный механизм
4. Интерфейс системных методов
5. Библиотека нативных методов

![img](img/jvm_arch.png)

### Загрузчик классов

Он в основном отвечает за три вида деятельности.

- Загрузка
- Связывание
- Инициализация

#### Загрузка

Загрузчик классов считывает файл `.class`, создает соответствующие двоичные данные и сохраняет их в области методов.

Для каждого файла `.class` JVM хранит следующую информацию в области методов:

- Полное имя загруженного класса и его непосредственного родительского класса.
- Связан ли файл `.class` с классом, интерфейсом или перечислением.
- Информация о модификаторах, переменных и методах и т. д.

После загрузки файла `.class` JVM создает объект типа `Class` для представления этого файла в динамической памяти.
Обратите внимание, что этот объект имеет тип `Class`, предопределенный в пакете `java.lang`. Этот объект класса может
использоваться программистом для получения информации об уровне класса, такой как имя класса, имя родителя, методы и
информация о переменной и т. д.

*Чтобы получить ссылку на этот объект, мы можем использовать метод `getClass()` класса `Object`.*
<details>
  <summary>Пример кода</summary>

```java
import java.lang.reflect.Field;
import java.lang.reflect.Method;


public class Test {
    public static void main(String[] args) {
        Student s1 = new Student();
        Class c1 = s1.getClass();
        System.out.println(c1.getName());
        // Получить массив методов
        Method[] methods = c1.getDeclaredMethods();
        for (Method method : methods)
            System.out.println(method.getName());
        //Получить массив полей
        Field[] fields = c1.getDeclaredFields();
        for (Field field : fields)
            System.out.println(field.getName());
    }
}


class Student {
    private String name;
    private int number;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getNumber() {
        return number;
    }

    public void setNumber(int number) {
        this.number = number;
    }
}
```

> **Примечание**. Для каждого загруженного файла « .class» создается только один объект класса.
</details>

#### Связывание

Выполняет проверку, подготовку и (необязательно) разрешение.

1. **Проверка** - проверяет правильность файла `.class` , т. е. проверяет, правильно ли этот файл отформатирован и
   сгенерирован допустимым компилятором или нет. Если проверка не пройдена, мы получаем исключение времени выполнения
   java.lang.VerifyError . Это действие выполняется компонентом ByteCodeVerifier. После завершения этого действия файл
   класса готов к компиляции.
2. **Подготовка** - JVM выделяет память для переменных класса и инициализирует память значениями по умолчанию.
3. **Разрешение** - это процесс замены символических ссылок из типа прямыми ссылками. Это делается путем поиска в
   области метода, чтобы найти объект, на который ссылаются.

#### Инициализация

На этом этапе всем статическим переменным присваиваются значения, определенные в коде и статическом блоке (если есть).
Это выполняется сверху вниз в классе и от родителя к дочернему в иерархии классов.

Есть три загрузчика классов:

1. **Загрузчик классов начальной загрузки -** каждая реализация JVM должна иметь загрузчик классов начальной загрузки,
   способный загружать доверенные классы. Он загружает основные классы API Java, присутствующие в каталоге «JAVA_HOME/jre/lib». 
   Этот путь широко известен как путь начальной загрузки. Он реализован на родных языках, таких как
   C, C++.
2. **Загрузчик класса расширения -** это дочерний элемент загрузчика класса начальной загрузки. Он загружает классы,
   присутствующие в каталогах расширений «JAVA_HOME/jre/lib/ext» (путь расширения) или в любом другом каталоге,
   указанном системным свойством java.ext.dirs. Он реализован в java классом `sun.misc.Launcher$ExtClassLoader` .
3. **Загрузчик класса системы/приложения -** это дочерний загрузчик класса расширения. Он отвечает за загрузку классов
   из пути к классам приложения. Он внутренне использует переменную среды, которая сопоставляется с `java.class.path.`
   Он также реализован в Java классом `sun.misc.Launcher$AppClassLoader` .

> JVM следует принципу делегирования-иерархии для загрузки классов.
> Загрузчик системного класса делегирует запрос загрузки загрузчику класса расширения, а загрузчик класса расширения делегирует запрос загрузчику класса начальной загрузки.
> Если класс найден в пути начальной загрузки, класс загружается, в противном случае запрос снова передается загрузчику класса расширения, а затем системному загрузчику класса.
> Наконец, если загрузчику системного класса не удается загрузить класс, мы получаем исключение времени выполнения java.lang.ClassNotFoundException .
![img](img/jvmclassloader.jpg)

### JVM - Память

#### Method Area(Область методов)

В области методов хранится вся информация уровня класса, такая как имя класса, имя непосредственного родительского
класса, информация о методах и переменных и т. д., включая статические переменные. У каждой JVM есть только одна область
методов, и это общий ресурс.

#### Heap&Stack

Для оптимальной работы приложения JVM делит память на область стека (stack) и область кучи (heap). Всякий раз, когда мы
объявляем новые переменные, создаем объекты или вызываем новый метод, JVM выделяет память для этих операций в стеке или
в куче.

##### Heap

Эта область памяти используется для динамического выделения памяти для объектов и классов JRE во время выполнения. Новые
объекты всегда создаются в heap'e, а ссылки на них хранятся в стеке.

Эти объекты имеют глобальный доступ и могут быть получены из любого места программы.

Эта область памяти разбита на несколько более мелких частей, называемых поколениями:

- **Young Generation** — область, где размещаются недавно созданные объекты. Когда она заполняется, происходит быстрая
  сборка мусора
- **Old (Tenured) Generation** — здесь хранятся долгоживущие объекты. Когда объекты из Young Generation достигают
  определенного порога «возраста», они перемещаются в Old Generation
- **Permanent Generation** — эта область содержит метаинформацию о классах и методах приложения, но начиная с Java 8
  данная область памяти была упразднена. Так же мы можем управлять размерами кучи в зависимости от наших требований.

**Помимо рассмотренных ранее, heap имеет следующие ключевые особенности**

- Когда эта область памяти полностью заполняется, Java бросает `java.lang.OutOfMemoryError`
- Доступ к ней медленнее, чем к стеку
- Эта память, в отличие от стека, автоматически не освобождается. Для сбора неиспользуемых объектов используется сборщик
  мусора
- В отличие от стека, heap не является потокобезопасной и ее необходимо контролировать, правильно синхронизируя код

##### Stack

Стек работает по схеме LIFO (последним вошел, первым вышел).
![img](img/stack_representation.jpg)

Всякий раз, когда вызывается новый метод, содержащий примитивные значения или ссылки на объекты, то на вершине стека под
них выделяется блок памяти. Из этого можно сделать вывод, что стек хранит значения примитивных переменных, создаваемых в
методах, а также ссылки на объекты в куче, на которые ссылается метод. Когда метод завершает выполнение, блок памяти (frame), 
отведенный для его нужд, очищается, и пространство становится доступным для следующего метода. При этом поток
выполнения программы возвращается к месту вызова этого метода с последующим переходом к следующей строке кода.

**Помимо того, что мы рассмотрели, существуют и другие особенности стека**

Он заполняется и освобождается по мере вызова и завершения новых методов. Переменные в стеке существуют до тех пор, пока
выполняется метод, в котором они были созданы. Если память стека будет заполнена, Java бросит исключение
`java.lang.StackOverFlowError`. Доступ к этой области памяти осуществляется быстрее, чем к куче. Является
потокобезопасным, поскольку для каждого потока создается свой отдельный стек

##### Пример

Рассмотрим пример кода и далее разберем его:
<details>
  <summary>Пример кода</summary>

```java
class Person {
    int id;
    String name;

    public Person(int id, String name) {
        this.id = id;
        this.name = name;
    }
}

public class PersonBuilder {
    private static Person buildPerson(int id, String name) {
        return new Person(id, name);
    }

    public static void main(String[] args) {
        int id = 23;
        String name = "John";
        Person person = null;
        person = buildPerson(id, name);
    }
}
```

</details>

**Рассмотрим выполнение кода по шагам**

1. До начала выполнения метода `main()` в стеке будет выделено пространство для хранения примитивов и ссылок этого
   метода:
   примитивное значение id типа `int` будет храниться непосредственно в стеке; ссылочная переменная name типа `String`
   будет создана в стеке, но сама строка "John" будет храниться в области, называемой **String Pool** (*является частью
   Кучи*); ссылочная переменная person типа `Person` будет также создана в памяти стека, но будет указывать на объект,
   расположенный в куче;
2. Для вызова конструктора с параметрами `Person (int, String)` из метода `main()` в стеке поверх предыдущего вызова
   метода `main()` будет выделен блок памяти, который будет хранить:
   `this` — ссылка на текущий объект; 
   примитивное значение id; 
   ссылочную переменную name типа `String`, которая указывает на объект строки из пула строк;
3. В методе `main()` дополнительно вызывается метод `buildPerson` для которого будет выделен блок памяти в стеке поверх
   предыдущего вызова. Этот блок снова сохранит переменные способом, описанным выше.
4. Для вновь созданного объекта person типа `Person` все переменные будут сохранены в памяти кучи.

### Исполнительный механизм

Механизм выполнения выполняет `.class` (байт-код). Он считывает байт-код построчно, использует данные и информацию,
находящиеся в различных областях памяти, и выполняет инструкции. 

Его можно разделить на три части:
- Интерпретатор
- JIT-Компилятор
- Сборщик мусора

#### Интерпретатор

Интерпретатор считывает инструкции байт-кода и выполняет их последовательно

#### Компилятор Just-In-Time (JIT)

JIT-компиляция — это способ динамической компиляции, которая запускается после запуска программы и компилирует ее код
«на лету». JIT-компиляторы преобразуют код высокоуровневых языков в инструкции, понятные виртуальной машине или
процессору. JIT — это Just-inTime, что подразумевает компиляцию кода, когда это нужно, а не до выполнения программы, в
реальном времени.

**JIT обладает следующими свойствами**

- не весь код сразу компилируется в машинный, а только необходимая часть, — это снижает нагрузку на процессор;
- машинный код генерируется во время выполнения программы, значит, он будет изначально оптимизирован под архитектуру
  устройства, что позволит делать кроссплатформенные программы.

**Главный принцип JIT** — это компилировать не всю программу, а лишь те ее участки, которые наиболее часто используются
пользователем. Такой подход ускоряет работу программы в будущем, поэтому сами программы становятся производительнее,
потому что виртуальная машина будет выполнять уже скомпилированный машинный код, а не компилировать его еще раз.

Однако у такого принципа есть один минус. Скомпилированные куски программного кода нужно где-то хранить. Поэтому они
хранятся в памяти устройства. В результате быстродействие программ при JIT-компиляции достигается за счет увеличенного
потребления памяти устройства.

#### Сборщик мусора

Мусором считается объект, который больше не может быть доступен по ссылке из какого-либо объекта. Поскольку такие
объекты больше не используются в приложении, то их можно удалить из памяти.

Например, в приведенном ниже коде объект student2 может быть удален из памяти, поскольку на него нет ссылок.

```java
Student student = new Student("S1");
Student student2 = new Student("S2");
student2 = null;
```

Вот диаграмма:
![img](img/gc_example.png)

## Краткий итог

**Java Virtual Machine** - это среда выполнения для управления Java-кодом или приложениями. Он преобразует байт-код Java
в машинный язык

- Позволяет запускать код на любой "машине"
- Сам управляет памятью
- Раньше разработчик думал об этом сам

**Основые компоненты Архитектуры JVM**

- Загрузчик классов
- Heap
- Stack
- Исполнительный механизм
- JIT-Компилятор
- Сборщик мусора

