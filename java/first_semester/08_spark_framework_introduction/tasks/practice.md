# Практика

Вам необходимо разработать приложение на Spark Framework по хранению информации о статьях и
комментариях.
Требования к реализации:

1. Все данные хранятся в памяти. Доступ осуществляется через репозиторий. При этом его реализация
   должна работать корректно в многопоточной среде.
2. В сущности `Article` (статья) храним:
    1. `id`
    2. Название
    3. Теги в виде `Set<String>`
    4. Список `Comment` (комментарий) в виде `List<Comment>`
3. В сущности `Comment` храним:
    1. `id`
    2. `articleId` (в каждом `Comment` должна быть ссылка на `Article` по его `id`)
    3. Текст комментария
4. Обе сущности должны быть иммутабельны (то есть меняем контент, создавая новый экземпляр).
5. ID у сущностей `Article` и `Comment` должны быть типизированы. Проще говоря, нужно создать
   обертки `ArticleId` и `CommentId`,
   которые хранят `long`, вместо того, чтобы передавать примитив `long` напрямую.
6. То же самое относится к методам `generateId` в репозиториях: они должны сразу
   возвращать `ArticleId` или `CommentId` вместо «сырых» `long`.
7. Необходимо добавить следующие REST API (возвращают JSON), соблюдая принципы RESTful:
    1. Получение списка статей вместе с их комментариями.
    2. Получение конкретной статьи по ID вместе с ее комментариями.
    3. Редактирование/удаление статьи по ID.
    4. Добавление новой статьи.
    5. Добавление нового комментария в существующую статью.
    6. Удаления комментария.
8. Также нужно добавить один endpoint с шаблонизатором (возвращает динамический `HTML`):
    1. Список существующих статей вместе количеством комментариев в нем.
9. Процент покрытия тестами должен быть не менее `60%` (добавляем соответствующую настройку в
   Jacoco).
10. Требуется написать следующий E2E-тест (поднимает все приложение целиком, составляя "матрешку"
    объектов):
    1. Создаем статью.
    2. Добавляем в нее комментарий.
    3. Редактируем статью.
    4. Удаляем комментарий.
    5. Запрашиваем статью по ID и проверяем, что в ней нет комментариев, а контент изменен в
       соответствии с пунктом 3.
11. Нужно настроить в проекте SLF4J + Logback:
    1. Логи отбрасываются в консоль.
    2. `Root.level = INFO`
    3. При успешном запросе в контролере логируем `DEBUG`.
    4. При `4xx` ошибке (ожидаемой) логируем `WARN`.
    5. При `5xx` ошибке (неожиданная) логируем `ERROR`.