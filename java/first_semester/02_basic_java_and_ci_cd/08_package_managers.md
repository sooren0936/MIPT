# Пакетные менеджеры

## Как Java внедряет сторонние библиотеки

Разработка программного обеспечения построена на принципе повторного использования кода, который уже
был написан (вами или другими программистами). Более того, современные программные системы настолько
сложны, что написать их без использования сторонних библиотек и фреймворков практически невозможно.
Ведь в таком случае вам бы пришлось всю эту функциональность писать самостоятельно.

Предположим, что вы пишите программу по выводу MD5-хэша для входной строки в консоли. Посмотрите на
пример кода ниже.

```java
package com.example;

class Main {

  public static void main(String[] args) {
    String inputStr = args[0];
    String hash = calculateMD5Hash(inputStr);
    System.out.println(hash);
  }

  private static String calculateMD5Hash(String input) {
    // implementation...
  }
}
```

В данном случае, процесс подсчета MD5-хэша должен быть реализован в функции `calculateMD5Hash`. Но
зачем нам его писать самостоятельно, если кто-то уже сделал это за нас? Допустим, что существует
некий класс `com.apache.HashUtil`, который предоставляет статический метод `md5`. Тогда наш код
изменится.

```java
package com.example;

import com.apache.HashUtil;

class Main {

  public static void main(String[] args) {
    String inputStr = args[0];
    String hash = HashUtil.md5(inputStr);
    System.out.println(hash);
  }
}
```

Процесс компиляции и запуска этой программы в терминале представлен ниже.

```shell
javac Main.java       # компиляция в byte-код (файл с расширением .class)
java com.example.Main # запуска программы (указываем название класса вместе с пакетом)
```

При запуске мы получим ошибку `ClassNotFoundException` в той строчке, где происходит обращение к
`HashUtil`. Дело в том, что JVM не знает, откуда прочитать byte-код класса `HashUtil`. Для решения
этой проблемы
существует [classpath](https://docs.oracle.com/javase/tutorial/essential/environment/paths.html).
Это указание директории, откуда JVM будет загружать классы. Предположим, что скомпилированный
класс `HashUtil` находится в той же директории, что и `Main.java`. Тогда процесс компиляции и
запуска будет выглядеть следующим образом.

```shell
javac Main.java
java -classpath . com.example.Main # несколько директорий classpath можно разделять знаком ;
```

А теперь представьте, что вам нужно использовать не один сторонний класс, а десятки или даже сотни.
Если следовать предложенному сценарию, вам придется:

1. Искать все нужные библиотеки в Интернете ручным поиском.
2. Сохранять их в одну директорию в системе.
3. Корректно указывать classpath при запуске.
4. Вовремя обновляться до актуальных версий.
5. Каждому программисту из вашей команды придется повторно проделывать эти действия.

Чтобы автоматизировать и упростить эти шаги, придумали пакетные менеджеры.

## Maven

Maven – один из самых популярных пакетных менеджеров для Java на текущий момент. Создать новый
Java-проект на основе Maven можно с помощью IDEA. Суть пакетного менеджера проста:

1. Каждая зависимость характеризуется тремя параметрами: `groupId`, `artifactId` и `version`. Есть
   правила относительно того, какими `groupId` пользователь может маркировать модули, которые он
   публикует в открытый доступ. Например, для Maven Central `groupId` должен быть равен реверсивному
   доменному имени (например, `google.com` превращается в `com.google`). Причем тот, кто производит
   публикацию, должен доказать, что он владеет указанным доменом (есть определенная процедура
   проверки). `artifactId` может быть любым, но обычно он совпадает с названием конкретной
   библиотеки. `version` же – это версия зависимости. Обычно записывается в формате `1.2.3`.
2. Все модули публикуются в едином реестре – репозитории. По
   умолчанию [Maven](https://maven.apache.org/) скачивает зависимости
   из [Maven Central](https://search.maven.org/). Но в компаниях часто используются приватные
   репозитории, которые недоступны извне.
3. Зависимости описываются декларативно в файле `pom.xml`.

Посмотрите на пример описания зависимости на
библиотеку [Apache Commons](https://commons.apache.org/).

```xml

<dependencies>
  <dependency>
    <groupId>org.apache.commons</groupId>
    <artifactId>commons-lang3</artifactId>
    <version>3.12.0</version>
  </dependency>
</dependencies>
```

Maven предоставляет команду `package`, которая собирает ваш код и все зависимости в единый артефакт
– файл с расширением `.jar`. При запуске вам не нужно указывать classpath, так как все зависимости
уже инкапсулированы внутри. Таким образом, Maven предоставляет:

1. Универсальные правила для идентификации зависимостей
2. Декларативный способ объявления нужных зависимостей и их версий
3. Простой способ смены удаленного репозитория, откуда зависимости будут запрашиваться (достаточно
   указать нужный remote в теге `repository`).

Есть, правда, один нюанс, на который вы могли обратить внимание. При импорте класса в программе вы
указываете только его package и название. Что произойдет, если в classpath окажутся несколько
одинаковых классов разных версий? Это хороший вопрос. Дело в том, что JVM загружает только первый
класс, идентифицируя его по сочетанию `package + class`. Последующие дубликаты будут игнорироваться.
А вот какой именно класс JVM расценит как «первый», неизвестно. Поэтому нужно внимательно следить за
тем, чтобы в вашей программе не было расхождений по версиям. Иначе это может привести, например,
к `MethodNotFoundException` (вы ожидали вызвать метод класса из новой версии, но загрузилась старая,
где он еще не был добавлен). В Maven есть команда `dependency:tree`, которая покажет все зависимости
проекта. После этого вы сможете точечно убрать ненужные с помощью
тега [exclusion](https://maven.apache.org/guides/introduction/introduction-to-optional-and-excludes-dependencies.html#dependency-exclusions).

Создать новый Java проект на Maven можно двумя способами:

1. С помощью командной строки. Например, приведенная ниже команда создаст Maven проект для Java со
   стандартными директориями.

```shell
mvn archetype:generate \
	-DgroupId=com.mts.meta \
	-DartifactId=student-project \
	-DarchetypeArtifactId=maven-archetype-quickstart \
	-DinteractiveMode=false
```

2. С помощью IDEA. Выберите пункт: `File -> Project... -> Maven`

## Внедрение Maven Shade Plugin

Давайте в наш Java-проект добавим Maven Shade Plugin, который соберет проект и все наши зависимости в `jar` файл.
Посмотрите на блок кода ниже, который нужно добавить в `pom.xml`:

```xml
<build>
   
    <plugins>
       
      <plugin>
        <groupId>org.apache.maven.plugins</groupId>
        <artifactId>maven-shade-plugin</artifactId>
        <version>3.5.0</version>
        <executions>
          <execution>
            <goals>
              <goal>shade</goal>
            </goals>
            <configuration>
              <shadedArtifactAttached>true</shadedArtifactAttached>
              <transformers>
                <transformer implementation=
                  "org.apache.maven.plugins.shade.resource.ManifestResourceTransformer">
                  <mainClass>org.example.Main</mainClass>
                </transformer>
              </transformers>
            </configuration>
          </execution>
        </executions>
      </plugin>
       
    </plugins>
   
</build>
```

Тег `build` содержит конфигурацию сборки. В `plugins` располагаем плагины (их может быть несколько).
Ну и затем добавляем информацию о самом `maven-shade-plugin`. Обратите внимание на тег `mainClass`.
В нем указывается название класса, который содержит функцию `main`, вместе с `package`.
Если вы указали другое название package при создании проекта, он может немного отличаться.
Проверьте, что у вас все совпадает.

Теперь запустите команду `package` в Maven. Это можно сделать в Idea, открыв вкладку `Maven`, либо выполнив следующую команду в консоли:

```bash
mvn package
```

> Чтобы операция в консоли выполнилась, нужно, чтобы команда `mvn` была доступна.
> Для этого вам нужно будет явно скачать и установить Maven (в Idea он встроен).

После этого откройте папку `target` в вашем проекте и запустите собранный `jar` файл:

```bash
java -jar my-test-project-1.0-SNAPSHOT-shaded.jar
```

> Название `jar` файла может немного отличаться. Вам нужно выбрать тот, что с суффиксом `shaded`.
> Также команда `java` должна быть доступна из командной строки. Для этого нужно [установить JDK 17](https://bell-sw.com/pages/downloads/).

Если вы увидели в консоли тот результат, который добавляли в функцию `main`, то вы всё сделали правильно.
Поздравляем!

> Если у вас возникли трудности, можете посмотреть пример готового `pom.xml` [по этой ссылке](https://github.com/SimonHarmonicMinor/java-maven-ci-example/blob/master/pom.xml).

## Пара слов о Gradle

Хотя Maven остается одним из самых популярных пакетных менеджеров для Java, другие решения также
набирают обороты. Например, есть такая штука как [Gradle](https://gradle.org/). Это более
современная альтернатива, которая призвана побороть ограничения декларативного подхода в объявлении
зависимостей. Вместо XML используется [Groovy](https://groovy-lang.org/) DSL. Тем не менее, принципы
сохраняются те же самые (репозитории, идентификация зависимостей с помощью тройки `artifactId`-`groupId`-`version`
и так далее).

Все примеры в курсе будут показаны на Maven, но вы можете полюбопытствовать и использовать Gradle.
Это не запрещается. 