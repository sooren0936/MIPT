## Обновляем проект Spring Repository
1) Добавить в проект необходимые зависимости для:
   - Spring Data Jpa + Hibernate
   - Flyway
   - Postgresql
   - TestContainers (со scope = test)
2) Настроить application.yml файл:
   - добавить блок (+настройки) spring.datasource
   - добавить блок (+настройки) spring.jpa
   - добавить блок (+настройки) spring.jpa.hibernate

## Переводим сущности на Hibernate
1) Для каждой вашей сущности (под которую существуют репозитории: Article, User, Book и тп (зависит от ваших текущих реализации дз))
добавляем JPA-аннотации (`@Entity`, `@Table`, `@Id,` `@Column,` `@OneToMany,` `@ManyToOne` и тп)
2) Для генерации идентификаторов можно воспользоваться либо автоматической генерацией, либо переложить ответственность на БД, либо руками генерировать UUID 
3) Должна быть как минимум одна связь из: `OneToMany`, `ManyToOne`, `ManyToMany`

## Добавляем Flyway-миграции
1) В директорию `resources/db/migration/` добавляем миграции, которые должны полностью соответствовать структуре Hibernate-сущностей.
Вы можете написать миграции руками, либо сгенерировать их автоматически - на ваше усмотрение, главное чтобы были файлы с миграциями
2) Для проверки корректности необходимо выставить настройку в application.yml: `spring.jpa.hibernate.ddl-auto: validate` на постоянно основе

## Обновляем проект Spring
1) Реализовать существующие в проекте Spring-Repository через работу с Spring/Hibernate/PG, для этого:
   - Для каждого вашего интерфейса `<Entity>Repository` создаем новый интерфейс, в котором 
все существующие методы должны быть написаны через Spring JPA [JPA Query Methods](https://docs.spring.io/spring-data/jpa/reference/jpa/query-methods.html#jpa.query-methods.query-creation).
Если какой-то метод нельзя переписать через Spring JPA, то нужно его реализовать через "кастомный" репозиторий (см презентацию слайд `Расширение репозитория новым интерфейсом`), либо через
нативный sql-запрос
   - Каждый репозиторий должен быть наследован от `JpaRepository<...>`-интерфейса
   - Не должно остаться классов/интерфейсов для repository, которые работают по "старым" вариантам с заглушками/hashmap/тп
2) Для service-слоя ставим аннотации `@Transactional`, передавая в их параметры правильные значения `isolation`/`readOnly`/`propagation`/`rollbackFor`
3) Рекомендуется работать с Hibernate-объектами только в рамках транзакционных методов. Если вы возвращаете Hibernate-сущность из транзакционного-метода,
то лучше создать отдельный DTO-класс и возвращать именно его (создав обычный маппиг типа `new UserDto(user)`)

## Тесты
1) Хотя бы на один репозиторий должен быть написан тест (в идеале для всех репозиториев). Для этого обращаемся к методичке `Интеграционное тестирование с реальной БД`.
Критерии для теста:
   - Протестирован каждый метод в репозитории: один тест = один метод репозитория
   - Используется TestContainers-библиотеки
   - Используется аннотация `@DataJpaTest`
2) Все ваши существующие тесты должны также работать. Если падают ошибки вида `LazyInitializationException` и тп, то их необходимо устранить


