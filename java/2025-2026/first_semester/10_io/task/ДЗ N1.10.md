## Цель задания
Практическое освоение всех трех подходов к работе с файлами в Java: классический IO, NIO и NIO2.

## Предварительные действия
1. Создайте отдельную ветку для текущего дз
2. Создайте отдельную директорию в вашем проекте, где будут все классы по заданию ниже

## Задание 1: Анализатор текстовых файлов (4 балла)
**Задача**: Создать утилиту для анализа текстовых файлов, которая использует классический Java IO для подсчета статистики: количество строк, слов, символов.

Требования:
1. Использовать FileReader, BufferedReader, FileWriter, BufferedWriter
2. Реализовать подсчет: общее количество строк, слов, символов
3. Реализовать анализ частоты использования каждого символа
4. Сохранять результаты анализа в отдельный файл 
5. Написать Unit-тест в котором тестируется каждый из методов

Шаблон кода:
```java
public class TextFileAnalyzer {

   public static class AnalysisResult {
      private final long lineCount;  // количество строк в файле
      private final long wordCount; // количество слов в файле
      private final long charCount; // количество символов в файле

      // TODO: не забудь прописать конструктор, геттеры, toString()
   }
   
    public AnalysisResult analyzeFile(String filePath) throws IOException {
        // TODO: Реализовать анализ файла по переданному пути `filePath`, используя BufferedReader
        // Подсчитать в файле: lineCount, wordCount, charCount
        // Использовать try-with-resources для автоматического закрытия потоков
    }
    
    public void saveAnalysisResult(AnalysisResult result, String outputPath) throws IOException {
        // TODO: Сохранить результаты в файл по указанному пути `outputPath` используя BufferedWriter в
    }
}
```

Шаблон теста:
```java
class TextFileAnalyzerTest {
    
    @Test
    void testAnalyzeFile() throws IOException {
        TextFileAnalyzer analyzer = new TextFileAnalyzer();
        
        // Создаем временный тестовый файл
        Path testFile = Files.createTempFile("test", ".txt");
        Files.write(testFile, Arrays.asList("Hello world!", "This is test."));
        
        AnalysisResult result = analyzer.analyzeFile(testFile.toString());
        
        // TODO: пропиши тут все проверки на `result`
    }
    
    @Test
    void testSaveAnalysisResult() throws IOException {
        TextFileAnalyzer analyzer = new TextFileAnalyzer();
        
        // Создаем тестовый результат
        AnalysisResult result = new AnalysisResult(2, 5, 20);
        
        // Сохранить в файл
        Path outputFile = Files.createTempFile("analysis", ".txt");
        analyzer.saveAnalysisResult(result, outputFile.toString());
        
        // Проверить что файл создан и содержит данные
        // TODO добавь проверки на файл по пути: outputFile
        //  1. его размер больше 0
        //  2. прочитай этот файл и посмотри что в нем записаны аналогинчные данные как в объекте `result`
    }
}
```

## Задание 2: Файловый процессор с NIO и NIO2 (6 баллов)

**Задача**: Создать утилиту для работы с файлами используя Java NIO и NIO.2. Реализовать операции разбиения файлов на части, объединения частей

Требования:
1. Использовать FileChannel, ByteBuffer для операций с файлами
2. Реализовать разбиение файла на части фиксированного размера
3. Реализовать объединение частей обратно в файл
4. Дописать unit-тест

Шаблон кода:
```java
public class FileProcessor {
    
    /**
     * Разбивает файл на части указанного размера
     * @param sourcePath путь к исходному файлу
     * @param outputDir директория для сохранения частей
     * @param partSize размер каждой части в байтах
     * @return список путей к созданным частям
     */
    public List<Path> splitFile(String sourcePath, String outputDir, int partSize) throws IOException {
        // TODO: Реализовать разбиение файла используя FileChannel и ByteBuffer
        // - Создать части в указанной директории
        // - Имена файлов: originalName.part1, originalName.part2, etc.
        // - Вернуть список путей к созданным частям
    }
    
    /**
     * Объединяет части файла обратно в один файл
     * @param partPaths список путей к частям файла (в правильном порядке)
     * @param outputPath путь для результирующего файла
     */
    public void mergeFiles(List<Path> partPaths, String outputPath) throws IOException {
        // TODO: Реализовать объединение частей используя FileChannel
        // - Проверить что все части существуют
        // - Объединить в правильном порядке
    }
}
```

Шаблон теста:
```java
class FileProcessorTest {
    
    @Test
    void testSplitAndMergeFile() throws IOException {
        FileProcessor processor = new FileProcessor();
        
        // Создать тестовый файл
        Path testFile = Files.createTempFile("test", ".dat");
        byte[] testData = new byte[1500]; // 1.5KB данных
        new Random().nextBytes(testData);
        Files.write(testFile, testData);
        
        // Разбить на части по 500 байт
        String outputDir = Files.createTempDirectory("parts").toString();
        List<Path> parts = processor.splitFile(testFile.toString(), outputDir, 500);
        
        // Должно быть 3 части
        // TODO: напиши тут необходимые проверки asserts
        
        // Объединить обратно
        Path mergedFile = Files.createTempFile("merged", ".dat");
        processor.mergeFiles(parts, mergedFile.toString());
        
        // Проверить что исходный и объединенный файлы идентичны
        assertArrayEquals(Files.readAllBytes(testFile), Files.readAllBytes(mergedFile));
    }
}
```

