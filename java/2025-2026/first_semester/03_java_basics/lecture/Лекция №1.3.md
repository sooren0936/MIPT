

## Введение <a name="введение"></a>

Java — это строго типизированный объектно-ориентированный язык. Его синтаксис во многом унаследован от C/C++, но избавлен от многих их "острых углов". Философия Java — «написано once, run anywhere» (WORA) — достигается компиляцией исходного кода (`*.java`) в байт-код (`*.class`), который выполняется на Виртуальной Машине Java (JVM).

## Объявление переменных: Основы и Нюансы <a name="объявление-переменных"></a>

Переменная — это основной элемент хранения данных в программе. Это именованная область памяти, значение которой может изменяться в ходе выполнения программы.

#### Синтаксис объявления

Базовый синтаксис для объявления переменной выглядит так:
`[модификаторы] тип имя_переменной [= значение];`

*   **Тип (Type):** Определяет, какие данные может хранить переменная (например, `int`, `String`, `double`). Это обязательная часть объявления.
*   **Имя (Identifier):** Идентификатор, по которому вы обращаетесь к переменной. Должен соблюдать правила именования (начинаться с буквы, `$` или `_`, не быть ключевым словом).
*   **Значение (Value):** Начальное значение, присваиваемое переменной. Это опционально, но крайне рекомендуется.

**Примеры:**

```java
// 1. Простое объявление (без инициализации)
int age;
String name;

// 2. Объявление с инициализацией (присваиванием значения)
int count = 0;
double price = 199.99;
String greeting = "Hello, World!";
boolean isActive = true;

// 3. Объявление нескольких переменных одного типа
int x, y, z; // Все три переменные типа int, но не инициализированы.
int a = 5, b = 10, c = 15; // Объявление с инициализацией.
```

#### Важные особенности и подводные камни

1.  **Локальные переменные должны быть инициализированы перед использованием.**
    Это, пожалуй, самый частый источник ошибок у новичков. В отличие от полей класса, локальные переменные (объявленные внутри метода, конструктора или блока) **не получают значения по умолчанию**. Компилятор не позволит вам использовать такую переменную, пока вы явно не присвоите ей значение.

    ```java
     public void myMethod() {
		int localVar;
		System.out.println(localVar); // ОШИБКА КОМПИЛЯЦИИ!
		// Variable 'localVar' might not have been initialized

        localVar = 10; // Теперь инициализирована
        System.out.println(localVar); // OK, выведет 10
    }
    ```

2.  **Поля класса (переменные уровня класса) инициализируются по умолчанию.**
    Если переменная объявлена как поле класса (вне всех методов), JVM автоматически присвоит ей значение по умолчанию, если вы не сделаете этого сами.

| Тип переменной                 | Значение по умолчанию |
| :----------------------------- | :-------------------- |
| `byte`, `short`, `int`, `long` | `0`                   |
| `float`, `double`              | `0.0`                 |
| `char`                         | `'\u0000'` (null)     |
| `boolean`                      | `false`               |
| **Ссылочные типы**             | `null`                |

```java
   public class MyClass {
       private int defaultInt; // Будет = 0
       private String defaultString; // Будет = null

        public void printDefaults() {
            System.out.println(defaultInt); // Выведет 0
            System.out.println(defaultString); // Выведет null
        }
    }
    ```

3.  **`final` переменные (константы).**
    Ключевое слово `final` используется для объявления переменной, которую можно инициализировать только **один раз**. После присваивания значения его нельзя изменить.
    *   Для `final` полей класса инициализацию можно отложить до работы конструктора.
    *   Имена констант принято писать в UPPER_SNAKE_CASE.

Для дальнейшего развития самостоятельно узнайте:
*   Разницу между `final` переменной, `final` методом и `final` классом.
*   Что дает `final` в параметрах метода.
*   Как `final` влияет на потокобезопасность (например, гарантии safe publication).

    ```java
    // Объявление константы
    public static final double PI = 3.14159;
    public final int maxConnections;

    public MyClass(int max) {
        this.maxConnections = max; // Инициализация final-поля в конструкторе
    }

    public void tryToChange() {
        // maxConnections = 100; // ОШИБКА КОМПИЛЯЦИИ! Cannot assign a value to final variable
    }
    ```

4.  **Область видимости (Scope).**
    Переменная доступна только внутри того блока кода (`{}`), в котором она объявлена, и во всех вложенных блоках. Вне своего блока переменная "не существует".

    ```java
    public void scopeExample() {
        int outerVar = 10;

        {
            int innerVar = 20;
            System.out.println(outerVar); // OK, внешняя переменная видна
            System.out.println(innerVar); // OK
        }
        // Блок кода закончился

        // System.out.println(innerVar); // ОШИБКА КОМПИЛЯЦИИ! Cannot find symbol 'innerVar'
        System.out.println(outerVar); // OK
    }
    ```

**Совет из практики:** Всегда старайтесь **инициализировать переменные сразу при объявлении**, где это возможно. Это делает код более предсказуемым и защищает от ошибок `might not have been initialized`. Объявляйте переменные как можно ближе к месту их первого использования, чтобы не загромождать начало метода и улучшать читаемость.
## Переменные и типы данных <a name="переменные-и-типы-данных"></a>

### Примитивные типы <a name="примитивные-типы"></a>
Хранят непосредственно значение. Живут в стеке. Быстрые и легковесные.

| Тип       | Размер | Описание                                    | Пример                          |
| :-------- | :----- | :------------------------------------------ | :------------------------------ |
| `byte`    | 8 bit  | Целое число                                 | `byte b = 100;`                 |
| `short`   | 16 bit | Целое число                                 | `short s = 30000;`              |
| `int`     | 32 bit | Целое число                                 | `int i = 1000000;`              |
| `long`    | 64 bit | Целое число                                 | `long l = 100L;` // L в конце   |
| `float`   | 32 bit | Число с плавающей точкой                    | `float f = 3.14f;` // f в конце |
| `double`  | 64 bit | Число с плавающей точкой (двойная точность) | `double d = 3.14;`              |
| `char`    | 16 bit | Один символ Unicode                         | `char c = 'A';`                 |
| `boolean` | ~      | Логическое значение `true` / `false`        | `boolean flag = true;`          |

**Ошибка №1:** Использование `==` для сравнения чисел с плавающей точкой. Из-за ошибок округления прямое сравнение ненадежно. Всегда используйте проверку на допустимую погрешность:
```java
// ПЛОХО:
if (a == b) { ... }

// ХОРОШО:
if (Math.abs(a - b) < 0.0001) { ... }
```

### Ссылочные типы <a name="ссылочные-типы"></a>
Переменные этих типов хранят не сам объект, а ссылку (адрес) на объект в куче (heap). К ним относятся все классы, массивы, интерфейсы, перечисления (enums).
```java
String text = "Hello"; // 'text' - ссылка на объект String в куче
int[] numbers = new int[10]; // numbers - ссылка на массив
MyFirstClass obj = new MyFirstClass(); // obj - ссылка на объект
```

**Ошибка №2:** Оператор `==` для ссылочных типов сравнивает ссылки (адреса в памяти), а не содержимое объектов!
```java
String s1 = new String("Hello");
String s2 = new String("Hello");

System.out.println(s1 == s2); // FALSE! Сравниваются ссылки на разные объекты.
System.out.println(s1.equals(s2)); // TRUE! Сравнивается содержимое (логическая эквивалентность).
```

### Ключевое слово `var` (Java 10+) <a name="ключевое-слово-var"></a>
Позволяет объявить локальную переменную без явного указания типа. Компилятор сам определит тип по инициализатору.
```java
var list = new ArrayList<String>(); // тип list - ArrayList<String>
var message = "Hello World"; // тип message - String
```
**Совет:** Используйте `var` там, где тип очевиден из правой части выражения, чтобы сделать код менее многословным. Но не злоупотребляйте — если тип непонятен, лучше указать его явно для читаемости.
**Плохо:** `var data = processData();` // Что за тип возвращает `processData()`? Непонятно.

---

## Операторы <a name="операторы"></a>
Арифметические: `+`, `-`, `*`, `/`, `%`
Операторы сравнения: `==`, `!=`, `>`, `<`, `>=`, `<=`
Логические: `&&` (и), `||` (или), `!` (не)

**Подводный камень:** Короткий цикл вычислений (short-circuit). В выражениях с `&&` и `||` правый операнд вычисляется только если это необходимо.
```java
if (a != null && a.isValid()) { ... } // Если a == null, a.isValid() вызван не будет, это безопасно.
```

---

## Управляющие конструкции <a name="управляющие-конструкции"></a>

### Условные операторы <a name="условные-операторы"></a>
**if-else:**
```java
if (condition) {
    // ...
} else if (anotherCondition) {
    // ...
} else {
    // ...
}
```

**switch (Традиционный и modern):**
```java
// Старый стиль (до Java 14) - подвержен ошибкам из-за 'break'
int day = 3;
String dayName;
switch (day) {
    case 1:
        dayName = "Monday";
        break; // Если забыть break, выполнение "провалится" дальше!
    case 2:
        dayName = "Tuesday";
        break;
    default:
        dayName = "Unknown";
}

// Новый стиль (Java 14+, выражение ->, yield)
String dayName = switch (day) {
    case 1 -> "Monday"; // Нет проваливания, break не нужен
    case 2 -> "Tuesday";
    case 3 -> {
        // Для сложной логики можно использовать блок с yield
        String fullName = "Wednesday";
        yield fullName;
    }
    default -> "Unknown";
};
```
**Совет:** Всегда используйте modern `switch`. Он безопаснее и выразительнее.

### Циклы <a name="циклы"></a>
**for:**
```java
for (int i = 0; i < 10; i++) {
    System.out.println(i);
}
```

**foreach (улучшенный for):**
```java
int[] numbers = {1, 2, 3};
for (int num : numbers) { // Для каждого элемента в numbers
    System.out.println(num);
}
```

**while / do-while:**
```java
while (condition) {
    // ...
}

do {
    // Выполнится хотя бы один раз
} while (condition);
```

---


## Структура программы: Кирпичики и фундамент <a name="структура-программы"></a>

### Классы <a name="классы"></a>
Вся программа на Java состоит из классов. Класс — это шаблон для создания объектов, описывающий их состояние (поля) и поведение (методы).

```java
// Ключевое слово 'public' делает класс доступным из любого другого класса
// Имя класса должно совпадать с именем файла (MyFirstClass.java)
public class MyFirstClass {

    // Поле (состояние) класса. private - модификатор доступа, означающий инкапсуляцию.
    private int myField;

    // Конструктор. Вызывается при создании объекта через 'new'
    public MyFirstClass(int initialValue) {
        this.myField = initialValue; // 'this' ссылается на текущий экземпляр объекта
    }

    // Метод (поведение)
    public void myMethod() {
        System.out.println("The value is: " + myField);
    }
}
```

### Методы <a name="методы"></a>
Методы определяют действия, которые объект может совершать.
Синтаксис:
`[модификаторы] возвращаемый_тип имя_метода([параметры]) { // тело метода }`

*   `void` — если метод ничего не возвращает.
*   `return` — немедленно завершает метод и возвращает значение.

## Классы, Абстрактные Классы и Интерфейсы: Фундамент Объектно-Ориентированного Дизайна <a name="ооп-углубленно"></a>

### 1. Классы: Чертежи ваших объектов <a name="классы-углубленно"></a>

**Базовое понятие:** Класс — это прежде всего **чертеж** или **шаблон**, на основе которого создаются объекты (экземпляры). Он описывает:
1.  **Состояние (State):** Данные, которые будет хранить объект. Это *поля класса* (переменные).
2.  **Поведение (Behavior):** Действия, которые объект может выполнять. Это *методы класса* (функции).

**Простая аналогия:** Представьте класс `CookieCutter` (формочка для печенья).
*   **Класс** — это сама формочка (ее форма, например, звезды).
*   **Объект** — это конкретное печенье, вырезанное этой формочкой.
*   **Поле** класса — это, например, `size` (размер формочки).
*   **Метод** класса — это `cut()` (вырезать печенье).

**Синтаксис и компоненты:**

```java
// Модификатор 'public' означает, что класс доступен из любого другого класса
public class Car {

    // 1. Поля (состояние) - обычно private (принцип инкапсуляции)
    private String model; // Марка машины
    private int year;     // Год выпуска
    private boolean isRunning; // Заведена ли машина

    // 2. Конструктор - специальный метод для создания НОВОГО объекта (экземпляра) класса.
    // Вызывается через оператор 'new Car(...)'
    // Имя конструктора всегда совпадает с именем класса.
    public Car(String model, int year) {
        // 'this' ссылается на текущий экземпляр объекта (на "ту самую" машину, которую сейчас создают)
        this.model = model; // Полю model присваиваем значение из параметра model
        this.year = year;
        this.isRunning = false; // По умолчанию машина заглушена
    }

    // 3. Методы (поведение) - обычно public
    public void startEngine() {
        isRunning = true;
        System.out.println("Vroom-vroom! The " + model + " is started.");
    }

    public void stopEngine() {
        isRunning = false;
        System.out.println("The engine of " + model + " is stopped.");
    }

    // Геттер (метод для получения значения private-поля)
    public String getModel() {
        return model;
    }

    // Сеттер (метод для установки значения private-поля с возможной проверкой)
    public void setYear(int year) {
        if (year > 1886) { // Первый автомобиль был создан в 1886 :)
            this.year = year;
        }
    }
}

// Использование (в другом классе, например, в Main)
public class Main {
    public static void main(String[] args) {
        // Создаем объект (экземпляр) класса Car с помощью конструктора
        Car myCar = new Car("Tesla Model 3", 2023);
        Car oldCar = new Car("Ford T", 1908);

        // Вызываем методы у объекта
        myCar.startEngine(); // Вывод: Vroom-vroom! The Tesla Model 3 is started.
        oldCar.startEngine();

        // Используем геттер
        System.out.println("My car is a " + myCar.getModel());

        // Используем сеттер
        oldCar.setYear(2024); // Ничего не произойдет, проверка не пройдет
        oldCar.setYear(1909); // Год успешно поменяется
    }
}
```

**Итог по классам:** Класс — это основа. Вы описываете в нем всё, что нужно для создания полноценных, самостоятельных объектов с их собственными данными и поведением.

### 2. Абстрактные Классы: Недоопределенные чертежи <a name="абстрактные-классы-углубленно"></a>
**Базовое понятие:** Это класс, помеченный ключевым словом `abstract`. Он представляет собой **неполный чертеж**. Его главная цель — быть родителем для других классов, объединяя их общую логику.

**Зачем они нужны?**
*   **Нельзя создать экземпляр:** `new AbstractClass()` — ошибка компиляции.
*   **Может содержать абстрактные методы:** Методы без реализации (без тела `{}`). Они говорят: "Все мои потомки *обязаны* уметь это делать, но как именно — решат они сами".
*   **Может содержать обычные методы:** С готовой реализацией, которая наследуется потомками.

**Аналогия:** Представьте абстрактный класс `Shape` (Фигура).
*   У любой фигуры есть площадь. *Но как ее вычислить?* Для круга — одна формула, для квадрата — другая.
*   Мы обязываем все фигуры *иметь метод* `calculateArea()`, но *не реализуем его* на уровне фигуры.

**Синтаксис:**

```java
// Абстрактный класс
public abstract class Shape {

    // Обычное поле - есть у всех фигур
    private String color;

    // Конструктор - он нужен, чтобы инициализировать поля предка
    public Shape(String color) {
        this.color = color;
    }

    // Абстрактный метод - не имеет тела, только сигнатура.
    // Класс, содержащий абстрактный метод, ДОЛЖЕН быть абстрактным.
    public abstract double calculateArea();

    // Обычный метод с реализацией - есть у всех фигур
    public String getColor() {
        return color;
    }

    // Еще один обычный метод
    public void printInfo() {
        System.out.println("I'm a " + color + " shape.");
    }
}

// Конкретный класс-наследник (Concrete Class)
public class Circle extends Shape { // extends - ключевое слово для наследования

    // Свое, специфичное поле
    private double radius;

    // Конструктор
    public Circle(String color, double radius) {
        super(color); // super() вызывает конструктор родительского класса (Shape)
        this.radius = radius;
    }

    // ОБЯЗАТЕЛЬНАЯ реализация абстрактного метода родителя
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }

    // Свой специфичный метод
    public double getCircumference() {
        return 2 * Math.PI * radius;
    }
}

// Использование
public class Main {
    public static void main(String[] args) {
        // Shape shape = new Shape("red"); // ОШИБКА! Нельзя создать экземпляр абстрактного класса

        Shape myCircle = new Circle("blue", 5.0); // Полиморфизм: ссылка типа Shape на объект Circle
        System.out.println("Area: " + myCircle.calculateArea()); // Работает! Вызовется реализация из Circle
        myCircle.printInfo(); // Унаследованный метод

        // myCircle.getCircumference(); // ОШИБКА! У ссылки типа Shape нет такого метода
    }
}
```

**Итог по абстрактным классам:** Используйте их, когда у группы классов есть четкая иерархия "is-a" (является) и общая логика, но часть поведения должна быть реализована по-разному для каждого потомка.

### 3. Интерфейсы: Контракты на поведение <a name="интерфейсы-углубленно"></a>

**Базовое понятие:** Интерфейс — это чистейший **контракт**. Он определяет *что* класс должен делать, но не *как*. До Java 8 он мог содержать только абстрактные методы. Сейчас возможности сильно расширились.

**Зачем они нужны?**
*   Обеспечивают **множественное "наследование"** (реализацию нескольких контрактов одним классом).
*   Позволяют достичь **слабой связанности (loose coupling)** компонентов системы. Код зависит от абстракции (интерфейса), а не от конкретной реализации.
*   Определяют роль, которую может играть объект.

**Аналогия:** Интерфейс `USB`.
*   У него есть строгий контракт: разъем, напряжение, protocol передачи данных.
*   Неважно, кто производитель устройства (флешка, клавиатура, мышь), если оно реализует контракт `USB`, оно гарантированно заработает при подключении к USB-порту.

**Эволюция интерфейсов:**

```java
// До Java 8 (только абстрактные методы и константы)
public interface Drawable {
    // Неявно всегда 'public static final'
    String DEFAULT_COLOR = "black";

    // Неявно всегда 'public abstract'
    void draw();
}

// С Java 8+ (добавились default и static методы)
public interface Drawable {

    void draw(); // abstract метод - все еще основа контракта

    // default метод - реализация по умолчанию для всех, кто реализует интерфейс.
    // Нужен для обратной совместимости. Можно переопределить.
    default void setColor(String color) {
        System.out.println("Setting color to " + color);
        // Реальная логика установки цвета была бы здесь
    }

    // static метод - принадлежит самому интерфейсу, вызывается как Drawable.printInfo()
    // Не наследуется реализующими классами.
    static void printInfo() {
        System.out.println("This is the Drawable interface.");
    }
}

// Класс может реализовать (implements) множество интерфейсов
public class Button implements Drawable, Clickable { // Два контракта сразу!

    private String label;

    // ОБЯЗАТЕЛЬНАЯ реализация абстрактного метода из Drawable
    @Override
    public void draw() {
        System.out.println("Drawing a button with label: " + label);
    }

    // Реализация метода из Clickable (предположим, что такой интерфейс есть)
    @Override
    public void onClick() {
        System.out.println("Button was clicked!");
    }

    // Метод setColor() НЕ ОБЯЗАТЕЛЕН к реализации, т.к. есть default реализация.
    // Но мы можем его переопределить, если захотим:
    // @Override
    // public void setColor(String color) { ... }
}

// Использование
public class Main {
    public static void main(String[] args) {

        Drawable button = new Button(); // Полиморфизм: ссылка типа интерфейса
        button.draw(); // Вызовется реализация из Button
        button.setColor("red"); // Вызовется default-метод из интерфейса

        Drawable.printInfo(); // Вызов static-метода интерфейса

        // Если нужно поведение другого интерфейса:
        if (button instanceof Clickable) {
            Clickable clickableButton = (Clickable) button;
            clickableButton.onClick();
        }
    }
}
```

### Сводка: Ключевые различия и что когда использовать <a name="сравнение-ооп"></a>

| Характеристика          | Класс                                                        | Абстрактный Класс                                                     | Интерфейс (Modern)                                                                                           |
| :---------------------- | :----------------------------------------------------------- | :-------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------- |
| **Экземпляры**          | Можно создавать (`new`)                                      | **Нельзя** создавать                                                  | **Нельзя** создавать                                                                                         |
| **Поля**                | Любые (обычно `private`)                                     | Любые (обычно `private`)                                              | Только `public static final` (константы)                                                                     |
| **Методы**              | Любые                                                        | Абстрактные и/или реализованные                                       | Абстрактные, `default`, `static`                                                                             |
| **Наследование**        | Один класс (`extends`)                                       | Один абстрактный класс (`extends`)                                    | **Много** интерфейсов (`implements`)                                                                         |
| **Суть**                | **Реализация** и **состояние**                               | **Частичная реализация** для иерархии "is-a"                          | **Контракт** (поведение) для ролей "can-do"                                                                  |
| **Когда использовать?** | Для создания объектов с конкретными свойствами и поведением. | Когда несколько классов тесно связаны иерархией и имеют общую логику. | Когда нужно определить роль, которую могут играть **несвязанные** классы. Для достижения слабой связанности. |

### Метод `main` <a name="метод-main"></a>
Точка входа в программу. JVM ищет именно его, чтобы начать выполнение.
```java
public static void main(String[] args) {
    // Создание объекта
    MyFirstClass obj = new MyFirstClass(42);
    obj.myMethod(); // Вызов метода
}
```
*   `static`: метод принадлежит классу, а не экземпляру. Для вызова не нужен объект.
*   `String[] args`: аргументы командной строки.

### Пакеты и импорты <a name="пакеты-и-импорты"></a>
*   **Пакеты** (`package`) организуют классы в пространства имен для избежания конфликтов. Это как папки на диске.
    ```java
    package com.mycompany.myaplication.util;
    ```
*   **Импорты** (`import`) позволяют использовать классы из других пакетов без указания полного имени.
    ```java
    import java.util.ArrayList; // Импорт одного класса
    import java.util.*; // Импорт всех классов из пакета (не рекомендуется без необходимости!)
    ```

**Подводный камень:** `import java.util.*;` не импортирует подпакеты! Он импортирует только классы непосредственно из `java.util`. Также избегайте "диких" импортов в больших проектах — это ухудшает читаемость: непонятно, откуда пришел класс.

---

## Аннотации в Java: Метаданные для кода<a name="аннотации-основы"></a>

**Аннотации** — это форма метаданных, которые предоставляют данные о программе, но не являются частью самой программы. Они не имеют прямого влияния на операцию кода, который они аннотируют.

**Простая аналогия:** Представьте, что вы читаете книгу с заметками на полях. Эти заметки:
1. Не меняют основной текст книги
2. Несут дополнительную информацию для читателя
3. Могут давать инструкции ("обрати внимание на это", "это важно")

Аннотации в Java — это такие же "заметки на полях" для вашего кода, которые могут быть прочитаны компилятором, инструментами сборки или фреймворками во время выполнения.

### Базовый синтаксис <a name="аннотации-синтаксис"></a>

Аннотации начинаются с символа `@` и могут иметь элементы, которые принимают значения:

```java
@AnnotationName
@AnnotationName(someValue = "value")
@AnnotationName(value = "value", number = 42)
```

### Встроенные аннотации в Java <a name="встроенные-аннотации"></a>

### 1. Аннотации для компилятора

**`@Override`** — указывает, что метод переопределяет метод суперкласса.
```java
public class Parent {
    public void doSomething() {
        // ...
    }
}

public class Child extends Parent {
    @Override // Убедитесь, что это действительно переопределение
    public void doSomething() {
        // ...
    }
}
```
**Зачем нужно:** Если вы допустите ошибку в имени метода (например, `doSomething` вместо `doSomething`), компилятор выдаст ошибку, а не просто создаст новый метод.

**`@Deprecated`** — указывает, что элемент устарел и не рекомендуется к использованию.
```java
public class OldClass {
    @Deprecated
    public void oldMethod() {
        // ...
    }
    
    @Deprecated(since = "2.0", forRemoval = true)
    public void veryOldMethod() {
        // ...
    }
}
```
**Зачем нужно:** Компилятор выдаст предупреждение при использовании такого элемента. Современные IDE также подсвечивают устаревшие методы.

**`@SuppressWarnings`** — говорит компилятору подавить определенные предупреждения.
```java
@SuppressWarnings("unchecked")
public List<String> getStrings() {
    return (List<String>) someObject; // Без аннотации было бы предупреждение о непроверенном преобразовании
}
```
**Совет:** Используйте эту аннотацию осторожно и только когда полностью уверены в безопасности операции.

**`@FunctionalInterface`** — указывает, что интерфейс предназначен быть функциональным интерфейсом.
```java
@FunctionalInterface
public interface SimpleFunction {
    void execute();
    // boolean equals(Object obj); // Разрешено - метод из Object
    // void anotherMethod(); // ОШИБКА! Функциональный интерфейс должен иметь ровно один абстрактный метод
}
```
**Зачем нужно:** Гарантирует, что интерфейс имеет ровно один абстрактный метод и может быть использован с лямбда-выражениями.

### 2. Аннотации для обработки во время выполнения

Эти аннотации доступны через reflection и используются фреймворками.

**`@Retention`** — определяет, как долго сохраняется аннотация:
- `RetentionPolicy.SOURCE` — только в исходном коде (отбрасываются компилятором)
- `RetentionPolicy.CLASS` — сохраняются в байт-коде, но недоступны во время выполнения (по умолчанию)
- `RetentionPolicy.RUNTIME` — сохраняются в байт-коде и доступны через reflection во время выполнения

**`@Target`** — ограничивает, к каким элементам можно применять аннотацию:
- `ElementType.TYPE` — классы, интерфейсы, перечисления
- `ElementType.FIELD` — поля
- `ElementType.METHOD` — методы
- `ElementType.PARAMETER` — параметры
- `ElementType.CONSTRUCTOR` — конструкторы
- И другие...

**`@Inherited`** — указывает, что аннотация автоматически наследуется подклассами.

**`@Repeatable`** (Java 8+) — позволяет использовать аннотацию многократно на одном элементе.

### Создание собственных аннотаций <a name="создание-аннотаций"></a>

Давайте создадим простую аннотацию для логгирования выполнения методов:

```java
import java.lang.annotation.ElementType;
import java.lang.annotation.Retention;
import java.lang.annotation.RetentionPolicy;
import java.lang.annotation.Target;

// Аннотация будет доступна во время выполнения
@Retention(RetentionPolicy.RUNTIME)
// Аннотацию можно применять только к методам
@Target(ElementType.METHOD)
public @interface Loggable {
    // Элементы аннотации выглядят как методы, но фактически это поля
    // value() - специальный элемент, который можно использовать без указания имени
    String value() default "Executing method";
    
    // Можно определить другие элементы
    boolean logParameters() default false;
    LogLevel level() default LogLevel.INFO;
}

// Перечисление для уровня логирования
enum LogLevel {
    DEBUG, INFO, WARN, ERROR
}
```

### Использование аннотации <a name="использование-аннотации"></a>

Теперь применим нашу аннотацию к классу:

```java
public class BusinessService {
    
    @Loggable("Processing user data")
    public void processUserData(User user) {
        // Логика обработки
    }
    
    @Loggable(value = "Calculating statistics", logParameters = true, level = LogLevel.DEBUG)
    public Statistics calculateStats(String category, int year) {
        // Логика расчета
        return new Statistics();
    }
}
```

### Обработка аннотаций через Reflection <a name="обработка-аннотаций"></a>

Сама по себе аннотация ничего не делает. Её силу раскрывает код, который её обрабатывает:

```java
import java.lang.reflect.Method;

public class LoggingAspect {
    
    public static void processAnnotations(Object target) {
        Class<?> clazz = target.getClass();
        
        for (Method method : clazz.getDeclaredMethods()) {
            if (method.isAnnotationPresent(Loggable.class)) {
                Loggable annotation = method.getAnnotation(Loggable.class);
                String message = annotation.value();
                boolean logParams = annotation.logParameters();
                LogLevel level = annotation.level();
                
                // Здесь могла бы быть реальная логика логирования
                System.out.println(level + ": " + message);
                
                if (logParams) {
                    System.out.println("Method parameters would be logged here");
                }
                
                // Мы также могли бы здесь перехватывать вызовы метода
                // и добавлять логирование до/после выполнения
            }
        }
    }
    
    public static void main(String[] args) {
        BusinessService service = new BusinessService();
        processAnnotations(service);
    }
}
```

### Практическое применение в реальных проектах <a name="практическое-применение"></a>

Аннотации широко используются в современных фреймворках:

1. **Spring Framework**:
   - `@Component`, `@Service`, `@Repository` — для объявления bean-компонентов
   - `@Autowired` — для внедрения зависимостей
   - `@RequestMapping` — для маппинга URL в Spring MVC

2. **Hibernate/JPA**:
   - `@Entity` — для объявления сущности
   - `@Table` — для маппинга на таблицу БД
   - `@Column` — для маппинга на столбец таблицы

3. **JUnit**:
   - `@Test` — для методов как тестов
   - `@BeforeEach`, `@AfterEach` — для методов, выполняемых до/после каждого теста

### Лучшие практики и советы <a name="аннотации-лучшие-практики"></a>

1. **Создавайте аннотации с четкой целью** — не создавайте аннотации "на всякий случай".
2. **Документируйте назначение аннотации** — особенно если она предназначена для использования другими разработчиками.
3. **Используйте значения по умолчанию** — делайте аннотации максимально удобными в использовании.
4. **Помните о производительности** — обработка аннотаций через reflection может быть дорогостоящей операцией.
5. **В FAANG-подобных компаниях** ожидают понимания не только как использовать аннотации, но и как они работают на уровне байт-кода и JVM.

### FAQ по аннотациям <a name="аннотации-faq"></a>

**Q: Аннотации замедляют выполнение программы?**
**A:** Сами по себе аннотации не замедляют выполнение, так как это просто метаданные. Однако их обработка через reflection может быть относительно медленной. В высокопроизводительных системах часто используют кодогенерацию на этапе компиляции вместо reflection во время выполнения.

**Q: Можно ли применять несколько аннотаций к одному элементу?**
**A:** Да, начиная с Java 5 можно применять несколько аннотаций к одному элементу. С Java 8 появилась возможность использовать повторяющиеся аннотации с помощью `@Repeatable`.

**Q: Как получить аннотации во время выполнения?**
**A:** С помощью Reflection API: `method.getAnnotation()`, `field.getAnnotations()`, `class.getDeclaredAnnotations()` и т. Д.

**Q: Могут ли аннотации наследоваться?**
**A:** По умолчанию аннотации не наследуются. Но если аннотация помечена аннотацией `@Inherited`, то она будет унаследована подклассами.

**Q: В чем разница между `@Override` и `@Overrides`?**
**A:** `@Override` — это корректная аннотация. `@Overrides` не существует — это распространенная опечатка.

Аннотации — мощный инструмент, который позволяет писать более декларативный и выразительный код. Понимание их работы необходимо для эффективного использования современных Java-фреймворков и создания собственных инструментов и библиотек.

---
## Обработка исключений <a name="обработка-исключений"></a>
Механизм обработки ошибок и исключительных ситуаций.

```java
try {
    // Код, который может抛出 исключение
    File file = new File("nonexistent.txt");
    FileInputStream stream = new FileInputStream(file);
} catch (FileNotFoundException e) { // Ловим конкретное исключение
    // Обрабатываем ситуацию "файл не найден"
    System.err.println("File was not found: " + e.getMessage());
    // Логируем исключение
} catch (IOException e) { // Ловим более общее исключение
    e.printStackTrace();
} finally {
    // Этот блок выполняется ВСЕГДА, было исключение или нет.
    // Здесь закрывают ресурсы (потоки, соединения и т.д.).
}
```

**Совет:** Всегда закрывайте ресурсы в `finally` или, что еще лучше, используйте **try-with-resources** (Java 7+). Это избавит от утечек ресурсов.
```java
// Автоматически закрывает ресурсы, объявленные в скобках
try (FileInputStream stream = new FileInputStream(file)) {
    // Работаем со stream
} catch (IOException e) {
    // Обрабатываем ошибку
}
// finally для закрытия не нужен, stream будет закрыт автоматически
```

---

## ООП в Java: Сердце языка <a name="ооп-в-java"></a>

### Инкапсуляция <a name="инкапсуляция"></a>
Сокрытие внутреннего состояния объекта и предоставление контролируемого доступа к нему через методы (геттеры/сеттеры).
```java
public class BankAccount {
    private double balance; // Поле приватное, прямое изменение извне невозможно

    // Геттер (контролируемый доступ на чтение)
    public double getBalance() {
        return balance;
    }

    // Сеттер (контролируемый доступ на запись)
    public void deposit(double amount) {
        if (amount > 0) { // Валидация!
            balance += amount;
        }
    }
}
```

### Наследование <a name="наследование"></a>
Механизм, позволяющий создать новый класс на основе существующего.
```java
public class Animal { // Родительский (супер)класс
    public void eat() {
        System.out.println("Animal is eating");
    }
}

public class Dog extends Animal { // Класс Dog наследует от Animal
    public void bark() {
        System.out.println("Woof!");
    }
    // Метод eat() тоже доступен объекту Dog
}

// Использование
Dog myDog = new Dog();
myDog.eat(); // Унаследованный метод
myDog.bark(); // Собственный метод
```

**Подводный камень:** В Java только **одиночное наследование**. Класс может наследовать только от одного суперкласса. Множественное наследование реализуется через интерфейсы.

### Полиморфизм <a name="полиморфизм"></a>
Возможность работать с объектами разных классов через общий интерфейс.
1.  **Переопределение методов (Override):** Дочерний класс предоставляет свою реализацию метода, объявленного в родительском классе. Используется аннотация `@Override`.
    ```java
    public class Cat extends Animal {
        @Override // Аннотация помогает избежать опечаток (например, если написать 'eet')
        public void eat() {
            System.out.println("Cat is eating fish");
        }
    }

    Animal myAnimal = new Cat();
    myAnimal.eat(); // Выведет "Cat is eating fish". Вызывается переопределенная версия.
    ```

### Абстракция <a name="абстракция"></a>
**Абстрактные классы:** Классы, которые нельзя инициировать (создать объект). Они являются шаблонами для других классов. Могут содержать как реализованные, так и абстрактные (без реализации) методы.
```java
public abstract class Shape {
    // Абстрактный метод (не имеет тела)
    public abstract double calculateArea();

    // Обычный метод с реализацией
    public void printInfo() {
        System.out.println("This is a shape.");
    }
}

public class Circle extends Shape {
    private double radius;

    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
}
```

**Интерфейсы (до Java 8 и после):** Изначально — контракт, содержащий только абстрактные методы. Сейчас могут содержать методы по умолчанию (`default`) и статические (`static`) методы.
```java
public interface Drawable {
    // Абстрактный метод (неявно public abstract)
    void draw();

    // Метод по умолчанию с реализацией
    default void setColor(String color) {
        System.out.println("Setting color to " + color);
    }
}

public class Button implements Drawable {
    @Override
    public void draw() {
        System.out.println("Drawing a button");
    }
}
```

**Совет из практики:** Prefer composition over inheritance (Отдавайте предпочтение композиции перед наследованием). Наследование создает жесткую связь между классами. Композиция (включение одного объекта в другой) часто дает большую гибкость и простоту тестирования.
```java
// Наследование (менее гибко)
class Engine { ... }
class Car extends Engine { ... } // Автомобиль - это двигатель?

// Композиция (лучше!)
class Car {
    private Engine engine; // Автомобиль имеет двигатель
    public Car(Engine engine) {
        this.engine = engine;
    }
}
```


**Совет из практики:**
1.  **Prefer composition over inheritance:** Отдавайте предпочтение композиции (включению объектов) перед наследованием. Наследование — самое сильное связывание в ООП, его сложнее всего менять. Интерфейсы и композиция дают гораздо большую гибкость.
2.  **Program to an interface, not an implementation:** Пишите код, зависящий от интерфейсов, а не от конкретных классов. Ваш `Service` должен зависеть от `Repository`, а не от его конкретной реализации `MySqlRepository`. Это позволяет легко подменять реализации (например, на `InMemoryRepository` для тестов).
3.  **Абстрактные классы — для "is-a", Интерфейсы — для "has-a" / "can-do":** `Dog extends Animal` — хороший кандидат для абстрактного класса. `Dog implements Runnable, Barkable` — хорошее использование интерфейсов для описания способностей.
---

## Коллекции и Generics <a name="коллекции-и-generics"></a>
**Generics (Дженерики)** позволяют создавать типизированные коллекции и классы.
```java
// Без дженериков (Старый стиль, опасен)
List list = new ArrayList();
list.add("Hello");
String s = (String) list.get(0); // Требуется явное приведение типа

// С дженериками (Типобезопасно)
List<String> list = new ArrayList<>(); // С Java 7 можно использовать diamond operator <>
list.add("Hello");
String s = list.get(0); // Приведение типа не нужно, компилятор знает, что здесь String
```

**Основные интерфейсы коллекций:**
*   `List<>` — упорядоченная коллекция (список). Допускает дубликаты. (`ArrayList`, `LinkedList`)
*   `Set<>` — коллекция, не допускающая дубликатов. (`HashSet`, `TreeSet`)
*   `Map<K, V>` — не коллекция в прямом смысле, но часть фреймворка. Пары "ключ-значение". Ключи уникальны. (`HashMap`, `TreeMap`)

**Ошибка №3:** Изменение коллекции во время итерации по ней с помощью `for-each` приведет к `ConcurrentModificationException`.
```java
List<String> list = new ArrayList<>(Arrays.asList("a", "b", "c"));
for (String s : list) {
    if (s.equals("b")) {
        list.remove(s); // Выбросит ConcurrentModificationException!
    }
}
```
**Решение:** Использовать `Iterator` и его метод `remove()`, либо API коллекций из Java 8+ (`removeIf`).
```java
// Правильно с итератором
Iterator<String> iterator = list.iterator();
while (iterator.hasNext()) {
    String s = iterator.next();
    if (s.equals("b")) {
        iterator.remove(); // Безопасно
    }
}

// Правильно с Java 8+
list.removeIf(s -> s.equals("b"));
```

---

## Современный Java синтаксис (краткий обзор) <a name="современный-java-синтаксис"></a>

*   **Lambda Expressions (Java 8+):** Краткая форма записи анонимных классов.
    ```java
    // Было:
    button.addActionListener(new ActionListener() {
        @Override
        public void actionPerformed(ActionEvent e) {
            System.out.println("Clicked");
        }
    });

    // Стало:
    button.addActionListener(e -> System.out.println("Clicked"));
    ```

*   **Stream API (Java 8+):** Функциональный стиль для работы с данными.
    ```java
    List<String> names = Arrays.asList("John", "Alice", "Bob");
    List<String> filtered = names.stream()
                                .filter(name -> name.startsWith("A"))
                                .map(String::toUpperCase)
                                .collect(Collectors.toList()); // [ALICE]
    ```

*   **Modules (Java 9+):** Система модулей для организации больших приложений и усиления инкапсуляции.

---

## FAQ: Типичные вопросы и подводные камни <a name="faq"></a>

**Q: В чем разница между `==` и `.equals()`?**
**A:** `==` сравнивает примитивы по значению, а ссылки — по адресу в памяти. `equals()` — это метод, предназначенный для логического сравнения объектов (по умолчанию ведет себя как `==`, но переопределяется в классах типа `String`, `Integer` и т. Д.).

**Q: Что такое `String` pool?**
**A:** Это специальная область в heap памяти, где JVM хранит литералы строк для экономии памяти. При создании строки через литерал (`String s = "hello";`) JVM сначала ищет ее в пуле. Если находит, возвращает ссылку на существующий объект.
```java
String s1 = "hello";
String s2 = "hello";
String s3 = new String("hello");

System.out.println(s1 == s2); // true (обе ссылки указывают на один объект в пуле)
System.out.println(s1 == s3); // false (s3 создает новый объект вне пула)
```

**Q: Когда использовать `String`, а когда `StringBuilder` / `StringBuffer`?**
**A:** `String` — неизменяемый (immutable). Любая операция (конкатенация, замена) создает новый объект. Это дорого в циклах.
`StringBuilder` (не потокобезопасный, быстрее) и `StringBuffer` (потокобезопасный, медленнее) — изменяемые. Используйте их для интенсивных манипуляций со строками, особенно в циклах.

**Q: Что такое перегрузка методов (Overloading)?**
**A:** Это создание методов с одинаковыми именами, но разными параметрами (типом, количеством, порядком). Возвращаемый тип не учитывается.
```java
public class Printer {
    public void print(int number) { ... }
    public void print(String text) { ... } // Overloading
    // public int print(String text) { ... } // Ошибка компиляции! Сигнатура не отличается.
}
```

**Q: `ArrayList` vs `LinkedList`? Когда что использовать?**
**A:**
*   `ArrayList` — основан на массиве. Быстрый доступ по индексу (`O(1)`). Медленная вставка/удаление в середине списка (`O(n)`).
*   `LinkedList` — основан на двусвязном списке. Медленный доступ по индексу (`O(n)`). Быстрая вставка/удаление в начале/середине/конце, если есть итератор (`O(1)`).

**Выбор:** В 95% случаев используйте `ArrayList`. `LinkedList` нужен очень редко для специфичных сценариев.

---

## Заключение и лучшие практики <a name="заключение"></a>

**Лучшие практики из мира больших корпораций:**
1.  **Читаемость важнее краткости.** Пишите код так, чтобы его мог понять другой разработчик (или вы сами через полгода) без комментариев. Хорошие имена переменных и методов — ключ к успеху.
2.  **Принципы KISS и YAGNI.** Keep It Simple, Stupid. You Ain't Gonna Need It. Не усложняйте архитектуру заранее. Пишите самое простое решение, которое работает сейчас.
3.  **Не повторяйтесь (DRY).** Выносите повторяющуюся логику в методы/утилитные классы.
4.  **Код должен быть самодокументированным.** Комментарии пишите для объяснения "почему", а не "что". "Что" должно быть понятно из кода.
5.  **Пишите unit-тесты.** Хорошо протестированный код — это надежный код, который не боишься рефакторить. TDD (Test-Driven Development) — золотой стандарт.
6.  **Изучите Code Conventions от Google.** Единый стиль кода в команде — must have.
7.  **Освойте инструменты:** IDE (IntelliJ IDEA), системы сборки (Maven/Gradle), контроль версий (Git). 

Синтаксис — это только начало. Дальше — многопоточность, IO, рефлексия, паттерны проектирования, производительность и многое другое. Но с крепким фундаментом эти темы будут даваться намного легче.