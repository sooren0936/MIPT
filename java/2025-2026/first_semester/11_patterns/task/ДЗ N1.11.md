## Цель задания
Практическое применение трех ключевых паттернов. Понимание, когда и зачем использовать каждый паттерн.


## Предварительные действия
1. Создайте отдельную ветку для текущего дз
2. Создайте отдельную директорию в вашем проекте, где будут все классы по заданию ниже

## Задание: Data Service with Decorators (10 баллов)
**Задача**: Реализовать сервис данных с возможностью добавления дополнительной функциональности через декораторы

Требования:
0. Реализовать по шаблону ниже весь код (6 баллов)
1. Unit-тесты на каждый отдельный класс-декоратор (4 балла)

Шаблон кода:
```java
// Базовый интерфейс сервиса данных
interface DataService {
    Optional<String> findDataByKey(String key);

    void saveData(String key, String data);

    boolean deleteData(String key);
}

// Базовая реализация - работа с памятью
class SimpleDataService implements DataService {
    private Map<String, String> storage = new HashMap<>();

    @Override
    public Optional<String> findDataByKey(String key) {
        return Optional.of(storage.get(key));
    }

    @Override
    public void saveData(String key, String data) {
        storage.put(key, data);
    }

    @Override
    public boolean deleteData(String key) {
        return storage.remove(key) != null;
    }
}
```

Код для реализации (создайте отдельные файлы для каждого класса):
```java
    // TODO: Декоратор для кеширования
    //  Должен:
    //      1. При findDataByKey - кешировать результаты
    //      2. При saveData - обновлять данные в кэше
    //      3. При deleteData - инвалидировать кэш
    class CachingDecorator extends DataService {
        // todo: ваш код тут
    }

    // TODO: Декоратор для логирования
    //  Должен:
    //      1. При findDataByKey - логировать действие через System.out.println
    //      2. При saveData - логировать действие через System.out.println
    //      3. При deleteData - логировать действие через System.out.println
    class LoggingDecorator extends DataService {
        // todo: ваш код тут
    }

    // TODO: Декоратор для метрик
    //  Должен:
    //      1. При findDataByKey - замерять скорость работы метода и отправлять через MetricService (реализация уже есть внутри класса)
    //      2. При saveData - замерять скорость работы метода и отправлять через MetricService (реализация уже есть внутри класса)
    //      3. При deleteData - замерять скорость работы метода и отправлять через MetricService (реализация уже есть внутри класса)
    class MetricableDecorator extends DataService {
        // todo: ваш код тут

        public static class MetricService {
            public void sendMetric(Duration duration) {
                System.out.println("Метод выполнялся: " + duration.toString());
            }
        }
    }

    // TODO: Декоратор для валидации
    //  Должен:
    //      1. При findDataByKey - влидируются входные данные
    //      2. При saveData - влидируются входные данные
    //      3. При deleteData - влидируются входные данные
    class ValidationDecorator extends DataService {
        // todo: ваш код тут
    }
```

Пример работы с этими классами (ЭТО НЕ ТЕСТ - вам нужно написать самbv Unit-тесты через JUnit на каждый класс-декоратор):
```java
public static void main(String[] args) {
    final var service = new ValidationDecorator(
        new MetricableDecorator(
            new LoggingDecorator(
                new CachingDecorator(
                    new SimpleDataService()
                )
            )
        )
    );

    service.saveData("key", "data");
    final var data = service.findDataByKey("key");
    service.deleteData("key");
    final var noData = service.findDataByKey("key");
}
```
