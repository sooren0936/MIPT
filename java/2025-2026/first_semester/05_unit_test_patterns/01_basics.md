## Что такое Unit-тесты?

После того как вы закончили писать очередной кусок кода, вы хотите проверить, что он выполняет именно то, что задумывалось изначально. Процесс проверки соответствия кода требованиям и есть тестирование. Вы уже тестировали свой код - просто запустить приложение и потыкать в UI тоже считается. 
Результат этого процесса - ваша уверенность (до некоторой степени), что код, который вы написали, достаточно хорош, чтобы отдать его дальше.
Тестирование также позволяет вам улучшить знания о кодовой базе, лучше понять функциональные требования. 

Но с ручным тестированием есть много проблем. Можно что-то забыть по дороге, отвлечься и пропустить баг, это отнимает много времени, и его сложно автоматизировать.

Unit-тестирование - это концепт, который позволяет понять, что наши компоненты работают правильно по отдельности. 
Определение с Википедии:

> Модульное тестирование, иногда блочное тестирование или юнит-тестирование (англ. unit testing) — процесс в программировании,
> позволяющий проверить на корректность отдельные модули исходного кода программы, наборы из одного или более программных модулей вместе с соответствующими управляющими данными, процедурами использования и обработки.

Что можно считать отдельным модулем (unit)?

Unit работы - это сумма действий, которые происходят между двумя вызовами публичных методов в системе, имеющих конечный видимый результат.  
Конечный результат это то, что можно получить, не глядя во внутреннее состояние программы. Это может быть:

* Вызванный публичный метод, возвращающий значение
* Заметное изменение состояния или поведения системы до и после вызова (например, запись в лог)
* Обращение к сторонней системе, которую тест не может контролировать

Unit может быть как очень маленьким (один конкретный метод), так и достигать больших размеров (несколько классов/методов, объединенных одной целью).

Одним из самых сложных аспектов определения модульного теста является определение того, что можно считать "хорошим" тестом.
Хорошие Unit-тесты должны удовлетворять следующим требованиям:

* автоматические и повторяемые
* должно быть легко написать новый тест
* должны оставаться актуальными
* любой человек в команде может легко запустить все тесты
* должны работать быстро
* должны быть консистентными (одинаковый результат между запусками, если ничего не меняли в коде)
* должны быть изолированы (результат одного теста не влияет на выполнение других)
* Если тест упал, то должно быть легко найти, что пошло не так и где проблема

## Какие тесты можно считать хорошими

### Можно легко запустить свои тесты, написанные ранее (неделю/месяц/год назад)

Если нет, то мы оказываемся в ситуации, где невозможно понять, сломали ли вы новым кодом функционал, написанный ранее.
Требования к приложению постоянно меняются, и код меняется вместе с ними, и если у вас нет возможности (или вам лень) запускать тесты, проверяющие все ранее реализованные фичи, каждый раз, когда вы меняете код, вы не будете знать, работает ваше приложение или нет.

### Любой член команды может запустить тесты, написанные мной

Это очен похоже на предыдущий пункт, но рассматриваемый с другой перспективы. 
Мы хотим убедиться, что не сломаем чей-то еще код, когда что-то меняем.
Многие разработчики боятся вносить изменения в легаси код из-за того, что они не знают, зависит ли что-то в системе от кода, который они меняют.
По сути, они рискуют привести систему в состояние с неизвестной стабильностью. 
Страшно не знать, работает ли приложение по-прежнему, особенно если вы не писали этот код. 
Если бы вы знали, что ничего не сломаете, вы бы гораздо меньше боялись взяться за менее знакомый код, и у вас есть легкий способ проверить, что ничего не сломалось - модульные тесты.
Хорошие тесты могут быть доступны и запущены кем угодно.

### Все тесты можно легко запустить за несколько минут

Если вы не можете быстро запустить тесты, вы будете запускать их реже (ежедневно, еженедельно или даже ежемесячно). 
Проблема заключается в том, что, когда вы меняете код, вы хотите получить обратную связь как можно раньше, чтобы посмотреть, не сломалось ли что-нибудь.
Чем больше времени между запусками тестов, тем больше изменений, которые вы вносите в систему, и тем больше мест для поиска ошибок, когда вы обнаружите, что что-то сломали.
Хорошие тесты должны выполняться быстро.

### Все тесты можно запустить одним нажатием кнопки

Если вы не можете это сделать, вам нужно настроить машину, на которой тесты будут выполняться так, чтобы они работали правильно (настроить подключение к БД, например). Еще это может означать, что ваши модульные тесты не полностью автоматизированы. 
Если вы не можете полностью автоматизировать модульные тесты, вы, вероятно, будете избегать их многократного выполнения, как и все остальные в вашей команде.
Никто не любит увязать в деталях настройки, чтобы запускать тесты только для того, чтобы убедится, что система все еще работает. 
У разработчиков есть дела поважнее, например, писать больше кода.
Хорошие тесты должны выполняться легко, а не с кучей ручной работы.

## Разница с интеграционными тестами

Давайте рассматривать интеграционные тесты как любые тесты, которые небыстрые/противоречивые и которые используют одну или несколько реальных зависимостей тестируемых модулей.
Например, если в тесте используется реальное системное время, реальная файловая система или реальная база данных, будем думать о нем как об интеграционном тесте.

Само по себе использование внешних зависимостей не так плохо. Интеграционные тесты являются важными аналогами модульных тестов, но должны рассматриваться как отдельная сущность.
Если тест использует реальную базу данных, то он больше не выполняется независимо, и его действия потом будет сложно стереть.
Интеграционные тесты обычно намного медленнее модульных. Это тоже следствие внешних зависимостей: подключение к базе данных - не бесплатная операция и тоже занимает время. 
Когда тестов становится много (сотни или тысячи), время выполнения каждого отдельного теста становится критичным. 

Интеграционные тесты увеличивают риск возникновения другой проблемы - тестирования слишком большого количества вещей.
Тут можно провести аналогию с поломкой машины. Как узнать, в чем проблема? Как ее исправить?
Двигатель состоит из множества частей, работающих вместе, каждая из которых зависит от других.
Если автомобиль перестает двигаться, поломка может быть в любой из этих частей, а может быть и в нескольких.

То же самое происходит при написании кода. Много разработчиков тестируют свой код через ui.
Нажатие какой-либо кнопки запускает серию событий, компоненты работают вместе, чтобы получить окончательный результат.
Если тест неудачный, то это значит, что ошибка где-то внутри цепочки операций, и может быть трудно выяснить, что вызвало сбой всей цепочки.

Подведем итог: интеграционные тесты используют реальные зависимости; модульные тесты изолируют "единицу работы" от ее зависимостей, чтобы они легко согласовывались в своих результатах и могли легко контролировать и моделировать любой аспект поведения кода.

## Когда писать тесты?

Теперь вы знаете, как писать структурированные и надежные тесты, и следующий вопрос - когда писать тесты? 
Многие считают, что лучшее время для написания модульных тестов - после того, как код был написан. 
И это абсолютно нормальная практика. 

Но также есть те, кто предпочитают писать модульные тесты до написания самого кода. 
Этот подход называется разработкой, ориентированной на тестирование, или разработкой через тестирование (TDD).

TDD отличается от традиционной разработки, но по сути довольно проста:

1. Напишите неудачный тест, чтобы доказать, что код или функциональность отсутствуют в конечном продукте. 
Тест пишется так, как если бы код уже работал, поэтому то, что тест не пройден, означает, что в коде есть ошибка. 
2. Написать код, который соответствует ожиданиям вашего теста. Код при этом должен быть максимально простым и не делать ничего лишнего.
3. Рефакторинг кода. 

Когда тест пройден, можно либо перейти к следующему тесту, либо провести рефакторинг кода, чтобы сделать его более читабельным, удалить дублирование кода и т. д.
Рефакторинг можно проводить после написания нескольких тестов или после написания каждого теста. 
Это важная практика, потому что она упрощает чтение и сопровождение кода при прохождении всех ранее написанных тестов.

Хоть описание и очень простое, сам по себе фреймворк достаточно сложный в использовании и может принести больше вреда, чем пользы. Если интересно почитать про практики применения и паттерны, то есть хорошая книжка -  [Kent Beck’s Test-Driven Development: by Example](https://www.piter.com/product_by_id/147809326?recommended_by=instant_search&r46_search_query=%D1%8D%D0%BA%D1%81%D1%82%D1%80%D0%B5%D0%BC%D0%B0%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5%20%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5%3A%20%D1%80%D0%B0%D0%B7%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B0%20%D1%87%D0%B5%D1%80%D0%B5%D0%B7%20%D1%82%D0%B5%D1%81%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5).

## Фреймворки для тестирования

Как мы уже поняли, ручные тесты - отстой. 
Вы пишете свой код, нажимаете нужные клавиши в приложении, чтобы проверить, что все работает правильно, а затем повторяете все это в следующий раз, когда пишете новый код.
И вы должны не забыть проверить весь другой код, который мог сломаться из-за вашего. Больше ручной работы. Отлично.
Выполнение тестов полностью вручную, повторение одних и тех же действий снова и снова подвержено ошибкам и требует много времени.
Эти проблемы решаются с помощью инструментов для тестирования. 
Фреймворки модульного тестирования помогают разработчикам быстрее писать тесты с помощью набора известных API, автоматически выполнять эти тесты и легко просматривать результаты этих тестов.
И они никогда не забывают выполнить все тесты :) 

Давайте разберем, что они предлагают.
