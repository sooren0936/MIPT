# Работаем с ветками

Пока в вашем проекте довольно линейная история. Посмотреть его схему можно
командой `git log --graph`. Полоски слева — это дерево ветвлений. Сейчас ваша история больше похожа
на фонарный столб. Давайте добавим ей ветку.

Все работы из примера проводились в ветке `master`. В ней хранится последняя стабильная версия
приложения. Чтобы случайно не сломать мастер-ветку, для разработки новой функциональности или
исправления ошибок создаются отдельные ветки. Такой подход
называется [github-flow](https://guides.github.com/introduction/flow/).

В название новой ветки, предназначенной для разработки новой функциональности, добавляют префикс `feature/`. Он нужен,
чтобы отличать эту ветку от тех, где исправляют ошибки — к названию таких веток добавляется префикс `fix/`.

```shell
git checkout -b feature/branches
```

Команда `checkout` используется в Git, чтобы:

- переключиться на произвольную существующую ветку (`git checkout branch-name`);
- создать новую ветку от текущей (`git checkout -b new-branch-name`).

При команде `checkout` Git не даст переключиться на другую ветку, если в текущей есть
незакоммиченные изменения. Если вы не хотите коммитить изменения, используйте команду `git stash` —
она их спрячет. Позже изменения можно достать с помощью команд `git stash pop` или `git stash apply`.

Добавьте в ветку изменения и закоммитьте их.

```shell
echo "Команда checkout используется в Git, чтобы:" > branch_help.md
echo "* переключиться на произвольную существующую ветку (git checkout branch-name)" >> branch_help.md
echo "* создать новую ветку от текущей (git checkout -b new-branch-name)" >> branch_help.md
echo '- [Ветвление](./branch_help.md)' >> README.md

git add .
git commit -m "Добавлена информация о ветвлении"
```

Посмотреть список веток, которые доступны локально, можно командой `git branch`, а добавив
параметр `-a`, вы увидите ещё и ветки в репозитории GitHub.

```shell
* feature/branches
  master
  remotes/origin/master
```

Теперь отправьте изменения на сервер.

```shell
git push origin feature/branches
```

## Pull Request

Pull Request (или Merge Request) - это запрос на внесение изменений. По сути он является
визуализацией попытки совершения операции `git merge` или `git rebase` (про последнюю читайте далее
в курсе).

В чем разница? Давайте предположим, что мы хотим добавить новую фичу в проект. Самый простой способ
выглядит так:

1. Создаем новую ветку `feature/123` и переключаемся на нее.
2. Коммитим наши изменения.
3. Переключаемся на ветку `master`.
4. Вливаем в ветку `master` изменения из `feature/123`.
5. Пушим изменения в ветку `master`.

В этом подходе есть целый ряд проблем. Во-первых, мы вынуждены позволять контрибьютерам отправлять
изменения непосредственно в ветку `master`. Во-вторых, нет гарантии, что код, который был "запушен"
работает корректно. В-третьих, нет возможности проверить изменения на качество перед тем, как они
попадут в главную ветку.

Однако такая вещь как Pull Request появилась позже, чем Git. Как же люди совместно работали над
проектами? Ответ

- [patch-файлы](https://git-scm.com/book/ru/v2/%D0%A0%D0%B0%D1%81%D0%BF%D1%80%D0%B5%D0%B4%D0%B5%D0%BB%D0%B5%D0%BD%D0%BD%D1%8B%D0%B9-Git-%D0%A1%D0%BE%D0%BF%D1%80%D0%BE%D0%B2%D0%BE%D0%B6%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B0).

Patch - это список изменений, который были совершены пользователем. Если вы владелец репозитория,
пользователи могут присылать вам patch-файлы по e-mail. Просматривая их, вы сможете отобрать те,
которые соответствуют стандартам качества, и применить их, тем самым добавив изменения в репозиторий.

Некоторые проекты до сих пор разрабатываются с помощью такого подхода.
Например, [ядро Linux](https://github.com/torvalds/linux) (даже несмотря на то, что репозиторий
выложен на GitHub).

Этот подход гораздо лучше обычного слияния, так как позволяет запретить прямые коммиты в главную
ветку. Однако у него также есть недостатки:

1. Тяжело автоматизировать процесс тестирования новых запросов на изменения.
2. Большие затраты на code-review со стороны владельца репозитория.
3. Способ неудобен и довольно архаичен, что может отпугнуть потенциальных контрибьютеров.

В 2008 году появился GitHub. Это был далеко не первый публичный Git-хостинг, однако его создатели
предложили концепцию, которая перевернула игру и сделала GitHub лидером на рынке. Речь о Pull
Request.

Идея проста. Вы добавляете новую ветку и пушите в нее необходимые изменения. Далее создаете Pull
Request - запрос на слияние изменений из вашей ветки с `master`. После GitHub визуализирует, какие
файлы были добавлены, изменены, удалены и так далее. Другие люди могут оставлять комментарии к
вашему коду в реальном времени. Владелец же нажатием одной кнопки может принять ваш Pull Request и
влить изменения в главную ветку.

Но что если вы не хотите давать возможность создавать ветки в вашем репозитории? Предположим, вам
нужно получать только одобренные изменения в главную ветку. При этом наличие побочных веток, в
которых люди ведут работу, вам только мешает.

К счастью, решение есть - модель "Fork + Pull". Сторонние пользователи не могут создавать ветки в
вашем репозитории, однако они имеют возможность "форкнуть" его. То есть создать точную копию,
привязав к своей учетной записи. Так как этот репозиторий принадлежит им, можно свободно вносить в
него изменения. Далее повторяем те же шаги:

1. Создаем новую "фичовую" ветку
2. Пушим изменения

Только теперь при создании Pull Request'а GitHub предлагает пробросить его сразу в
репозиторий-родитель. Благодаря этому владелец получает список потенциальных изменений, не имея
необходимости давать доступ к репозиторию третьим лицам. Этот подход используется повсеместно в
разработке open-source проектов.

---
Идеи Pull Request и модели "Fork + Pull" стали настолько успешным, что другие вендоры Git-серверов
тоже реализовали эту концепцию (GitLab, BitBucket и так далее).

Сейчас Pull Request'ы де-факто являются стандартом в командной разработке.

## Pull Request в GitHub на практике

В предыдущем пункте мы запушили изменения в ветку `feature/branches`. Проверьте GitHub — там
появилось сообщение о новой ветке с предложением создать `pull-request`. Соглашайтесь.

![image](images/04_1_new_branch.png)

При создании `pull-request` укажите задачу, к которой он относится.

> Если такая плашка у вас не появилась, вы можете создать Pull Request вручную.
> Для этого кликните на вкладку `Pull Request`, нажмите `Create Pull Request` и в качестве
> `source branch` укажите `feature/branches` (или другую, если вы назвали ее иначе).

Теперь, чтобы завершить работу, вам нужно соединить изменения в ветке `feature/branches` с веткой `master`. 
Пока что вы сами и постановщик задач, и исполнитель, и ревьюер. Но скоро это изменится — для
выполнения задания этого модуля вы объединитесь с другими студентами.

Откройте `pull-request` и нажмите большую зелёную кнопку `Merge pull-request`. Не забудьте удалить
ветку после завершения `merge` — для этого тоже есть отдельная кнопка :)

Все ваши изменения попали в `master`. Теперь они - официальная часть проекта.

## А как работать в консоли?

Сейчас расскажем.

Для начала переключитесь на мастер-ветку и заберите изменения из `GitHub`.

```
git checkout master
# Git напомнит вам, что между локальной и удалённой веткой есть различия:
# Switched to branch 'master'
# Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.
#  (use "git pull" to update your local branch)
#
git pull
```

При использовании `pull` Git пытается сделать всё за вас. Он вливает любые внесённые коммиты в ветку,
в которой вы сейчас работаете. Команда `pull` автоматически сливает коммиты, не давая вам сначала
просмотреть их. Если вы не пристально следите за ветками, выполнение этой команды может привести к
частым конфликтам.

При использовании `fetch` Git собирает все коммиты из целевой ветки, которых нет в текущей ветке, и
сохраняет их в локальном репозитории. Однако он не сливает их в текущую ветку. Это особенно полезно,
если вам нужно постоянно обновлять свой репозиторий, но вы работаете над функциональностью,
неправильная реализация которой может негативно сказаться на проекте в целом. Чтобы слить коммиты в
основную ветвь, нужно использовать merge.

Фактически, по дефолту, `git pull` — это шоткод для последовательности двух команд: 
`git fetch` (получение изменений с сервера) и `git merge` (сливание в локальную копию).

Теперь создайте новую ветку и внесите правки.

```
git checkout -b feature/merge
echo "Для слияния двух веток нужна команда merge" > merge_help.md
echo "[Слияние веток](./merge_help.md)" >> README.md
```

Не забывайте проверять статус индекса и добавлять в него файлы.

```
git status
git add merge_help.md README.md
git commit -m "Добавлена информация о merge"
git log
```

Теперь переключитесь на ветку, в которую хотите влить `feature/merge`, и выполните слияние.

```
git checkout master
```

Теперь нужно слить изменения ветки `feature/merge` с основной веткой разработки.

```
git merge feature/merge
```

При желании вы можете отправить локальную мастер-ветку в GitHub
командой `git push origin branch-name`. Пока вы работаете один и полностью контролируете код, это
допустимо. При командной разработке все задачи принято выполнять в отдельных ветках и вливать
изменения через `pull-request`, а master заблокирован для прямого `push`.

## Безопасная отмена изменений

Команда `git revert` создаёт новые коммиты, в которых откачены старые изменения. Команду `revert`
используют в публичных ветках — тех, в которых ведут работу несколько человек. Например, её
применяют, если кто-то записал в мастер-ветку неработающий код.
