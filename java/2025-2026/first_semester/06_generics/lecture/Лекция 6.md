# Generics

Дженерики - очень мощная концепция в Java, которая не только позволяет писать более безопасный с
точки зрения типов код, но и избежать дублирования.

Основные преимущества:

- **Типобезопасность** - ошибки обнаруживаются при компиляции, а не во время выполнения
- **Устранение приведений типов** - код становится чище и читабельнее
- **Повторное использование** - один алгоритм можно использовать с разными типами
- **Лучшая документация** - код сам документирует свои намерения

## Проблема недостаточной полиморфности

Чтобы понять необходимость дженериков, давайте рассмотрим простой пример. Предположим, что мы хотим
создать контейнер для хранения объекта, который
печатает свое содержимое в консоль, а также отдает содержимое наружу. Посмотрите на пример кода
ниже:

```java
public class Container {
    private final Car value;

    public Container(Car value) {
        this.value = value;
    }

    public boolean isPresent() {
        return value != null;
    }

    public void print() {
        if (isPresent()) {
            System.out.println("Container value is: " + value);
        } else {
            System.out.println("Container is empty");
        }
    }

    public Car getValue() {
        return value;
    }
}
```

Метод `isPresent` возвращает статус того, есть ли какое-то значение в `Container-е`. Метод `print`
печатает содержимое в консоль в зависимости от статуса `isPresent`.
А метод `getValue` возвращает само значение `Car`. Все работает хорошо, но что если мы хотим
использовать `Container` и для других классов?
Более того, не каждый из них даже может имплементировать интерфейс `Vehicle`. Например, в
Container-е мы можем хранить строки, числа, другие кастомные объекты и так далее.
Написание нового класса под каждый отдельный тип данных `Container` (`ContainerCar`,
`ContainerString` и так далее) выглядит чрезмерно сложным и ненужным.
Но мы же с вами помним, что все классы в Java наследуются от `Object`. Значит, в качестве `value` мы
можем указать `Object`, и это даст нам возможность
использовать один и тот же класс для хранения совершенно разных объектов! Посмотрите на пример кода
ниже:

```java
public class Container {
    private final Object value;

    public Container(Object value) {
        this.value = value;
    }

    public boolean isPresent() {
        return value != null;
    }

    public void print() {
        if (isPresent()) {
            System.out.println("Container value is: " + value);
        } else {
            System.out.println("Container is empty");
        }
    }

    public Object getValue() {
        return value;
    }
}
```

Вроде как, мы решили проблему. Правда, тот код, который будет использовать `Container`, сильно
усложнится. Посмотрите на пример ниже:

```java
public class Main {
    public static void main(String[] args) {
        Container container = new Container(new Car(...));
        /* некоторая логика работы */
        Car car = (Car) container.getValue();
    }
}
```

Обратите внимание на строчку, где мы получаем значение из `Container`. В качестве типа там хранится
`Object`, но нам нужен `Car`, потому что именно его мы положили туда.
Значит, нам приходится делать _down cast_ (приведение предка к потомку).

В то время как _up cast_ (приведение потомка к предку) всегда безопасен, down cast таковым не
является. Посмотрите на пример кода ниже:

```java
public class Main {
    public static void main(String[] args) {
        String str = "abc";
        Object obj = (Object) str;
        LocalDate date = (LocalDate) obj;
    }
}
```

Сначала мы присваем строку в переменную `str`. Далее выполняем up cast к `Object` и присваиваем
результат в переменную `obj`.
Поскольку любой класс в Java наследуется от `Object`, эта операция безопасна.
В конце концов, мы пытаемся привести `Object` с помощью каста к типу `LocalDate`.

Класс `LocalDate` не является предком `String`, то есть они никак не связаны. Что же произойдет в
этом случае? Давайте запустим программу и посмотрим:

```
Exception in thread "main" java.lang.ClassCastException: class java.lang.String cannot be cast to class java.time.LocalDate (java.lang.String and java.time.LocalDate are in module java.base of loader 'bootstrap')
	at org.example.Main.main(Main.java:10)
```

Мы получили исключение `ClassCastException`. Отсюда можно сделать вывод, что использование `Object`
в качестве значение не является безопасным, потому что может привести
к неожиданным ошибкам.

## Внедрение дженериков

Давайте немного перепишем класс `Container`. Посмотрите на код ниже:

```java
public class Container<T> {
    private final T value;

    public Container(Object value) {
        this.value = value;
    }

    public boolean isPresent() {
        return value != null;
    }

    public void print() {
        if (isPresent()) {
            System.out.println("Container value is: " + value);
        } else {
            System.out.println("Container is empty");
        }
    }

    public T getValue() {
        return value;
    }
}
```

Значение `T`, которое мы указали в скобках возле название класса, - это и есть дженерик-параметр.
Он означает, что при создании экземпляра этого класса мы явно указываем, какой тип хранится внутри.
Поскольку он же и будет возращаться в `getValue`, мы избавляем себя от необходимости иметь дело с
`Object`.
Посмотрите на пример ниже с использованием `Container<T>`:

```java
public class Main {
    public static void main(String[] args) {
        Container<Car> container = new Container<>(new Car(...));
        /* некоторая логика работы */
        Car car = container.getValue();
    }
}
```

Теперь `container.getValue()` сразу возвращает тип `Car`.

> Возможно, вы обратили внимание, что мы создали `Container` с помощью `new Container<>`, а не
`new Container<Car>`,
> хотя присваиваем значение именно в переменную типа `Container<Car>`. Начиная с Java 8 при создании
> объекта
> через `new` не обязательно указывать значения дженерик-параметров, если вы уже указали их в типе
> переменной.

Дженерик обладают еще одним важным свойством. Если какой-то метод принимает на вход
`Container<Car>`,
то мы не сможем туда передать переменную `Container<Airplane>`, `Container<String>` или любой другой
тип, отличный от `Container<Car>`.
Это значит, что многие ошибки можно будет проверить на этапе компиляции программы, а не во время ее
выполнения.

> Дженерики в Java - большая и сложная тема. Мы рассмотрели лишь основы, но также есть очень много
> нюансов, которые выходят за рамки курса.
> Но если вам интересно чуть глубже погрузиться в эту
> тему, [ознакомьтесь с этой статьей](https://dev.to/kirekov/java-generics-advanced-cases-3iah).

**Соглашения по именованию параметров типа:**

- `T` - Type (тип)
- `E` - Element (элемент)
- `K` - Key (ключ)
- `V` - Value (значение)
- `N` - Number (число)
-

## Обобщенные интерфейсы

Интерфейсы также могут быть параметризованы, что особенно полезно для создания библиотек и API.

```java
// Интерфейс с несколькими параметрами типа
public interface Pair<K, V> {
    K getKey();

    V getValue();

    void setPair(K key, V value);
}

// Реализация
public class SimplePair<K, V> implements Pair<K, V> {
    private K key;
    private V value;

    public SimplePair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    @Override
    public K getKey() {
        return key;
    }

    @Override
    public V getValue() {
        return value;
    }

    @Override
    public void setPair(K key, V value) {
        this.key = key;
        this.value = value;
    }
}

// Использование
Pair<String, Integer> nameAge = new SimplePair<>("Alice", 25);
System.out.

println(nameAge.getKey() +": "+nameAge.

getValue());
```

## Обертки вокруг примитивов

Возможно, вы уже обратили внимание, что помимо примитивов вроде `int`, `double` и `boolean` есть
некие классы `Integer`, `Double` и `Boolean`.
Это иммутабельные классы-обертки вокруг соответствующих примитивов.

> Если вам непонятно значение слова "иммутабельный", вернитесь к параграфу про инкапсуляцию в ООП.

Они нужны для того, чтобы использовать их в дженериках. Потому что код вроде `Container<int>` не
скомпилируется, а вот `Container<Integer>` - да.
Также интересен механизм _autoboxing_, который построен на этих обертках в Java. Посмотрите на
пример кода ниже:

```java
public class Main {
    public static void main(String[] args) {
        int value = getInt();
        printInt(value);
    }

    private static Integer getInt() {
        return 10;
    }

    private static void printInt(Integer value) {
        System.out.println(value);
    }
}
```

На первый взгляд вообще не понятно, как этот код компилируется. Посмотрите на метод `getInt`.
Возвращаемое значение - `Integer`, а в `return` мы указываем примитив `int`.
Причем `Integer` - это класс, а `int` - примитив. Как это может работать?

Дело в том, что Java знает об этих обертках и этом, каким примитивам они соответствуют. Поэтому
выполняет преобразования от одного типа к другому автоматически.
Чтобы было понятно, посмотрите на альтернативный вариант кода ниже. Он работает точно так же, но
теперь все преобразования видны явно:

```java
public class Main {
    public static void main(String[] args) {
        Integer valueObj = getInt();
        int value = valueObj.intValue();
        printInt(Integer.valueOf(value));
    }

    private static Integer getInt() {
        return Integer.valueOf(10);
    }

    private static void printInt(Integer value) {
        System.out.println(value);
    }
}
```

### Проблемы NullPointerException при autoboxing

В момент autoboxing возможны `NullPointerException`. К примитивам нельзя присвоить `null`: будет
ошибка компиляции. Посмотрите на пример кода ниже:

```java
public class Main {
    public static void main(String[] args) {
        printInt(null);
    }

    private static void printInt(int value) {
        System.out.println(value);
    }
}
```

Это код даже не скомпилируется. С другой стороны, другой пример кода скомпилируется без проблем, но
завершится с `NullPointerException`:

```java
public class Main {
    public static void main(String[] args) {
        Integer valueObj = null;
        printInt(valueObj);
    }

    private static void printInt(int value) {
        System.out.println(value);
    }
}
```

В момент передачи параметра типа `Integer` в функцию `printInt` произойдет попытка unboxing-а:
преобразование объекта `Integer` к примитиву `int` (по сути у объекта типа `Integer` будет вызван
метод `intValue`).
И как раз в этот момент и произойдет `NullPointerException`. Запустите программу, и вы увидите такое
сообщение об ошибке:

```
Exception in thread "main" java.lang.NullPointerException: Cannot invoke "java.lang.Integer.intValue()" because "valueObj" is null
	at org.example.Main.main(Main.java:9)
```

## Обобщенные методы

### Базовый синтаксис

Обобщенные методы позволяют параметризовать отдельные методы, независимо от того, является ли класс
обобщенным.

```java
public class ArrayUtils {

    // Обобщенный метод - <T> перед возвращаемым типом
    public static <T> T getMiddle(T[] array) {
        if (array == null || array.length == 0) return null;
        return array[array.length / 2];
    }

    // Метод с ограниченным типом
    public static <T extends Comparable<T>> T max(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }

    // Метод с несколькими параметрами типа
    public static <K, V> String formatPair(K key, V value) {
        return key.toString() + " -> " + value.toString();
    }
}

// Использование
String[] names = {"Alice", "Bob", "Charlie"};
String middleName = ArrayUtils.getMiddle(names); // T выводится как String

Integer maxNumber = ArrayUtils.max(10, 20); // T выводится как Integer

String pair = ArrayUtils.formatPair("Age", 25); // K=String, V=Integer
```

### Вывод типов (Type Inference)

Компилятор Java может автоматически определять типы на основе контекста, что делает код более
чистым.

```java
public class TypeInferenceExample {

    // Компилятор выводит тип из контекста
    public static <T> List<T> createList(T element1, T element2) {
        List<T> list = new ArrayList<>();
        list.add(element1);
        list.add(element2);
        return list;
    }

    // Сложный вывод типов
    public static <T> void process(List<T> list, Consumer<T> processor) {
        for (T item : list) {
            processor.accept(item);
        }
    }
}

// Использование с выводом типов
List<String> names = TypeInferenceExample.createList("Alice", "Bob");
// Компилятор выводит T = String

List<Integer> numbers = TypeInferenceExample.createList(1, 2);
// Компилятор выводит T = Integer

// Diamond operator <>
List<String> explicitList = new ArrayList<String>();
List<String> inferredList = new ArrayList<>(); // Тип выводится
```

**Diamond operator (`<>`)** был добавлен в Java 7 для сокращения синтаксиса - компилятор
автоматически выводит типы из контекста.

## Наследование и Подтипы

### Инвариантность Generics

Важное понятие: Generics в Java **инвариантны**. Это означает, что если `String` является подтипом
`Object`, то `List<String>` **не является** подтипом `List<Object>`.

```java
// Допустимые присваивания
Object obj = "string"; // String наследуется от Object
String[] strArray = new String[10];
Object[] objArray = strArray; // Ковариантность массивов

// НЕдопустимые присваивания с Generics
List<String> strList = new ArrayList<>();
// List<Object> objList = strList; // ОШИБКА КОМПИЛЯЦИИ!

// Почему это опасно?
public class InheritanceDanger {
    public static void main(String[] args) {
        // Если бы это было разрешено:
        // List<String> strList = new ArrayList<>();
        // List<Object> objList = strList; // Предположим, что разрешено
        // objList.add(123); // Добавляем Integer в List<String>!
        // String value = strList.get(0); // ClassCastException!
    }
}
```

**Объяснение:** Если бы `List<String>` был подтипом `List<Object>`, мы могли бы добавить любой
объект в список, который должен содержать только строки, что привело бы к `ClassCastException` во
время выполнения.

## Wildcards

Wildcards (подстановки) обеспечивают гибкость при работе с обобщенными типами, позволяя создавать
методы, которые могут работать с различными инстанциациями generic-типов.

### Upper Bounded Wildcard (`? extends T`)

**"Читатель"** - можно читать элементы как `T`, но нельзя добавлять новые элементы (кроме `null`).

```java
// "Читатель" - можно читать как T, но нельзя добавлять
public class UpperBoundExample {

    public static double sumNumbers(List<? extends Number> numbers) {
        double sum = 0.0;
        for (Number num : numbers) { // Чтение - OK
            sum += num.doubleValue();
        }
        return sum;
    }

    public static void printAnimals(List<? extends Animal> animals) {
        for (Animal animal : animals) {
            System.out.println(animal);
        }
        // animals.add(new Dog()); // ОШИБКА - нельзя добавлять
    }
}

// Использование
List<Integer> integers = List.of(1, 2, 3);
List<Double> doubles = List.of(1.1, 2.2, 3.3);

System.out.

println(UpperBoundExample.sumNumbers(integers)); // 6.0
    System.out.

println(UpperBoundExample.sumNumbers(doubles));  // 6.6
```

**Применение:** Когда вам нужно только читать из коллекции и вы хотите работать с элементами как с
базовым типом.

### Lower Bounded Wildcard (`? super T`)

**"Писатель"** - можно добавлять элементы типа `T` и его подтипов, но чтение ограничено типом
`Object`.

```java
// "Писатель" - можно добавлять T и его подтипы
public class LowerBoundExample {

    public static void addNumbers(List<? super Integer> list) {
        for (int i = 1; i <= 3; i++) {
            list.add(i); // Добавление - OK
        }
    }

    public static void addDogs(List<? super Dog> dogs) {
        dogs.add(new Dog());
        // dogs.add(new Animal()); // ОШИБКА - только Dog и его подтипы
    }
}

// Использование
List<Integer> intList = new ArrayList<>();
List<Number> numList = new ArrayList<>();
List<Object> objList = new ArrayList<>();

LowerBoundExample.

addNumbers(intList); // OK
LowerBoundExample.

addNumbers(numList); // OK  
LowerBoundExample.

addNumbers(objList); // OK
```

**Применение:** Когда вам нужно добавлять элементы в коллекцию и вы хотите сохранить гибкость при
выборе типа коллекции.

### Unbounded Wildcard (`?`)

**"Универсальный обработчик"** - можно только читать элементы как `Object`, нельзя добавлять
элементы (кроме `null`).

```java
// Универсальный обработчик - только чтение как Object
public class UnboundedExample {

    public static void printList(List<?> list) {
        for (Object elem : list) {
            System.out.print(elem + " ");
        }
        System.out.println();
    }

    public static boolean hasNull(List<?> list) {
        return list.contains(null);
    }
}

// Использование
List<String> strings = List.of("A", "B", "C");
List<Integer> numbers = List.of(1, 2, 3);

UnboundedExample.

printList(strings); // A B C
UnboundedExample.

printList(numbers); // 1 2 3
```

**Применение:** Когда функциональность метода не зависит от типа элементов в коллекции.

## PECS принцип

**PECS (Producer-Extends, Consumer-Super)** - это мнемоническое правило, помогающее правильно
использовать wildcards.

- **Producer (поставщик)** - если параметр производит (предоставляет) элементы, используйте
  `? extends T`

- **Consumer (потребитель)** - если параметр потребляет (принимает) элементы, используйте
  `? super T`

### Принцип PECS на практике

```java
public class PECSExample {

    // Producer - источник данных (ЧТЕНИЕ)
    public static <T> void copyFromSource(List<? extends T> source, List<T> dest) {
        dest.addAll(source);
    }

    // Consumer - приемник данных (ЗАПИСЬ)  
    public static <T> void copyToDest(List<T> source, List<? super T> dest) {
        dest.addAll(source);
    }

    // Полная реализация copy с PECS
    public static <T> void copy(List<? extends T> src, List<? super T> dest) {
        for (T item : src) {
            dest.add(item);
        }
    }
}

// Пример из Java Collections
List<Number> numbers = new ArrayList<>();
List<Integer> integers = List.of(1, 2, 3);

// integers - Producer (extends), numbers - Consumer (super)
Collections.

copy(numbers, integers); // В оригинале: copy(List<? super T> dest, List<? extends T> src)
```

**Важность PECS:** Этот принцип обеспечивает максимальную гибкость при сохранении типобезопасности.

## Ограничения Generics

Generics в Java имеют несколько важных ограничений, связанных с реализацией через стирание типов.

### Ограничение 1: Нельзя создавать экземпляры generic-типов

```java
public class InstanceLimitation<T> {
    private T value;

    public InstanceLimitation() {
        // this.value = new T(); // ОШИБКА - неизвестен конструктор
        // this.value = T.class.newInstance(); // Также ошибка
    }

    // Обходное решение через Class<T>
    public InstanceLimitation(Class<T> clazz) throws Exception {
        this.value = clazz.newInstance();
    }
}
```

**Причина:** Во время выполнения информация о типе `T` стирается, поэтому JVM не знает, какой
конструктор вызывать.

### Ограничение 2: Нельзя использовать примитивы

```java

// List<int> primitiveList; // ОШИБКА
List<Integer> wrapperList = new ArrayList<>(); // Правильно
```

**Причина:** Generics работают только с ссылочными типами. Используйте классы-обертки для
примитивов.

### Ограничение 3: Нельзя создавать generic-массивы

```java
public class ArrayLimitation<T> {
// private T[] array = new T[10]; // ОШИБКА

    // Обходное решение
    @SuppressWarnings("unchecked")
    public T[] createArray(Class<T> clazz, int size) {
        return (T[]) java.lang.reflect.Array.newInstance(clazz, size);
    }
}
```

**Причина:** Из-за стирания типов JVM не знает точный тип для создания массива.

### Ограничение 4: Статические члены

```java

public class StaticMemberLimitation<T> {
// private static T staticField; // ОШИБКА

    private static int count = 0; // OK - статическое поле

    // private static void staticMethod(T param) {} // ОШИБКА

    public static <U> void genericStaticMethod(U param) { // OK
        System.out.println(param);
    }
}
```

**Причина:** Статические члены принадлежат классу, а не его экземплярам. Поскольку параметры типа
связаны с экземплярами, они не могут использоваться в статическом контексте.

### Ограничение 5: Невозможность перегрузки по generic-параметрам

```java

public class OverloadLimitation {
// public void process(List<String> list) {} // ОШИБКА
// public void process(List<Integer> list) {} // Оба метода имеют одинаковую сигнатуру после стирания
}
```

### Ковариантность массивов

Массивы в Java ковариантны: если `S` является подтипом `T`, то `S[]` является подтипом `T[]`.

```java
public class ArrayCovariance {
    public static void main(String[] args) {
// Массивы - ковариантны
        String[] strArray = new String[]{"A", "B", "C"};
        Object[] objArray = strArray; // OK - ковариантность

        // Проблема: ArrayStoreException в runtime
        try {
            objArray[0] = "New String"; // OK
            objArray[1] = 123; // ArrayStoreException!
        } catch (ArrayStoreException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }
}
```

**Проблема:** Безопасность не гарантируется на этапе компиляции, ошибки возникают во время
выполнения.

### Инвариантность Generics

Generics инвариантны: `List<S>` не является подтипом `List<T>`, даже если `S` является подтипом `T`.

```java
public class GenericInvariance {
    public static void main(String[] args) {
        List<String> strList = new ArrayList<>();

        // Generics - инвариантны
        // List<Object> objList = strList; // ОШИБКА КОМПИЛЯЦИИ!

        // Безопасность обеспечивается на этапе компиляции
        strList.add("Safe");
        // strList.add(123); // ОШИБКА КОМПИЛЯЦИИ!
    }
}
```

**Преимущество:** Безопасность типов обеспечивается на этапе компиляции.

## Стирание типов

**Type Erasure** - это процесс, при котором компилятор Java удаляет всю информацию о generic-типах
во время компиляции. Это сделано для обратной совместимости с кодом, написанным до Java 5.

### Базовое стирание типов

```java
// Исходный код
public class ErasureExample<T> {
    private T value;

    public void setValue(T value) {
        this.value = value;
    }

    public T getValue() {
        return value;
    }
}

// После компиляции (декомпилированный вид)
public class ErasureExample {
    private Object value; // T заменен на Object

    public void setValue(Object value) {
        this.value = value;
    }

    public Object getValue() {
        return value;
    }
}
```

### Стирание с ограничениями

Если параметр типа имеет ограничение, он заменяется на граничный тип.

```java
// Исходный код с ограничением
public class BoundedErasure<T extends Number> {
    private T number;

    public double getDoubleValue() {
        return number.doubleValue(); // Методы Number доступны
    }
}

// После компиляции
public class BoundedErasure {
    private Number number; // T заменен на Number (верхняя граница)

    public double getDoubleValue() {
        return number.doubleValue();
    }
}

```

### Стирание в методах

```java
// Исходный код
public class MethodErasure {
    public static <T> T firstElement(List<T> list) {
        return list.get(0);
    }

    public static <T extends Comparable<T>> T max(T a, T b) {
        return a.compareTo(b) > 0 ? a : b;
    }
}

// После компиляции
public class MethodErasure {
    public static Object firstElement(List list) {
        return list.get(0);
    }

    public static Comparable max(Comparable a, Comparable b) {
        return a.compareTo(b) > 0 ? a : b;
    }
}
```

### Bridge Methods (Мостовые методы)

Мостовые методы генерируются компилятором для поддержки полиморфизма при наследовании обобщенных
классов.

```java
// Исходный код
public class Node<T> {
    private T data;

    public Node(T data) {
        this.data = data;
    }

    public void setData(T data) {
        this.data = data;
    }
}

public class IntegerNode extends Node<Integer> {
    public IntegerNode(Integer data) {
        super(data);
    }

    @Override
    public void setData(Integer data) {
        super.setData(data);
    }
}

// После компиляции генерируется мостовой метод
public class IntegerNode extends Node {
    public IntegerNode(Integer data) {
        super(data);
    }

    // Сгенерированный мостовой метод
    public void setData(Object data) {
        setData((Integer) data); // Вызов переопределенного метода
    }

    // Наш переопределенный метод
    public void setData(Integer data) {
        super.setData(data);
    }
}
```

## Заключение

### Ключевые моменты:

1. **Generics обеспечивают типобезопасность** на этапе компиляции, предотвращая `ClassCastException`
2. **Стирание типов** - фундаментальное ограничение реализации в Java для обратной совместимости
3. **Wildcards и PECS** - мощный инструмент для создания гибких и безопасных API
4. **Инвариантность Generics** безопаснее ковариантности массивов
5. **Мостовые методы** обеспечивают полиморфизм при наследовании обобщенных классов

### Лучшие практики:

- **Всегда используйте Generics** для коллекций и классов, работающих с различными типами
- **Следуйте принципу PECS** при проектировании API - `? extends T` для производителей, `? super T`
  для потребителей
- **Помните об ограничениях стирания** - нельзя создавать экземпляры `new T()`, массивы `new T[]`,
  использовать `instanceof T`
- **Используйте wildcards** для максимальной гибкости при сохранении безопасности типов
- **Избегайте raw types** - они существуют только для обратной совместимости
-

Generics - это мощный инструмент, который при правильном использовании делает код безопаснее, чище и
выразительнее. Понимание их внутреннего устройства и ограничений необходимо для написания
качественных Java-приложений.