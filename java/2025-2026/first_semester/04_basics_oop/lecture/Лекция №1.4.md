Records, Exceptions, String, Array, Sealed classes, OOP
# Java Records и Sealed Classes

## Введение
Records и Sealed Classes — одни из самых значимых дополнений со времен Java 8. Они не просто добавляют новый синтаксис, а фундаментально меняют то, как мы моделируем данные и проектируем иерархии классов.

Эти функции были введены с целью сделать Java более выразительной и безопасной, уменьшая объем шаблонного кода и предотвращая целый класс ошибок на этапе компиляции.

## Java Records

### Основы Records

Records представляют собой прозрачные носители данных, идеально подходящие для моделирования DTO (Data Transfer Objects), value-объектов и других неизменяемых данных.

```java
// Классический POJO vs Record
public final class Person {
    private final String name;
    private final int age;
    
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
    
    // Геттеры, equals, hashCode, toString
    // ~50 строк кода
}

// Record эквивалент - всего 1 строка!
public record Person(String name, int age) { }
```

Records автоматически генерируют:
- `final` класс с `private final` полями
- Канонический конструктор
- Геттеры (с именем как у поля, без префикса get)
- `equals()`, `hashCode()`, `toString()`

### 2.2. Под капотом Records

Компилятор генерирует байткод, очень похожий на рукописный неизменяемый класс. Но есть важные отличия:

1. **Синтетические методы**: Компилятор генерирует методы, которые обеспечивают семантику value-based поведения
2. **Неявный модификатор final**: Record не может быть унаследован
3. **Неявная расширяемость**: Нельзя добавлять поля в тело record (кроме static)

```java
// Декомпилированный байткод record будет выглядеть примерно так:
public final class Person extends java.lang.Record {
    private final java.lang.String name;
    private final int age;
    
    public Person(java.lang.String name, int age) { /* ... */ }
    
    public java.lang.String name() { return this.name; }
    public int age() { return this.age; }
    
    public java.lang.String toString() { /* ... */ }
    public int hashCode() { /* ... */ }
    public boolean equals(java.lang.Object o) { /* ... */ }
}
```

### Кастомизация Records

Хотя records генерируют много кода автоматически, вы можете кастомизировать различные аспекты:

```java
public record Person(String name, int age) {
    // Кастомизированный конструктор с валидацией
    public Person {
        if (age < 0) {
            throw new IllegalArgumentException("Age cannot be negative");
        }
        // Поля неявно инициализируются после этого блока
    }
    
    // Кастомизированный геттер
    public String name() {
        return name != null ? name : "Unknown";
    }
    
    // Статические методы и поля разрешены
    public static Person UNKNOWN = new Person("Unknown", 0);
    
    // Нельзя добавлять не-static поля!
    // private String nickname; // ОШИБКА!
}
```

### Best Practices и подводные камни

**Лучшие практики:**
1. Используйте records для чистых данных, не добавляйте поведение
2. Сохраняйте иммутабельность — не добавляйте сеттеры
3. Используйте для DTO, value objects, ключей в Map, результатов запросов

**Подводные камни:**
1. **Наследование запрещено**: Record не может наследовать другие классы (кроме Record)
2. **Нельзя добавлять поля**: Только статические поля разрешены
3. **Рефлексия**: Records имеют специальные методы в рефлексии (`isRecord()`, `getRecordComponents()`)
4. **Сериализация**: Records сериализуются по-другому — через конструктор, а не через поля

```java
// Типичная ошибка - попытка наследования
public record Student(String name, int age, String major) 
    extends Person(name, age) { } // ОШИБКА!

// Вместо этого используйте композицию:
public record Student(Person person, String major) { }
```

## Sealed Classes

### Основы Sealed Classes

Sealed classes (запечатанные классы) позволяют контролировать, какие классы могут наследовать или реализовывать интерфейс. Это мощный инструмент для моделирования точных иерархий.

```java
// Определение sealed-иерархии
public sealed interface Shape 
    permits Circle, Rectangle, Triangle {
    
    double area();
}

// Разрешенные реализации
public final class Circle implements Shape {
    private final double radius;
    
    public Circle(double radius) { this.radius = radius; }
    
    @Override
    public double area() { return Math.PI * radius * radius; }
}

public record Rectangle(double width, double height) implements Shape {
    @Override
    public double area() { return width * height; }
}

public non-sealed class Triangle implements Shape {
    private final double base, height;
    
    public Triangle(double base, double height) {
        this.base = base;
        this.height = height;
    }
    
    @Override
    public double area() { return 0.5 * base * height; }
}
```

### Под капотом Sealed Classes

Компилятор добавляет проверки, которые гарантируют:
1. Все permitted-классы доступны во время компиляции
2. Все permitted-классы находятся в том же модуле (или пакете, если нет модулей)
3. Никакие другие классы не могут наследовать sealed-класс

В байткоде эта информация сохраняется через аттрибуты, которые могут использоваться анализаторами и инструментами. 

### Best Practices и подводные камни

**Лучшие практики:**
1. Используйте для точного моделирования domain concepts
2. Сочетайте с pattern matching для exhaustiveness checking
3. Предпочитайте records для leaf-классов в иерархии

**Подводные камни:**
1. **Циклические зависимости**: Убедитесь, что permitted-классы видны во время компиляции
2. **Модульная система**: В модульном Java нужно открывать пакеты для reflection
3. **Комбинация с generics**: Требует осторожности

```java
// Ошибка: permitted-класс не в том же пакете/модуле
package com.example.shapes;

public sealed interface Shape 
    permits com.otherpackage.Circle { } // ОШИБКА!

// Решение: переместить классы или использовать модульную систему
```

## Комбинация Records и Sealed Classes

Сочетание этих двух функций создает мощный дуэт для моделирования данных:

```java
// Моделирование алгебраических типов данных
public sealed interface Result<T> permits Success, Failure {
    T getValue() throws Exception;
}

public record Success<T>(T value) implements Result<T> {
    @Override
    public T getValue() { return value; }
}

public record Failure<T>(Exception error) implements Result<T> {
    @Override
    public T getValue() throws Exception { throw error; }
}

// Использование с pattern matching
public class ResultProcessor {
    public static <T> void process(Result<T> result) {
        switch (result) {
            case Success<T>(var value) -> 
                System.out.println("Success: " + value);
            case Failure<T>(var error) -> 
                System.out.println("Error: " + error.getMessage());
            // Компилятор знает, что все случаи покрыты!
        }
    }
}
```

## Best Practices
**Best Practices:**
1. **Кодовая база масштаба**: Records уменьшают объем кода на 40-60% для DTO
2. **Безопасность**: Sealed classes предотвращают несанкционированное расширение API
3. **Совместимость**: Обе функции полностью обратно совместимы
4. **Производительность**: Records могут быть оптимизированы JVM как value types (в будущем)

**Рекомендации для enterprise-разработки:**
- Используйте records для всех DTO между слоями приложения
- Моделируйте domain concepts через sealed иерархии
- Сочетайте с pattern matching для обработки ошибок
- Документируйте intended use sealed-иерархий

```java
// Enterprise-пример: обработка API responses
public sealed interface ApiResponse<T> 
    permits SuccessResponse, ErrorResponse, PendingResponse {
    
    // Factory methods для удобства
    static <T> ApiResponse<T> success(T data) {
        return new SuccessResponse<>(data);
    }
    
    static <T> ApiResponse<T> error(String message, int code) {
        return new ErrorResponse<>(message, code);
    }
}

public record SuccessResponse<T>(T data) implements ApiResponse<T> {}
public record ErrorResponse<T>(String message, int code) implements ApiResponse<T> {}
public record PendingResponse<T>(String requestId) implements ApiResponse<T> {}
```

## Заключение

Records и Sealed Classes — это не просто синтаксический сахар, а фундаментальные улучшения языка Java, которые позволяют писать более выразительный, безопасный и поддерживаемый код.

Эти улучшения действительно меняют то, как мы проектируем Java-приложения. Они приближают Java к современным functional языкам, сохраняя при этом всю мощь и экосистему.

Начинайте использовать их в новых проектах и постепенно мигрируйте старый код — вы оцените уменьшение в boilerplate коде и увеличение в надежности ваших систем.

# Exceptions

## Философия исключений
 Исключения — это не просто ошибки, это механизм коммуникации между различными слоями приложения.

**Основные принципы:**
- Исключения должны быть информативными и "действующими"
- Обработка на том уровне, где можно предпринять осмысленные действия
- Не использовать исключения для контроля потока выполнения
- Логгировать на том уровне, где исключение возникает впервые

## Иерархия исключений

### Checked vs Unchecked исключения

```java
// Checked исключения - должны быть обработаны или объявлены
public void readFile() throws IOException {
    // Компилятор заставляет обработать это исключение
}

// Unchecked исключения (RuntimeException) - не обязательны для обработки
public void divide(int a, int b) {
    if (b == 0) {
        throw new IllegalArgumentException("Divisor cannot be zero");
    }
}
```

**Глубокое понимание:**
- **Checked исключения** - для recoverable ошибок, когда вызывающий код может что-то предпринять
- **Unchecked исключения** - для programming errors (null pointers, invalid arguments)

### Error vs Exception

```java
// Error - системные ошибки, которые обычно не должны перехватываться
public class CriticalSystemError extends Error {
    public CriticalSystemError(String message) {
        super(message);
    }
}

// Exception - базовый класс для исключений приложения
public class BusinessException extends Exception {
    public BusinessException(String message) {
        super(message);
    }
}
```

## Обработка исключений

### Блоки try-catch-finally

```java
public class DatabaseService {
    public void processTransaction(Connection conn) {
        try {
            // Код, который может бросить исключение
            startTransaction(conn);
            executeBusinessLogic(conn);
            commitTransaction(conn);
        } catch (SQLException e) {
            // Специфичная обработка SQL ошибок
            rollbackTransaction(conn);
            logger.error("Database error during transaction", e);
            throw new TransactionException("Transaction failed", e);
        } catch (BusinessException e) {
            // Обработка бизнес-логики ошибок
            rollbackTransaction(conn);
            logger.warn("Business rule violation", e);
            throw e;
        } finally {
            // Всегда выполняется (даже при return или исключении)
            closeResources(conn);
        }
    }
}
```

### Try-with-resources (Java 7+)

**Революционное улучшение**, устраняющее целый класс ошибок:

```java
// Старый стиль (потенциально опасный)
public void oldStyle() {
    Connection conn = null;
    try {
        conn = dataSource.getConnection();
        // работа с connection
    } finally {
        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                logger.error("Failed to close connection", e);
            }
        }
    }
}

// Новый стиль (автоматическое закрытие)
public void modernStyle() {
    try (Connection conn = dataSource.getConnection();
         PreparedStatement stmt = conn.prepareStatement("SELECT * FROM users");
         ResultSet rs = stmt.executeQuery()) {
        
        while (rs.next()) {
            processUser(rs);
        }
    } catch (SQLException e) {
        throw new DataAccessException("Database operation failed", e);
    }
    // Ресурсы автоматически закрываются в обратном порядке
}
```

### Multi-catch (Java 7+)

```java
public void handleMultipleExceptions() {
    try {
        processData();
    } catch (IOException | SQLException | NetworkException e) {
        // Общая обработка для разных типов исключений
        logger.error("Operation failed", e);
        throw new ApplicationException("Failed to process data", e);
    }
}
```

## Создание собственных исключений

**Правильный подход к созданию исключений:**

```java
// Бизнес-исключение с дополнительным контекстом
public class PaymentException extends Exception {
    private final String transactionId;
    private final BigDecimal amount;
    private final String reasonCode;
    
    public PaymentException(String message, String transactionId, 
                           BigDecimal amount, String reasonCode) {
        super(message);
        this.transactionId = transactionId;
        this.amount = amount;
        this.reasonCode = reasonCode;
    }
    
    public PaymentException(String message, String transactionId, 
                           BigDecimal amount, String reasonCode, Throwable cause) {
        super(message, cause);
        this.transactionId = transactionId;
        this.amount = amount;
        this.reasonCode = reasonCode;
    }
    
    // Геттеры для дополнительной информации
    public String getTransactionId() { return transactionId; }
    public String getReasonCode() { return reasonCode; }
    
    @Override
    public String getMessage() {
        return String.format("%s [transactionId=%s, amount=%s, reason=%s]", 
                           super.getMessage(), transactionId, amount, reasonCode);
    }
}
```

## Продвинутые техники

### Exception translation

**Паттерн, который используется в каждом enterprise-проекте:**

```java
public class ServiceFacade {
    public UserDTO getUserById(String id) {
        try {
            User user = userRepository.findById(id);
            return user.toDTO();
        } catch (EntityNotFoundException e) {
            // Преобразование низкоуровневого исключения в бизнес-ориентированное
            throw new UserNotFoundException("User not found with id: " + id, e);
        } catch (DataAccessException e) {
            // Сокрытие деталей реализации от клиента
            throw new ServiceUnavailableException("User service temporarily unavailable", e);
        }
    }
}
```

### Stack trace preservation

**Критически важная практика для отладки:**

```java
public class ExceptionHelper {
    public static BusinessException wrapException(String message, Throwable cause) {
        BusinessException exception = new BusinessException(message, cause);
        
        // Сохраняем оригинальный stack trace
        exception.setStackTrace(cause.getStackTrace());
        
        return exception;
    }
    
    // Альтернатива: использование initCause()
    public static BusinessException wrapWithInitCause(String message, Throwable cause) {
        BusinessException exception = new BusinessException(message);
        exception.initCause(cause);  // Сохраняет оригинальный stack trace
        return exception;
    }
}
```

### Suppressed exceptions

**Для сложных сценариев с несколькими исключениями:**

```java
public class ResourceManager {
    public void processWithMultipleResources() throws ApplicationException {
        Exception mainException = null;
        List<AutoCloseable> resources = new ArrayList<>();
        
        try {
            resources.add(acquireResource1());
            resources.add(acquireResource2());
            // Основная логика
        } catch (Exception e) {
            mainException = e;
        } finally {
            // Закрываем ресурсы, собирая suppressed исключения
            for (AutoCloseable resource : resources) {
                try {
                    if (resource != null) resource.close();
                } catch (Exception closingException) {
                    if (mainException != null) {
                        mainException.addSuppressed(closingException);
                    } else {
                        mainException = closingException;
                    }
                }
            }
        }
        
        if (mainException != null) {
            throw new ApplicationException("Operation failed", mainException);
        }
    }
}
```

## Производительность исключений

**Важные факты из работы high-performance систем:**

```java
public class PerformanceConsiderations {
    // МЕДЛЕННО: Создание исключения дорого из-за заполнения stack trace
    public void slowMethod() {
        if (invalidCondition) {
            throw new ValidationException("Invalid data"); // Дорогая операция
        }
    }
    
    // БЫСТРО: Использование исключений без stack trace (Java 7+)
    public static class NoStackTraceException extends RuntimeException {
        public NoStackTraceException(String message) {
            super(message, null, true, false); // Не заполнять stack trace
        }
    }
    
    public void fastMethod() {
        if (invalidCondition) {
            throw new NoStackTraceException("Validation failed"); // Быстро
        }
    }
    
    // АНТИПАТТЕРН: Использование исключений для контроля потока
    public void antiPattern() {
        try {
            while (true) {
                processItem(getNextItem()); // Бросает NoMoreItemsException
            }
        } catch (NoMoreItemsException e) {
            // НЕПРАВИЛЬНО! Исключения не для нормального flow
        }
    }
    
    // ПРАВИЛЬНО: Использование нормальных return values
    public void correctPattern() {
        Item item;
        while ((item = getNextItem()) != null) {
            processItem(item);
        }
    }
}
```
# Array и String

## Введение
Эти фундаментальные структуры кажутся простыми, но содержат множество нюансов, которые критически важны для высоконагруженных систем.
Массивы и строки — это кирпичики, из которых строятся практически все Java-приложения. 

## Массивы

### Основы массивов

**Массив — это контейнер фиксированного размера с непрерывной областью памяти:**

```java
// Различные способы объявления и инициализации
int[] numbers = new int[10];          // Все элементы 0
String[] names = new String[5];       // Все элементы null
boolean[] flags = {true, false, true}; // Инициализация при объявлении

// Особенности массивов в Java
public class ArrayFundamentals {
    public void demonstrateArrays() {
        int[] arr = new int[5];
        
        // Длина массива фиксирована и доступна через поле length
        System.out.println("Длина: " + arr.length); // 5
        
        // Индексация с 0
        arr[0] = 10;
        arr[4] = 50; // Последний элемент
        
        // Попытка доступа к arr[5] выбросит ArrayIndexOutOfBoundsException
    }
}
```

### Многомерные массивы

**В Java нет настоящих многомерных массивов — только массивы массивов:**

```java
public class MultiDimensionalArrays {
    public void demonstrateMultiArrays() {
        // Двумерный массив (массив массивов)
        int[][] matrix = new int[3][4];
        matrix[0][0] = 1;
        matrix[2][3] = 12;
        
        // "Зубчатый" массив (jagged array)
        int[][] jagged = new int[3][];
        jagged[0] = new int[2];  // Первая строка - 2 элемента
        jagged[1] = new int[3];  // Вторая строка - 3 элемента
        jagged[2] = new int[1];  // Третья строка - 1 элемент
        
        // Инициализация при объявлении
        int[][] predefined = {
            {1, 2, 3},
            {4, 5},
            {6, 7, 8, 9}
        };
    }
}
```

### Массивы и производительность

**Критически важные аспекты для high-performance систем:**

```java
public class ArrayPerformance {
    private static final int SIZE = 10_000;
    
    // ПРЕДПОЧТИТЕЛЬНО: последовательный доступ (cache-friendly)
    public long sequentialAccess() {
        int[] array = new int[SIZE];
        long sum = 0;
        
        for (int i = 0; i < SIZE; i++) {
            sum += array[i]; // Предсказуемый для процессора доступ
        }
        return sum;
    }
    
    // НЕПРЕДПОЧТИТЕЛЬНО: случайный доступ
    public long randomAccess(int[] indices) {
        int[] array = new int[SIZE];
        long sum = 0;
        
        for (int index : indices) {
            sum += array[index]; // Кэш-промахи
        }
        return sum;
    }
    
    // Копирование массивов
    public void arrayCopyPerformance() {
        int[] source = new int[SIZE];
        int[] dest = new int[SIZE];
        
        // МЕДЛЕННО: поэлементное копирование
        for (int i = 0; i < SIZE; i++) {
            dest[i] = source[i];
        }
        
        // БЫСТРО: System.arraycopy (нативная оптимизация)
        System.arraycopy(source, 0, dest, 0, SIZE);
    }
}
```

### Arrays Utility Class

**Мощный инструмент для работы с массивами:**

```java
import java.util.Arrays;
import java.util.Comparator;

public class ArraysUtility {
    public void demonstrateArraysClass() {
        int[] numbers = {3, 1, 4, 1, 5, 9, 2, 6};
        
        // Сортировка
        Arrays.sort(numbers); // Быстрая сортировка Dual-Pivot Quicksort
        
        // Бинарный поиск (только на отсортированных массивах)
        int index = Arrays.binarySearch(numbers, 5);
        
        // Сравнение массивов
        int[] copy = Arrays.copyOf(numbers, numbers.length);
        boolean equal = Arrays.equals(numbers, copy); // true
        
        // Заполнение
        int[] filled = new int[10];
        Arrays.fill(filled, 42); // Все элементы становятся 42
        
        // Глубокие операции для многомерных массивов
        int[][] matrix1 = {{1, 2}, {3, 4}};
        int[][] matrix2 = {{1, 2}, {3, 4}};
        boolean deepEqual = Arrays.deepEquals(matrix1, matrix2); // true
        
        // Стримы из массивов (Java 8+)
        int sum = Arrays.stream(numbers).sum();
    }
    
    // Сортировка объектов с компаратором
    public void sortObjects() {
        String[] names = {"John", "Alice", "Bob", "Charlie"};
        
        Arrays.sort(names); // Естественный порядок
        Arrays.sort(names, Comparator.comparing(String::length)); // По длине
        Arrays.sort(names, Comparator.reverseOrder()); // В обратном порядке
    }
}
```

### Подводные камни массивов

**Типичные ошибки:**

```java
public class ArrayPitfalls {
    // 1. Изменение размера невозможно
    public void resizeProblem() {
        int[] arr = new int[5];
        // arr.length = 10; // ОШИБКА: длина фиксирована
        
        // Правильно: создаем новый массив
        arr = Arrays.copyOf(arr, 10);
    }
    
    // 2. Коварство многомерных массивов
    public void multiArrayPitfall() {
        int[][] matrix = new int[3][];
        // matrix[0][0] = 1; // NullPointerException!
        
        // Правильно: сначала инициализировать внутренние массивы
        for (int i = 0; i < matrix.length; i++) {
            matrix[i] = new int[4];
        }
    }
    
    // 3. Утечки памяти
    public void memoryLeak() {
        int[] largeArray = new int[1_000_000];
        // Работа с массивом...
        largeArray = new int[10]; // Старый массив остается в памяти до GC
        
        // Правильно: явно очищать если нужно
        Arrays.fill(largeArray, 0); // Для чувствительных данных
    }
    
    // 4. Неправильное сравнение
    public void comparisonPitfall() {
        int[] arr1 = {1, 2, 3};
        int[] arr2 = {1, 2, 3};
        
        System.out.println(arr1 == arr2); // false - сравниваются ссылки!
        System.out.println(Arrays.equals(arr1, arr2)); // true - сравниваются содержимое
    }
}
```

## Строки

### Внутреннее устройство String

**Строки в Java — это иммутабельные объекты на основе char[]:**

```java
public class StringInternals {
    // До Java 9: char[] value
    // С Java 9: byte[] value + byte coder (LATIN1/UTF16 оптимизация)
    
    public void stringStructure() {
        String str = "Hello";
        
        // Иммутабельность означает:
        // 1. Поля final
        // 2. Нет сеттеров
        // 3. Все операции возвращают новые объекты
    }
}
```

### String Pool и иммутабельность

**String Pool — ключевая оптимизация JVM:**

```java
public class StringPoolDemo {
    public void demonstratePool() {
        // Литералы попадают в String Pool
        String s1 = "hello";
        String s2 = "hello";
        String s3 = new String("hello"); // НОВЫЙ объект в куче
        
        System.out.println(s1 == s2); // true - один объект в pool
        System.out.println(s1 == s3); // false - разные объекты
        
        // intern() помещает строку в pool или возвращает существующую
        String s4 = s3.intern();
        System.out.println(s1 == s4); // true
        
        // Компилятор оптимизирует конкатенацию литералов
        String s5 = "he" + "llo"; // Компилятор делает "hello"
        System.out.println(s1 == s5); // true
    }
    
    // Важность иммутабельности для многопоточности
    public void threadSafety() {
        String shared = "initial";
        
        // Безопасно в многопоточной среде - иммутабельные объекты thread-safe
        Runnable task = () -> {
            String local = shared.concat(" modified"); // Новый объект
            System.out.println(local);
        };
        
        new Thread(task).start();
        new Thread(task).start();
    }
}
```

### Операции со строками

**Эффективное использование строковых операций:**

```java
public class StringOperations {
    public void commonOperations() {
        String str = "  Hello World  ";
        
        // Базовые операции
        int length = str.length(); // 15 (включая пробелы)
        char ch = str.charAt(1);   // ' '
        String substr = str.substring(6, 11); // "World"
        
        // Поиск
        int index = str.indexOf("World"); // 6
        boolean contains = str.contains("Hello"); // true
        
        // Модификации (возвращают новые строки)
        String trimmed = str.trim(); // "Hello World"
        String upper = str.toUpperCase(); // "  HELLO WORLD  "
        String replaced = str.replace("World", "Java"); // "  Hello Java  "
        
        // Разделение и склейка
        String[] parts = "a,b,c".split(","); // ["a", "b", "c"]
        String joined = String.join("-", "a", "b", "c"); // "a-b-c"
    }
    
    // Сравнение строк
    public void stringComparison() {
        String s1 = "hello";
        String s2 = "HELLO";
        
        System.out.println(s1.equals(s2)); // false
        System.out.println(s1.equalsIgnoreCase(s2)); // true
        System.out.println(s1.compareTo(s2)); // > 0 (разница в кодах символов)
        
        // null-safe сравнение
        String possibleNull = null;
        // possibleNull.equals("test"); // NullPointerException!
        "test".equals(possibleNull); // false - безопасно
    }
}
```

### StringBuilder vs StringBuffer

**Оптимизация конкатенации строк:**

```java
public class StringBuilding {
    // НЕЭФФЕКТИВНО: создается много промежуточных объектов
    public String inefficientConcat(String[] words) {
        String result = "";
        for (String word : words) {
            result += word; // Каждый раз создается новый String
        }
        return result;
    }
    
    // ЭФФЕКТИВНО: используется StringBuilder
    public String efficientConcat(String[] words) {
        StringBuilder sb = new StringBuilder();
        for (String word : words) {
            sb.append(word);
        }
        return sb.toString(); // Один финальный String
    }
    
    // StringBuffer vs StringBuilder
    public void bufferVsBuilder() {
        // StringBuilder - несинхронизированный (быстрее)
        StringBuilder sb = new StringBuilder(); 
        sb.append("Hello").append(" World");
        
        // StringBuffer - синхронизированный (потокобезопасный, медленнее)
        StringBuffer buffer = new StringBuffer();
        buffer.append("Hello").append(" World");
        
        // В однопоточных приложениях всегда предпочитайте StringBuilder
    }
    
    // Правильная инициализация capacity
    public void properInitialization() {
        // ПЛОХО: default capacity (16), будет расширяться
        StringBuilder bad = new StringBuilder();
        
        // ХОРОШО: задаем ожидаемую capacity
        int expectedSize = 1000;
        StringBuilder good = new StringBuilder(expectedSize);
        
        for (int i = 0; i < expectedSize; i++) {
            good.append("x"); // Не будет переаллокаций
        }
    }
}
```

### Подводные камни строк

**Критические ошибки, которых следует избегать:**

```java
public class StringPitfalls {
    // 1. Конкатенация в цикле
    public void concatenationInLoop() {
        // ПЛОХО: O(n²) сложность
        String result = "";
        for (int i = 0; i < 1000; i++) {
            result += i; // Каждый раз новый объект!
        }
        
        // ХОРОШО: O(n) сложность
        StringBuilder sb = new StringBuilder();
        for (int i = 0; i < 1000; i++) {
            sb.append(i);
        }
        result = sb.toString();
    }
    
    // 2. Неправильное использование ==
    public void equalityPitfall() {
        String s1 = "hello";
        String s2 = new String("hello");
        
        if (s1 == s2) { // НИКОГДА ТАК НЕ ДЕЛАЙТЕ!
            System.out.println("Equal"); // Не выполнится
        }
        
        if (s1.equals(s2)) { // ПРАВИЛЬНО
            System.out.println("Equal"); // Выполнится
        }
    }
    
    // 3. Утечки памяти через substring (до Java 7)
    public void memoryLeakOldJava() {
        String hugeString = "очень_длинная_строка...";
        // В Java 6: substring делил char[] с оригиналом
        String small = hugeString.substring(0, 5);
        
        // hugeString = null; // small все еще держала ссылку на весь char[]
        
        // В Java 7+: substring создает новый char[]
    }
    
    // 4. Кодировка и локали
    public void encodingPitfall() throws Exception {
        String text = "Привет";
        
        // ПЛОХО: платформенная кодировка по умолчанию
        byte[] bytes1 = text.getBytes();
        
        // ХОРОШО: явное указание кодировки
        byte[] bytes2 = text.getBytes(StandardCharsets.UTF_8);
        
        String recovered = new String(bytes2, StandardCharsets.UTF_8);
    }
}
```

## Интеграция массивов и строк

**Взаимодействие между массивами и строками:**

```java
public class ArrayStringIntegration {
    // Конвертация между char[] и String
    public void charArrayToString() {
        char[] chars = {'H', 'e', 'l', 'l', 'o'};
        
        String str1 = new String(chars); // "Hello"
        String str2 = String.valueOf(chars); // "Hello"
        
        // Обратная конвертация
        char[] chars2 = str1.toCharArray();
        
        // Работа с отдельными символами
        for (char c : str1.toCharArray()) {
            System.out.println(c);
        }
    }
    
    // Байтовые массивы и строки
    public void byteArrayConversion() throws Exception {
        String text = "Hello World";
        
        // String -> byte[]
        byte[] utf8Bytes = text.getBytes(StandardCharsets.UTF_8);
        byte[] utf16Bytes = text.getBytes(StandardCharsets.UTF_16);
        
        // byte[] -> String
        String recovered = new String(utf8Bytes, StandardCharsets.UTF_8);
        
        // Base64 кодирование (Java 8+)
        String encoded = Base64.getEncoder().encodeToString(utf8Bytes);
        byte[] decoded = Base64.getDecoder().decode(encoded);
    }
    
    // Разделение строки на массив
    public void stringToArray() {
        String csv = "apple,banana,orange";
        String[] fruits = csv.split(","); // ["apple", "banana", "orange"]
        
        // Регулярные выражения в split
        String complex = "apple; banana, orange. grape";
        String[] parts = complex.split("[;,\\.]\\s*");
    }
}
```

## Best Practices

### **Профилирование и оптимизация памяти**

```java
public class MemoryOptimization {
    // Для больших текстов используйте правильные структуры
    public void largeTextProcessing() {
        // Вместо String для больших текстов
        StringBuilder largeText = new StringBuilder(100_000);
        
        // Или используйте streaming для очень больших данных
        try (BufferedReader reader = new BufferedReader(new FileReader("large.txt"))) {
            String line;
            while ((line = reader.readLine()) != null) {
                processLine(line); // Обрабатываем по частям
            }
        }
    }
    
    // Оптимизация работы с массивами в high-frequency trading
    public void lowLatencyArrays() {
        // Используем примитивные массивы вместо коллекций
        int[] prices = new int[1000];
        // Прямой доступ к памяти - минимальная latency
        
        // Кэшируем часто используемые массивы
        private static final int[] EMPTY_INT_ARRAY = new int[0];
        
        // Избегаем bounds checking в критических секциях
        // (только если абсолютно уверены в индексах)
    }
}
```

### 2. **String caching стратегии**

```java
public class StringCaching {
    private final Map<String, String> stringCache = new ConcurrentHashMap<>();
    
    // Кэширование часто используемых строк
    public String getCachedString(String key) {
        return stringCache.computeIfAbsent(key, k -> expensiveStringCreation(k));
    }
    
    // Интернирование для дублирующихся строк
    public void smartInternUsage() {
        // Только для строк с высокой вероятностью дублирования
        List<String> manySimilarStrings = getStringsFromExternalSource();
        
        Map<String, String> internCache = new HashMap<>();
        for (String str : manySimilarStrings) {
            String interned = internCache.computeIfAbsent(str, String::intern);
            // Используем interned...
        }
    }
}
```


## Заключение

Массивы и строки — это фундамент, на котором строится все в Java. 

1. **Производительность** - правильный выбор структур влияет на latency и throughput
2. **Память** - неэффективное использование строк и массивов приводит к GC pressure
3. **Стабильность** - правильная обработка edge cases предотвращает падения

Запомните ключевые принципы:
- **Массивы** - для фиксированных размеров и максимальной скорости
- **Строки** - иммутабельность и String Pool это ваши друзья
- **StringBuilder** - всегда для конкатенации в циклах
- **Arrays utility** - используйте готовые оптимизированные методы

В современных системах с гигабайтами данных и миллионами операций в секунду эти знания окупаются многократно.

# OOP

## Что такое ООП?

Представьте, что вы описываете мир вокруг себя в программе. ООП — это способ думать о программе как о наборе объектов, которые взаимодействуют друг с другом. 

**Простая аналогия:** 
- **Класс** — это чертеж дома (описание)
- **Объект** — это реальный дом, построенный по чертежу
- **Методы** — это то, что дом может делать (открыть дверь, включить свет)
- **Поля** — это характеристики дома (цвет, количество окон)

## Философские основы ООП

### Исторический контекст и парадигмальный сдвиг
Объектно-ориентированное программирование возникло как ответ на растущую сложность программных систем в 1960-70-х годах. Если процедурное программирование фокусировалось на последовательности действий (алгоритмах), то ООП сместило акцент на данные и их организацию. Это был фундаментальный сдвиг от "что программа делает" к "с чем программа работает".

Основная философская идея ООП заключается в том, что программные системы должны моделировать реальный мир через объекты, которые сочетают в себе состояние (данные) и поведение (методы). Такой подход позволяет создавать более интуитивно понятные и поддерживаемые системы.

## Основные понятия ООП

```java
// Самый простой класс
class Dog {
    // Поля (характеристики собаки)
    String name;
    int age;
    
    // Методы (что собака умеет делать)
    void bark() {
        System.out.println(name + " говорит: Гав-гав!");
    }
    
    void sleep() {
        System.out.println(name + " спит...");
    }
}
```

## Классы и объекты

**Класс** — это шаблон, описание того, какими будут объекты.
**Объект** — это конкретный экземпляр класса.

```java
public class Main {
    public static void main(String[] args) {
        // Создаем объекты (экземпляры класса Dog)
        Dog dog1 = new Dog();
        dog1.name = "Шарик";
        dog1.age = 3;
        
        Dog dog2 = new Dog();
        dog2.name = "Бобик";
        dog2.age = 5;
        
        // Используем методы объектов
        dog1.bark();  // Шарик говорит: Гав-гав!
        dog2.sleep(); // Бобик спит...
    }
}
```

## Три кита ООП

### 1. Инкапсуляция

#### Сущность инкапсуляции
Инкапсуляция — это не просто технический прием сокрытия данных, а фундаментальный принцип управления сложностью. Его суть заключается в разделении интерфейса (того, что объект делает) и реализации (как он это делает). Это позволяет разработчикам работать с объектами как с "черными ящиками", не зная их внутреннего устройства.

#### Уровни абстракции инкапсуляции
1. **Структурная инкапсуляция** — сокрытие внутренней структуры данных
2. **Поведенческая инкапсуляция** — сокрытие алгоритмов и бизнес-логики
3. **Процессуальная инкапсуляция** — сокрытие последовательности операций
4. **Временная инкапсуляция** — управление временем жизни и состоянием объекта

#### Принципы проектирования через инкапсуляцию
- **Принцип минимального знания (Закон Деметры)**: объект должен знать только о своих непосредственных соседях
- **Принцип единственной ответственности**: каждый объект должен иметь одну четко определенную зону ответственности
- **Принцип инвариантов**: объект должен гарантировать сохранение своих внутренних условий корректности

#### Психологические аспекты инкапсуляции
С точки зрения когнитивной психологии, инкапсуляция снижает когнитивную нагрузку на разработчика, позволяя ему удерживать в рабочей памяти только релевантную информацию об объекте. Человеческий мозг эффективно работает с 7±2 концепциями одновременно, и инкапсуляция помогает уложиться в эти ограничения.

**Инкапсуляция** — это сокрытие внутреннего устройства и защита данных.

```java
class BankAccount {
    // private - значит, доступ только внутри класса
    private double balance;
    private String owner;
    
    // public методы - это "интерфейс" для работы с объектом
    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("Положили: " + amount);
        }
    }
    
    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println("Сняли: " + amount);
        } else {
            System.out.println("Недостаточно денег");
        }
    }
    
    // Геттер - метод для получения значения
    public double getBalance() {
        return balance;
    }
    
    public String getOwner() {
        return owner;
    }
    
    // Сеттер - метод для установки значения
    public void setOwner(String owner) {
        this.owner = owner;
    }
}

// Использование
public class Main {
    public static void main(String[] args) {
        BankAccount account = new BankAccount();
        account.setOwner("Иван Иванов");
        
        account.deposit(1000);
        account.withdraw(500);
        
        // account.balance = 1000000; // ОШИБКА! Поле private
        System.out.println("Баланс: " + account.getBalance());
    }
}
```


#### Философия инкапсуляции

**Инкапсуляция — это не просто "скрытие данных", это принцип организации кода:**

```java
// НЕПРАВИЛЬНЫЙ ПОДХОД: данные открыты для прямого доступа
class BankAccount {
    public double balance; // Опасность!
    public String owner;
}

// ПРАВИЛЬНЫЙ ПОДХОД: данные защищены, поведение контролируется
class BankAccount {
    private double balance;
    private String owner;
    
    // Конструктор - часть инкапсуляции
    public BankAccount(String owner, double initialBalance) {
        if (initialBalance < 0) {
            throw new IllegalArgumentException("Баланс не может быть отрицательным");
        }
        this.owner = owner;
        this.balance = initialBalance;
    }
    
    // Контролируемые методы доступа
    public void deposit(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Сумма должна быть положительной");
        }
        balance += amount;
    }
    
    public void withdraw(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Сумма должна быть положительной");
        }
        if (amount > balance) {
            throw new IllegalArgumentException("Недостаточно средств");
        }
        balance -= amount;
    }
    
    // Геттеры предоставляют доступ без возможности изменения
    public double getBalance() {
        return balance;
    }
    
    public String getOwner() {
        return owner;
    }
}
```

#### Уровни доступа

**В Java есть 4 уровня доступа, которые реализуют инкапсуляцию:**

```java
public class AccessExample {
    // public - доступно везде
    public String publicField = "Доступно отовсюду";
    
    // protected - доступно в пакете и наследниках
    protected String protectedField = "Доступно в пакете и наследниках";
    
    // default (package-private) - доступно только в пакете
    String defaultField = "Доступно только в пакете";
    
    // private - доступно только внутри класса
    private String privateField = "Доступно только внутри класса";
    
    // Методы также могут иметь разные уровни доступа
    public void publicMethod() {
        System.out.println("Публичный метод");
        privateMethod(); // Можно вызывать приватные методы внутри класса
    }
    
    private void privateMethod() {
        System.out.println("Приватный метод");
        System.out.println(privateField); // Доступ к приватному полю
    }
    
    protected void protectedMethod() {
        System.out.println("Защищенный метод");
    }
    
    void defaultMethod() {
        System.out.println("Метод с доступом по умолчанию");
    }
}

// Другой класс в том же пакете
class AnotherClass {
    public void testAccess() {
        AccessExample example = new AccessExample();
        example.publicField = "OK";           // Доступно
        example.protectedField = "OK";        // Доступно (в том же пакете)
        example.defaultField = "OK";          // Доступно (в том же пакете)
        // example.privateField = "ERROR";    // Ошибка! Приватное поле
    }
}

// Класс в другом пакете
package another.package;
import AccessExample;

class DifferentPackageClass {
    public void testAccess() {
        AccessExample example = new AccessExample();
        example.publicField = "OK";           // Доступно
        // example.protectedField = "ERROR";  // Ошибка! Разные пакеты
        // example.defaultField = "ERROR";    // Ошибка! Разные пакеты
        // example.privateField = "ERROR";    // Ошибка! Приватное поле
    }
}
```

#### Getter/Setter паттерн

**Правильная реализация геттеров и сеттеров:**

```java
class Person {
    private String name;
    private int age;
    private String email;
    
    // Конструктор
    public Person(String name, int age) {
        this.name = name;
        setAge(age); // Используем сеттер для валидации
    }
    
    // Геттер для name
    public String getName() {
        return name;
    }
    
    // Сеттер для name с валидацией
    public void setName(String name) {
        if (name == null || name.trim().isEmpty()) {
            throw new IllegalArgumentException("Имя не может быть пустым");
        }
        this.name = name.trim();
    }
    
    // Геттер для age
    public int getAge() {
        return age;
    }
    
    // Сеттер для age с валидацией
    public void setAge(int age) {
        if (age < 0 || age > 150) {
            throw new IllegalArgumentException("Возраст должен быть от 0 до 150");
        }
        this.age = age;
    }
    
    // Геттер для email
    public String getEmail() {
        return email;
    }
    
    // Сеттер для email с валидацией
    public void setEmail(String email) {
        if (email != null && !email.contains("@")) {
            throw new IllegalArgumentException("Некорректный email адрес");
        }
        this.email = email;
    }
    
    // Read-only свойство (только геттер)
    public boolean isAdult() {
        return age >= 18;
    }
}
```

#### Полная инкапсуляция

**Иммутабельные (неизменяемые) классы — высшая форма инкапсуляции:**

```java
// Иммутабельный класс - после создания нельзя изменить
public final class ImmutablePerson {
    private final String name;
    private final int age;
    private final List<String> hobbies;
    
    public ImmutablePerson(String name, int age, List<String> hobbies) {
        this.name = Objects.requireNonNull(name, "Имя не может быть null");
        
        if (age < 0) throw new IllegalArgumentException("Возраст не может быть отрицательным");
        this.age = age;
        
        // Защитная копия для mutable объектов
        this.hobbies = Collections.unmodifiableList(new ArrayList<>(
            Objects.requireNonNull(hobbies, "Хобби не может быть null")
        ));
    }
    
    // Только геттеры
    public String getName() { return name; }
    public int getAge() { return age; }
    public List<String> getHobbies() { 
        // Возвращаем неизменяемую копию
        return Collections.unmodifiableList(new ArrayList<>(hobbies));
    }
    
    // "Сеттеры" возвращают новый объект
    public ImmutablePerson withName(String newName) {
        return new ImmutablePerson(newName, age, hobbies);
    }
    
    public ImmutablePerson withAge(int newAge) {
        return new ImmutablePerson(name, newAge, hobbies);
    }
    
    public ImmutablePerson withHobby(String hobby) {
        List<String> newHobbies = new ArrayList<>(hobbies);
        newHobbies.add(hobby);
        return new ImmutablePerson(name, age, newHobbies);
    }
}
```


### 2. Наследование

#### Концептуальные основы наследования
Наследование базируется на отношении "is-a" (является), которое отражает иерархические отношения в предметной области. Это мощный инструмент для моделирования таксономий и классификаций, позволяющий выражать общность между различными сущностями.

#### Типы наследования
1. **Структурное наследование** — наследование полей и методов
2. **Поведенческое наследование** — наследование функциональности
3. **Интерфейсное наследование** — наследование контрактов без реализации
4. **Прототипное наследование** — наследование через делегирование (в других языках)

#### Теория подстановки (Liskov Substitution Principle)
Фундаментальный принцип наследования был формализован Барбарой Лисков: если S является подтипом T, то объекты типа T могут быть заменены объектами типа S без изменения желательных свойств программы. Это означает, что наследник должен полностью удовлетворять контракту родителя.

#### Проблемы и ограничения наследования
- **Хрупкость базового класса**: изменения в родительском классе могут непредсказуемо повлиять на наследников
- **Проблема алмаза**: конфликты при множественном наследовании (решаются в Java через интерфейсы)
- **Избыточная связность**: тесная coupling между классами в иерархии
- **Нарушение инкапсуляции**: наследники могут получать излишний доступ к внутреннему устройству родителя

#### Когнитивные аспекты наследования
С точки зрения ментальных моделей, наследование позволяет разработчикам строить сложные концептуальные иерархии, но при чрезмерном использовании может приводить к "когнитивному перегрузу". Оптимальная глубина иерархии обычно не превышает 3-5 уровней для эффективного восприятия.


**Наследование** — это возможность создавать новые классы на основе существующих.

```java
// Базовый класс (родительский)
class Animal {
    String name;
    
    void eat() {
        System.out.println(name + " кушает");
    }
    
    void sleep() {
        System.out.println(name + " спит");
    }
}

// Производный класс (дочерний) - наследует от Animal
class Cat extends Animal {
    // Новый метод, специфичный для кошек
    void meow() {
        System.out.println(name + " говорит: Мяу!");
    }
}

class Dog extends Animal {
    // Новый метод, специфичный для собак
    void bark() {
        System.out.println(name + " говорит: Гав-гав!");
    }
}

// Использование
public class Main {
    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.name = "Мурка";
        cat.eat();  // Унаследованный метод
        cat.meow(); // Свой метод
        
        Dog dog = new Dog();
        dog.name = "Шарик";
        dog.sleep(); // Унаследованный метод
        dog.bark();  // Свой метод
    }
}
```

#### Иерархия классов

**Наследование создает отношения "is-a" (является):**

```java
// Базовый класс (суперкласс)
class Vehicle {
    protected String brand;
    protected int year;
    protected double speed;
    
    public Vehicle(String brand, int year) {
        this.brand = brand;
        this.year = year;
        this.speed = 0;
    }
    
    public void start() {
        System.out.println(brand + " запущен");
    }
    
    public void stop() {
        speed = 0;
        System.out.println(brand + " остановлен");
    }
    
    public void accelerate(double acceleration) {
        speed += acceleration;
        System.out.println(brand + " ускорился до " + speed + " км/ч");
    }
    
    // final метод - нельзя переопределить в наследниках
    public final String getInfo() {
        return brand + " (" + year + ")";
    }
}

// Производный класс (подкласс)
class Car extends Vehicle {
    private int doors;
    private String fuelType;
    
    // Конструктор с вызовом конструктора родителя
    public Car(String brand, int year, int doors, String fuelType) {
        super(brand, year); // Вызов конструктора Vehicle
        this.doors = doors;
        this.fuelType = fuelType;
    }
    
    // Новый метод, специфичный для Car
    public void honk() {
        System.out.println(brand + " сигналит: Би-бип!");
    }
    
    // Переопределение метода родителя
    @Override
    public void accelerate(double acceleration) {
        super.accelerate(acceleration); // Вызов метода родителя
        System.out.println("Автомобиль плавно набирает скорость");
    }
}

// Еще один производный класс
class Motorcycle extends Vehicle {
    private boolean hasSidecar;
    
    public Motorcycle(String brand, int year, boolean hasSidecar) {
        super(brand, year);
        this.hasSidecar = hasSidecar;
    }
    
    // Свой метод
    public void wheelie() {
        System.out.println(brand + " делает вилли!");
    }
    
    // Переопределение с другой логикой
    @Override
    public void accelerate(double acceleration) {
        speed += acceleration * 1.5; // Мотоциклы ускоряются быстрее
        System.out.println(brand + " резко ускорился до " + speed + " км/ч");
    }
}
```

#### Переопределение методов

**Правила переопределения методов (method overriding):**

```java
class Animal {
    protected String name;
    
    public Animal(String name) {
        this.name = name;
    }
    
    // Метод для переопределения
    public void makeSound() {
        System.out.println(name + " издает звук");
    }
    
    // final метод - нельзя переопределить
    public final void breathe() {
        System.out.println(name + " дышит");
    }
    
    // static метод - не переопределяется, а скрывается
    public static void describe() {
        System.out.println("Это животное");
    }
}

class Dog extends Animal {
    public Dog(String name) {
        super(name);
    }
    
    // Правильное переопределение
    @Override
    public void makeSound() {
        System.out.println(name + " говорит: Гав-гав!");
    }
    
    // Нельзя переопределить final метод
    // @Override
    // public void breathe() { } // ОШИБКА!
    
    // Сокрытие static метода (не переопределение!)
    public static void describe() {
        System.out.println("Это собака");
    }
    
    // Перегрузка (overloading) - другой метод с тем же именем
    public void makeSound(int times) {
        for (int i = 0; i < times; i++) {
            makeSound(); // Вызов переопределенного метода
        }
    }
}
```

#### Ключевые слова super и this

**Различие между super и this:**

```java
class Parent {
    protected String name = "Родитель";
    
    public void print() {
        System.out.println("Родительский метод");
    }
    
    public void commonMethod() {
        System.out.println("Общий метод в родителе");
    }
}

class Child extends Parent {
    private String name = "Ребенок";
    
    public void demonstrateKeywords() {
        // this - ссылка на текущий объект
        System.out.println("this.name: " + this.name);        // Ребенок
        System.out.println("this.getClass(): " + this.getClass()); // Child
        
        // super - ссылка на родительскую часть объекта
        System.out.println("super.name: " + super.name);      // Родитель
        
        // Вызов методов
        this.commonMethod();    // Вызовет метод ребенка (если переопределен)
        super.commonMethod();   // Всегда вызовет метод родителя
        
        // Вызов конструктора родителя
        // super(); // Только в конструкторе и первой строкой
    }
    
    @Override
    public void commonMethod() {
        System.out.println("Общий метод в ребенке");
    }
    
    public void callBoth() {
        super.commonMethod(); // Родительская версия
        this.commonMethod();  // Детская версия
    }
}
```

#### Абстрактные классы

**Абстрактные классы — это "неполные" классы, которые нельзя инстанцировать:**

```java
// Абстрактный класс
abstract class Shape {
    protected String color;
    protected boolean filled;
    
    public Shape(String color, boolean filled) {
        this.color = color;
        this.filled = filled;
    }
    
    // Абстрактный метод - без реализации
    public abstract double getArea();
    public abstract double getPerimeter();
    
    // Обычный метод с реализацией
    public String getColor() {
        return color;
    }
    
    public void setColor(String color) {
        this.color = color;
    }
    
    // final метод в абстрактном классе
    public final String getDescription() {
        return "Фигура цвета " + color + " (" + (filled ? "заполненная" : "пустая") + ")";
    }
}

// Конкретный класс должен реализовать все абстрактные методы
class Circle extends Shape {
    private double radius;
    
    public Circle(String color, boolean filled, double radius) {
        super(color, filled);
        this.radius = radius;
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
    
    // Свой специфичный метод
    public double getDiameter() {
        return 2 * radius;
    }
}

class Rectangle extends Shape {
    private double width;
    private double height;
    
    public Rectangle(String color, boolean filled, double width, double height) {
        super(color, filled);
        this.width = width;
        this.height = height;
    }
    
    @Override
    public double getArea() {
        return width * height;
    }
    
    @Override
    public double getPerimeter() {
        return 2 * (width + height);
    }
}
```

### 3. Полиморфизм

#### Сущность полиморфизма
Полиморфизм — это способность объектов различного типа реагировать на одинаковые сообщения разным образом. Это механизм, который позволяет абстрагироваться от конкретных типов и работать с объектами через общий интерфейс.

#### Типы полиморфизма
1. **Параметрический полиморфизм** (дженерики) — работа с разными типами через параметризацию
2. **Полиморфизм подтипов** (наследование) — возможность использовать объекты подтипов вместо базовых типов
3. **Ad-hoc полиморфизм** (перегрузка) — разные реализации для разных типов параметров
4. **Полиморфизм включения** (интерфейсы) — реализация общего интерфейса разными классами

#### Динамическое связывание и виртуальные методы
Ключевой механизм полиморфизма — динамическое связывание (late binding), при котором конкретная реализация метода выбирается во время выполнения на основе фактического типа объекта, а не типа ссылки. Это достигается через таблицы виртуальных методов (vtable), которые хранят указатели на актуальные реализации.

#### Теория контрактов и полиморфизм
Полиморфизм тесно связан с теорией контрактов (Design by Contract). Каждый полиморфный метод имеет:
- **Pre-conditions** — условия, которые должны быть истинны перед вызовом
- **Post-conditions** — условия, гарантируемые после выполнения
- **Invariants** — условия, сохраняемые в течение всего времени жизни объекта

#### Математические основы полиморфизма
С математической точки зрения, полиморфизм можно рассматривать через теорию категорий, где морфизмы (методы) могут по-разному отображать объекты различных типов. Типовая система полиморфизма обеспечивает безопасность выполнения операций через статическую проверку типов.

**Полиморфизм** — это возможность использовать объекты разных классов одинаковым образом.

```java
class Animal {
    String name;
    
    void makeSound() {
        System.out.println(name + " издает звук");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println(name + " говорит: Мяу!");
    }
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println(name + " говорит: Гав-гав!");
    }
}

class Cow extends Animal {
    @Override
    void makeSound() {
        System.out.println(name + " говорит: Му-у-у!");
    }
}

// Использование полиморфизма
public class Main {
    public static void main(String[] args) {
        // Создаем массив животных
        Animal[] animals = new Animal[3];
        animals[0] = new Cat();
        animals[1] = new Dog();
        animals[2] = new Cow();
        
        animals[0].name = "Мурка";
        animals[1].name = "Шарик";
        animals[2].name = "Буренка";
        
        // Одинаковый код для разных животных
        for (Animal animal : animals) {
            animal.makeSound(); // Каждое животное издаст свой звук!
        }
    }
}
```

#### Типы полиморфизма

**В Java есть несколько видов полиморфизма:**

```java
// 1. Полиморфизм переопределения (Runtime Polymorphism)
class Animal {
    public void makeSound() {
        System.out.println("Животное издает звук");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Собака лает");
    }
}

class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Кошка мяукает");
    }
}

// 2. Полиморфизм перегрузки (Compile-time Polymorphism)
class Calculator {
    // Перегрузка методов - разные параметры
    public int add(int a, int b) {
        return a + b;
    }
    
    public double add(double a, double b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
}

// 3. Полиморфизм через интерфейсы
interface Drawable {
    void draw();
}

class Circle implements Drawable {
    @Override
    public void draw() {
        System.out.println("Рисую круг");
    }
}

class Square implements Drawable {
    @Override
    public void draw() {
        System.out.println("Рисую квадрат");
    }
}
```

#### Динамическое связывание

**Полиморфизм времени выполнения (dynamic binding):**

```java
class Animal {
    public void makeSound() {
        System.out.println("Животное издает звук");
    }
    
    // Статический метод - связывание на этапе компиляции
    public static void staticMethod() {
        System.out.println("Статический метод Animal");
    }
}

class Dog extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Собака лает");
    }
    
    // Сокрытие статического метода (не полиморфизм!)
    public static void staticMethod() {
        System.out.println("Статический метод Dog");
    }
}

public class PolymorphismTest {
    public static void main(String[] args) {
        // Динамическое связывание - тип объекта определяет поведение
        Animal myAnimal = new Dog(); // Upcasting
        myAnimal.makeSound(); // "Собака лает" - вызывается метод Dog
        
        // Статическое связывание - тип ссылки определяет поведение
        myAnimal.staticMethod(); // "Статический метод Animal"
        
        // Проверка типа во время выполнения
        if (myAnimal instanceof Dog) {
            Dog myDog = (Dog) myAnimal; // Downcasting
            myDog.makeSound(); // "Собака лает"
        }
    }
}
```

#### Время компиляции vs выполнения

**Различие между ранним и поздним связыванием:**

```java
class EarlyLateBinding {
    // Раннее связывание (компиляция) - перегрузка
    public void process(int number) {
        System.out.println("Обработка int: " + number);
    }
    
    public void process(String text) {
        System.out.println("Обработка String: " + text);
    }
    
    // Позднее связывание (выполнение) - переопределение
}

class Parent {
    public void show() {
        System.out.println("Родительский show");
    }
}

class Child extends Parent {
    @Override
    public void show() {
        System.out.println("Дочерний show");
    }
}

public class BindingTest {
    public static void main(String[] args) {
        EarlyLateBinding elb = new EarlyLateBinding();
        
        // Раннее связывание - компилятор определяет какой метод вызвать
        elb.process(10);    // Обработка int: 10
        elb.process("текст"); // Обработка String: текст
        
        // Позднее связывание - JVM определяет во время выполнения
        Parent obj = new Child(); // Upcasting
        obj.show(); // "Дочерний show" - определяется во время выполнения
    }
}
```


## Простые примеры из жизни

### Пример 1: Книга и библиотека

```java
class Book {
    private String title;
    private String author;
    private int year;
    
    // Конструктор - специальный метод для создания объекта
    public Book(String title, String author, int year) {
        this.title = title;
        this.author = author;
        this.year = year;
    }
    
    public void displayInfo() {
        System.out.println(title + " - " + author + " (" + year + ")");
    }
}

class Library {
    private Book[] books;
    private int count;
    
    public Library(int size) {
        books = new Book[size];
        count = 0;
    }
    
    public void addBook(Book book) {
        if (count < books.length) {
            books[count] = book;
            count++;
        }
    }
    
    public void showAllBooks() {
        for (int i = 0; i < count; i++) {
            books[i].displayInfo();
        }
    }
}

// Использование
public class Main {
    public static void main(String[] args) {
        Library library = new Library(10);
        
        Book book1 = new Book("Война и мир", "Лев Толстой", 1869);
        Book book2 = new Book("Преступление и наказание", "Достоевский", 1866);
        
        library.addBook(book1);
        library.addBook(book2);
        
        library.showAllBooks();
    }
}
```

### Пример 2: Геометрические фигуры

```java
class Shape {
    String color;
    
    void draw() {
        System.out.println("Рисую фигуру цвета " + color);
    }
}

class Circle extends Shape {
    double radius;
    
    @Override
    void draw() {
        System.out.println("Рисую круг радиусом " + radius + " цвета " + color);
    }
}

class Rectangle extends Shape {
    double width;
    double height;
    
    @Override
    void draw() {
        System.out.println("Рисую прямоугольник " + width + "x" + height + " цвета " + color);
    }
}

public class Main {
    public static void main(String[] args) {
        Circle circle = new Circle();
        circle.color = "красный";
        circle.radius = 5.0;
        
        Rectangle rectangle = new Rectangle();
        rectangle.color = "синий";
        rectangle.width = 10.0;
        rectangle.height = 5.0;
        
        circle.draw();    // Рисую круг радиусом 5.0 цвета красный
        rectangle.draw(); // Рисую прямоугольник 10.0x5.0 цвета синий
    }
}
```

## Частые ошибки начинающих

### Ошибка 1: Не использовать инкапсуляцию

```java
// ПЛОХО
class Student {
    public String name;    // Опасно!
    public int age;        // Любой может изменить
    public double grade;   // напрямую
}

// ХОРОШО
class Student {
    private String name;
    private int age;
    private double grade;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public int getAge() { return age; }
    public void setAge(int age) { 
        if (age > 0 && age < 150) {
            this.age = age; 
        }
    }
}
```

### Ошибка 2: Путать класс и объект

```java
class Car {
    String model;
}

public class Main {
    public static void main(String[] args) {
        // Car.model = "BMW"; // ОШИБКА! model принадлежит объекту, а не классу
        
        Car car1 = new Car(); // Правильно - создаем объект
        car1.model = "BMW";   // Теперь можно работать с полем
        
        Car car2 = new Car();
        car2.model = "Audi";
    }
}
```

### Ошибка 3: Не понимать наследование

```java
class Vehicle {
    void start() {
        System.out.println("Транспорт запущен");
    }
}

class Car extends Vehicle {
    // Уже имеет метод start() от Vehicle
    void drive() {
        System.out.println("Машина едет");
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();
        car.start(); // Можно использовать! Унаследован от Vehicle
        car.drive(); // Свой метод
    }
}
```


## Взаимосвязь концепций

#### Системный взгляд на ООП
Три столпа ООП не существуют изолированно — они образуют взаимосвязанную систему:
- **Инкапсуляция** создает границы объектов
- **Наследование** устанавливает отношения между объектами
- **Полиморфизм** обеспечивает гибкое взаимодействие через эти отношения

#### Принцип композиции над наследованием
Современная теория ООП сместила акцент с наследования на композицию. Композиция (отношение "has-a") обеспечивает лучшую инкапсуляцию и меньшую связность, чем наследование. Это отражает принцип "предпочитайте композицию наследованию" из Design Patterns.

#### Теория типов в ООП
Система типов в ООП обеспечивает:
- **Безопасность типов** — предотвращение ошибок несовместимости
- **Абстракцию типов** — возможность работы с объектами через общие интерфейсы
- **Выводимость типов** — автоматическое определение типов в некоторых контекстах

#### ООП и функциональное программирование
Современные языки, включая Java, демонстрируют конвергенцию ООП и функционального программирования. Иммутабельность, функции высшего порядка и лямбда-выражения дополняют традиционные ООП-концепции, обеспечивая более выразительный и безопасный код.

#### ООП в распределенных системах
В микросервисной архитектуре принципы ООП находят новое применение:
- Инкапсуляция реализуется через границы сервисов
- Полиморфизм проявляется в различных реализациях сервисов
- Наследование заменяется композицией сервисов

#### Когнитивные ограничения и ООП
Теория когнитивных нагрузок объясняет, почему ООП эффективно для сложных систем: оно позволяет разбивать сложность на управляемые части, соответствующие ограничениям человеческой рабочей памяти. Однако чрезмерное усложнение иерархий может нарушить это преимущество.

**Как три концепции работают вместе:**

```java
// Инкапсуляция: скрываем детали реализации
abstract class BankAccount {
    private String accountNumber;
    private double balance;
    private String owner;
    
    protected BankAccount(String accountNumber, double balance, String owner) {
        this.accountNumber = accountNumber;
        this.balance = balance;
        this.owner = owner;
    }
    
    // Инкапсуляция через геттеры
    public final String getAccountNumber() { return accountNumber; }
    public final String getOwner() { return owner; }
    public double getBalance() { return balance; }
    
    // Абстрактный метод - наследование
    public abstract void withdraw(double amount);
    
    // Инкапсуляция бизнес-логики
    protected void updateBalance(double amount) {
        balance += amount;
    }
}

// Наследование: расширяем функциональность
class SavingsAccount extends BankAccount {
    private double interestRate;
    
    public SavingsAccount(String accountNumber, double balance, String owner, double interestRate) {
        super(accountNumber, balance, owner);
        this.interestRate = interestRate;
    }
    
    // Полиморфизм: своя реализация withdraw
    @Override
    public void withdraw(double amount) {
        if (amount > getBalance()) {
            throw new IllegalArgumentException("Недостаточно средств на сберегательном счете");
        }
        updateBalance(-amount);
        System.out.println("Снятие со сберегательного счета: " + amount);
    }
    
    // Уникальный метод
    public void applyInterest() {
        double interest = getBalance() * interestRate / 100;
        updateBalance(interest);
    }
}

class CheckingAccount extends BankAccount {
    private double overdraftLimit;
    
    public CheckingAccount(String accountNumber, double balance, String owner, double overdraftLimit) {
        super(accountNumber, balance, owner);
        this.overdraftLimit = overdraftLimit;
    }
    
    // Полиморфизм: другая реализация withdraw
    @Override
    public void withdraw(double amount) {
        if (amount > getBalance() + overdraftLimit) {
            throw new IllegalArgumentException("Превышен овердрафт");
        }
        updateBalance(-amount);
        System.out.println("Снятие с текущего счета: " + amount);
    }
}

// Использование всех трех концепций
public class BankDemo {
    public static void main(String[] args) {
        BankAccount savings = new SavingsAccount("123", 1000, "Иван", 5.0);
        BankAccount checking = new CheckingAccount("456", 500, "Петр", 200);
        
        // Полиморфизм: одинаковый интерфейс, разное поведение
        processWithdrawal(savings, 1200); // Ошибка - недостаточно средств
        processWithdrawal(checking, 600); // Успех - работает овердрафт
        
        // Инкапсуляция: не можем напрямую изменить баланс
        // savings.balance = 1000000; // Ошибка! Поле private
    }
    
    // Метод работает с любым BankAccount благодаря полиморфизму
    public static void processWithdrawal(BankAccount account, double amount) {
        try {
            account.withdraw(amount);
            System.out.println("Баланс после снятия: " + account.getBalance());
        } catch (IllegalArgumentException e) {
            System.out.println("Ошибка: " + e.getMessage());
        }
    }
}
```

## FAQ

**Q: В чем разница между перегрузкой (overloading) и переопределением (overriding)?**
A: 
- **Перегрузка** - методы с одним именем но разными параметрами (в одном классе)
- **Переопределение** - замена реализации метода в наследнике

**Q: Можно ли иметь конструктор в абстрактном классе?**
A: Да! Абстрактные классы могут иметь конструкторы для инициализации общих полей.

**Q: Что такое ковариантный возвращаемый тип?**
A: В Java можно сузить возвращаемый тип при переопределении:
```java
class Animal {
    public Animal reproduce() { return new Animal(); }
}

class Dog extends Animal {
    @Override
    public Dog reproduce() { return new Dog(); } // Более конкретный тип
}
```

**Q: Как работает multiple inheritance в Java?**
A: Java не поддерживает множественное наследование классов, но поддерживает множественную реализацию интерфейсов.

**Q: Что такое динамический полиморфизм?**
A: Это когда конкретный метод вызывается на основе типа объекта во время выполнения, а не типа ссылки во время компиляции.

**Q: Зачем нужны final классы и методы?**
A: Final классы нельзя наследовать, final методы нельзя переопределять. Это полезно для безопасности и проектирования API.

**Q: Что такое сокрытие методов (method hiding)?**
A: Когда статический метод в подклассе имеет ту же сигнатуру, что и в родительском классе - это сокрытие, а не переопределение.

**Q: Что такое конструктор?**
A: Это специальный метод, который вызывается при создании объекта. Он имеет то же имя, что и класс.

```java
class Person {
    String name;
    int age;
    
    // Конструктор
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

// Использование
Person person = new Person("Иван", 25); // Вызывается конструктор
```

**Q: Зачем нужно слово "this"?**
A: "this" ссылается на текущий объект. Помогает различить параметры метода и поля класса.

```java
class Example {
    String name;
    
    public void setName(String name) {
        this.name = name; // this.name - поле класса, name - параметр
    }
}
```

**Q: Что такое @Override?**
A: Это аннотация, которая показывает, что метод переопределяет метод родительского класса. Не обязательно, но помогает избежать ошибок.

**Q: Можно ли наследовать от нескольких классов?**
A: В Java нет множественного наследования классов. Класс может наследовать только от одного класса.

**Q: В чем разница между public и private?**
A: 
- Public - доступно отовсюду
- Private - доступно только внутри класса

## Заключение

ООП — это крайне сложно! Но главное понять основные идеи:
1. **Класс** — это чертеж, **объект** — конкретная вещь
2. **Инкапсуляция** — прячем данные, даем методы для работы с ними
3. **Наследование** — создаем новые классы на основе существующих  
4. **Полиморфизм** — разные объекты могут делать одно и то же по-разному

Начинайте с простых примеров, практикуйтесь, и скоро ООП станет для вас естественным способом мышления.

Помните: даже самые сложные программы состоят из простых классов и объектов!






