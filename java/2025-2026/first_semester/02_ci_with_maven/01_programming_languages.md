# Что такое язык программирования?

## «Уровни» языков программирования

### Низкоуровневые языки

С точки зрения Wikipedia, язык программирования — формальный язык, предназначенный для записи
компьютерных программ. Язык программирования определяет набор лексических, синтаксических и
семантических правил, определяющих внешний вид программы и действия, которые выполнит исполнитель 
(обычно — ЭВМ) под её управлением.

Кажется, что такое определение не добавляет понимания, для чего языки программирования нужны.
Посмотрим на это с другой стороны. Вообще процессор воспринимает в качестве инструкций лишь набор
нулей и единиц (далее _машинный язык_). Разные сочетания могут отображать:

1. Обращение к регистрам процессора
2. Push или pull операции со стеком
3. Вызов системных процедур и некоторые другие

Понятно, что для человека написать даже простую программу на машинном языке — непосильная задача.
Для решения проблемы
придумали [Assembler](https://ru.wikipedia.org/wiki/%D0%90%D1%81%D1%81%D0%B5%D0%BC%D0%B1%D0%BB%D0%B5%D1%80)
— транслятор в машинный код. Каждая строчка кода на Assembler преобразуется в соответствующую
операцию на машинном языке. Вот пример классического `Hello, World` на
диалекте [NASM](https://www.nasm.us/).

```asm
        global  _main
        extern  _printf

        section .text
_main:
        push    message
        call    _printf
        add     esp, 4
        ret
message:
        db      'Hello, World', 10, 0
```

Для определенных задач Assembler является оптимальным решением. Но у него есть ряд проблем:

1. Диалект Assembler отличается на разных операционных системах. Это значит, что программу, которую
   вы написали на Windows, не получится запустить на Linux.
2. Уровень взаимодействия с компьютером слишком низкоуровневый. Даже для такой простой задачи как
   вывод в консоль надписи `Hello, World` потребовалось работать с регистрами и стеком процессора
   напрямую.
3. Поддержка таких программ обходится дорого.

> Под поддержкой обычно понимается время,
> которое было затрачено на написание кода, тестирование и исправления возможных багов.
> То есть долгая разработка буквально требует большего количества денег:
> зарплаты, аренда помещения, отпуска, больничные и так далее.

Представьте себе, что вам нужно написать консольный калькулятор, который бы выдавал ответы на
выражения вида `2 + 5` или `15 * 17`. Технически это возможно. Но даже такая примитивная программа
получилась бы крайне сложной на Assembler.

### Языки «среднего» уровня

Язык C стал этаким более высокоуровневым Assembler. Идея простая:

1. Программист пишет код на языке C, который напоминает английский текст.
2. Компилятор преобразует код на языке C в машинный код текущей платформы.
3. Машинный код выполняется процессором.

Для сравнения, вот тот же `Hello, World` на языке C.

```c
#include <stdio.h>

int main() {
   printf("Hello, World");
   return 0;
}
```

Теперь все стало гораздо прозрачнее. У нас есть функции, типы данных, параметры, возвращаемые
значения и, самое главное, компилятор, который преобразует понятный человеку код в формат для
выполнения компьютером. Казалось бы, что на этом можно остановится, но здесь тоже есть нюансы.

Во-первых, язык C по-прежнему довольно близок к «железу», как и Assembler. За счет этого код, хотя и
становится проще, в некоторых задачах по-прежнему выходит довольно громоздким. Во-вторых, в C
нет [сборщика мусора](https://ru.wikipedia.org/wiki/%D0%A1%D0%B1%D0%BE%D1%80%D0%BA%D0%B0_%D0%BC%D1%83%D1%81%D0%BE%D1%80%D0%B0). 
Это значит, что выделение памяти и ее последующее очищение возлагается на плечи программиста.
Посмотрите на пример кода ниже.

```c
#include <stdlib.h>

void f(int n)
{
  int* array = calloc(n, sizeof(int));
  do_some_work(array);
}
```

В данном фрагменте мы выделяем место в памяти для массива типа `int` из `n` элементов и передаем
указатель на него в функцию `do_some_work`. Но после этого память не освобождается (функция `free`).
Если `do_some_work` внутри себя также не очищает `array`, то память останется занятой, пока жив
процесс операционной системы. Если программа работает достаточно долго, это может привести к тому,
что занимаемый объем RAM будет постоянно расти, пока ОС не забьет тревогу и не убьет процесс.

> Есть анализаторы кода, которые помогают найти подобные ошибки.
> Но они не могут гарантировать стопроцентный результат, хотя и помогают в обнаружении багов.

Представьте себе, что вы разрабатываете сервис, который отвечает за перевод денег с одного
банковского счета на другой. Если вы неосторожно передадите указатель неверного типа, то можете
«повредить» соответствующий участок памяти. В лучшем случае это приведет к rollback транзакции в
БД, а в худшем – к неправильно записанному результату.

> Транзакции и реляционные базы данных будем разбирать далее в курсе.

Есть и другая проблема с языком C – это кроссплатформенность. Хотя сам язык и позволяет
разрабатывать софт под разные операционные системы, конечный продукт - скомпилированный машинный код
в бинарном формате - собирается под текущую платформу. Это значит, что «бинарник», который вы
скомпилировали в Visual Studio под Windows, вы не сможете запустить на Linux. Для этого придется
компилировать под Linux заново.

> Проблема заключается еще и в том,
> что близость языка C к «железу» приводит к наличию функций, которые зависят от конкретной платформы.
> Например, компилятор под Windows ожидает вызов одних функций при работе с сокетами, а компилятор под Linux – других.
> Есть способы, как преодолеть это препятствие, однако объяснение этого выходит за рамки нашего курса.

### Языки высокого уровня

Программирование не ограничивается написанием драйверов и прочими низкоуровневыми решениями. Есть
запросы и на бизнес-приложения. Например, сервисы доставки еды, приложения по заказу такси,
инструменты для каршеринга, перевод денег в режиме онлайн и так далее. При реализации таких программ
существуют следующие требования:

1. **Безопасность**. Программа не должна «крашиться», например, из-за неверного обращения к адресу
   памяти.
2. **Скорость разработки**. Цикл создания продукта должен быть достаточно быстрым, чтобы
   подстраиваться под меняющиеся требования рынка.
3. **Поддержка**. Бизнес-приложения создаются с расчетом на долгосрочную эксплуатацию. Например, если
   вы создали сервис по заказу такси через смартфон, со временем его характеристики могут меняться:
   тарифы оплаты, система отзывов, алгоритмы подбора водителей. Чтобы обеспечить такие требования,
   во-первых, код должен быть расширяем. Во-вторых, программный код должен быть достаточно понятен,
   чтобы в нем мог разобраться новый программист.

Вышеописанные требования не могут быть полностью обеспечены языком С, а тем более Assembler. Нам
нужна более высокая абстракция, которая скроет от нас низкоуровневые детали и поможет
сосредоточиться на бизнес-логике. Значит, высокоуровневый язык программирования должен
предоставлять:

1. **Сборщик мусора** (Garbage Collector) – это часть среды выполнения языка программирования,
   которая автоматически освобождает память для неиспользующихся объектов. Подробнее про GC читайте
   далее в курсе.
2. **Отсутствие указателей на конкретные участки памяти**. Операции с памятью напрямую, как мы уже
   выяснили, могут быть очень опасны. Представьте себе, что из-за ошибки передачи указателя
   страховая компания согласовала человеку сумму в 10 раз больше одобренной изначально. Поэтому
   высокоуровневый язык программирования должен быть освобожден от подобных вещей.
3. **Кроссплатформенность**. Это значит, что результирующий «билд» должен запускаться не только на
   той системе, на которой он был собран, а на любой (или почти любой). Предположим, что вы
   поставляете клиентам некое бизнес-приложения для запуска на системе Windows, в то время как ваши
   программисты работают на Linux. Если «билд» не является переносимым, то вам придется дать
   исходный код продукта вашим клиентам, чтобы они могли скомпилировать его самостоятельно.
   Во-первых, клиенты могут не располагать нужными компетенциями. Во-вторых, код может быть защищен
   авторским правом.
4. **Более низкий порог входа**. Программисты приходят и уходят. А код, который они написали,
   остается. Это значит, что язык не должен быть чрезмерно усложнен, чтобы новые разработчики,
   уровень которых также может быть разным, могли быстро «влиться» в процесс разработки.

Большинство прикладных языков, о которых мы часто слышим, относятся к языкам высокого уровня.
Например, Java, Python, C#, Javascript и другие.

## Типизация языков программирования

Типы в языках программирования – довольно сложный академический предмет. При желании вы можете найти
в Интернете бесчисленное множество статей о теории языков программирования. Но в рамках курса мы не
будем уходить далеко, а проведем краткий ликбез, чтобы иметь общее представление о том, с чем вы
столкнетесь в рамках вашей карьеры разработчика.

Языки программирования можно разделить на следующие типы:

1. Со статической/динамической типизацией
2. С сильной/слабой типизацией
3. С явной/неявной типизацией

> Еще существуют бестиповые языки программирования.
> К ним можно отнести, например, Assembler или [BrainFuck](https://ru.wikipedia.org/wiki/Brainfuck).
> Подавляющее же большинство языков общего назначения **типизированные**.
> Некоторые ошибочно причисляют языки с динамической типизацией (Python, Javascript, PHP) к бестиповым,
> потому что явно в них типы не указываются.
> Это утверждение ошибочно. Подробнее об этом читайте ниже.

Рассмотрим каждое деление подробнее.

### Статическая/динамическая типизация

В статически типизированных языках корректность типов проверяется на этапе компиляции. То есть на
момент выполнения программы среда исполнения уже точно знает, какой тип ожидается в той или иной
строчке кода. В динамических же языках типы становятся известны лишь на моменте выполнения
конкретной инструкции.

К статическим языкам относятся: Java, C++, C#, Scala. К динамических языкам относятся: Python,
Javascript, PHP.

Посмотрите ниже на пример кода на языке Java.

```java
class Main {
    public static void main(String[] args) {
        int a = 45;
        int b = 55;
        System.out.println(sum(a, b));
    }

    public static int sum(int a, int b) {
        return a + b;
    }
}
```

Если мы попробуем передать в функцию `sum` вместо `int` тип `String`, будет ошибка компиляции, и
программа не выполнится. То же самое произойдет, если в переменную `a` мы попробуем присвоить,
например, коллекцию.

Посмотрите ниже на похожий код на языке Python.

```python
def sum(a, b):
    return a + b


if __name__ == '__main__':
    a = 45
    b = 55
    print(sum(a, b))
```

Тут видны некоторые отличия. Во-первых, мы нигде не указываем типы, потому что интерпретатор
определяет их автоматически в процессе **выполнения**. Во-вторых, если в `sum` мы передадим
значения, которые нельзя складывать (например, строку и число), ошибки компиляции не будет, и
программа успешно запустится. Тем не менее в строчке `a + b` произойдет исключение из-за попытки
сложения несовместимых типов (читайте далее про сильную/слабую типизацию).

Преимущества статической типизации:

1. Проверки типов происходят только один раз — на этапе компиляции. А это значит, что мы всегда
   уверены в типах значений, которые к нам приходят извне.
2. Статически типизированные языки практически всегда быстрее динамических, потому что нет накладных
   расходов на дополнительное определение типа значения в runtime.
3. Ускорение разработки при поддержке IDE: подсказка при вызове функций, autocomplete и так далее.

Преимущества динамической типизации:

1. Простота создания универсальных коллекций из разных типов. Однако такая необходимость
   возникает редко.
2. Легкость в освоении. Такие языки хорошо подходят для тех, кто хочет понять основы
   программирования.

В разработке промышленных решений (Java здесь лидер рынка) обычно применяют языки со статической
типизацией. Есть ряд причин:

1. Несоответствие типов гарантирует, что программа не запустится. В динамических же языках
   выполнение дойдет ровно до той строчки, где интерпретатор распознает ошибку. Представьте, что вы
   обрабатываете запрос клиента, который формирует заказ и снимает деньги со счета. Будет не очень
   приятно, если из-за ошибки типов заказ сформируется, а деньги не снимутся.
2. Сложность предметной области. Промышленные приложения автоматизируют бизнес-сценарии, которые
   сложны сами по себе. Статически типизированные языки позволяют описать контракты, корректность
   вызова которых будет проверяться компилятором, а не программистом.
3. В бизнес-приложениях может быть довольно много кода. Качественный autocomplete, который IDE
   предоставляют для статических языков, сильно ускоряют разработку.

> Для динамических языков сложно реализовать хороший autocomplete, потому что тип точно не известен,
> пока программа не начнет выполняться. Поэтому нельзя сказать однозначно, какими атрибутами обладает переданный объект.

### Пару слов о var

В Java, Scala, Kotlin и некоторых других языках программирования есть возможность не указывать тип
явно, а заменить его на ключевое слово `var`, чтобы компилятор определил его автоматически.
Некоторые программисты считают, что это внедрение динамической типизации в статические языки. Это не
так. Посмотрите ниже на пример кода Java с использованием `var`.

```java
class Main {
    public static void main(String[] args) {
        var a = 45;
        var b = 55;
        System.out.println(sum(a, b));
    }

    public static int sum(int a, int b) {
        return a + b;
    }
}
```

В данном случае, тип `int` определился компилятором автоматически. Но если мы передадим в функцию
значение, отличное от `int`, или аналогичным образом попытаемся переопределить переменную, также будет
ошибка компиляции. Посмотрите на пример ниже.

```java
class Main {
    public static void main(String[] args) {
        var temp = "some_string";
        // ошибка компиляции: temp типа String, нельзя присвоить int
        temp = 78;
        var a = 45;
        var b = "55";
        System.out.println(
            // ошибка компиляции: b типа String, но ожидался int
            sum(a, b)
        );
    }

    public static int sum(int a, int b) {
        return a + b;
    }
}
```

### Сильная/слабая типизация

Сильная/слабая типизация означает отсутствие или наличие автоматического преобразование типов. Если
типизация слабая, то вы можете в одном выражении применять совершенно не связанные между собой
объекты, и компилятор (или интерпретатор) приведет их к одному типу. Если же типизация сильная, то
подобные смешивания недопустимы. Программист должен вручную привести все типы к единому
значению.

Важно отметить, что сильная/слабая типизация не связана со статической/динамической. Язык может быть
статическим и слабым (язык C) или динамическим и сильным (язык PHP).

Рассмотрим сильную типизацию на примере Python. Посмотрите на код ниже.

```python
s = "Hello, World"
s1 = {
    'key': 'value'
}
# TypeError:  unsupported operand type(s) for +: 'dict' and 'str'
result_str = s + s1
```

В данном случае мы пытаемся сложить строку `Hello, World`
и словарь (объект формата ключ-значение). В Python нет преобразований типов в выражениях, поэтому
операция завершается с ошибкой. Чтобы это исправить, нужно явно трансформировать словарь в строку
перед операцией сложения. Посмотрите на исправленный пример кода ниже:

```python
s = "Hello, World"
s1 = {
    'key': 'value'
}
# {'key': 1}d"
result_str = s + str(s1)
```

Слабая типизация ведет себя иначе. Посмотрите на похожий код на языке Javascript ниже:

```javascript
const s = "Hello, World";
const s1 = {
    key: 'value'
}
// Hello, World[object Object]
result_str = s + s1;
```

Как можно заметить, `s1` был автоматически преобразован к строке вида `[object Object]`. После
конкатенации итоговый результат равен `Hello, World[object Object]`.

Это может показаться удобным, так как теперь интерпретатор решает проблемы конвертации типов за нас.
В действительности же это может приводить к неожиданным результатами и трудноуловимым багам.
Например, результат всех выражений ниже на Javascript равен `true`.

```javascript
[] == ![];
+[] == +![];
0 == +false
0 == false
false == []
false == ![]
```

Как можно догадаться, подобные «удобства» только вызывают дополнительные сложности. Поэтому в
Javascript есть оператор строгого равенства – `===` – который не выполняет никаких приведений типов
самостоятельно.

```javascript
0 === false; // false
false === [] // false
0 === 0 // true
```

Стоит отметить, что в Java, языке с сильной типизацией, также присутствуют некоторые преобразования
типов. Например, при операциях с численными типами.

```java
class Main {
    public static void main(String[] args) {
        int i = 12;
        double d = 13.5;
        // d == 12.0
        d = i;
    }
}
```

Но в обратную сторону это не работает. Будет ошибка, так как при присваивании `double` к `int`
возможна потеря данных.

```java
class Main {
    public static void main(String[] args) {
        int i = 12;
        double d = 13.5;
        // incompatible types: possible lossy conversion from double to int
        i = d;
    }
}
```

Также безопасно можно конкатенировать строки и числа.

```java
class Main {
    public static void main(String[] args) {
        // abc10
        System.out.println("abc" + 10);
    }
}
```

### Явная/неявная типизация

Неявная типизация относится к автоматическому выводу типов компилятором без их указания
программистом. Самый простой пример неявной типизации мы рассматривали ранее – это ключевое
слово `var`. Также есть и более сложные варианты. Например, в Haskell можно не указывать тип
возвращаемого значения и параметры функции. Компилятор выведет их автоматически на основании
операций, которые выполняются со значениями. Посмотрите на пример кода ниже:

```haskell
-- Без явного указания типа
add (x, y) = x + y

-- Явное указание типа
add :: (Integer, Integer) -> Integer
add (x, y) = x + y
```

Обратите внимание, что критерии явной и неявной типизации имеет отношение только к статическим
языкам, так как в динамических язках типы и так не указываются, поскольку определяются во время выполнения.

## Вывод по языкам программирования

Может сложиться впечатление, что мы пытаемся представить ситуацию так, как будто один язык
программирования лучше другого. Это не так. Язык – это инструмент для решения задачи. Разные языки
лучше себя показывают в различных сценариях. Нет смысла пытаться забить гвоздь пассатижами, если есть молоток, 
которым сделать это гораздо удобнее. Здесь также можно вспомнить шутку Бьерна Страуструпа, создателя
языка C++.

> Есть два вида языков программирования. На одни все жалуются, другими никто не пользуется. 
