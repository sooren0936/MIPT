Open API, Interface driven controllers, E2E tests, Testcontainers

**Введение к лекции: Java OpenAPI в экосистеме Spring**  
**Тема:** Современные подходы к документированию и управлению RESTful API с использованием OpenAPI и Spring  

---

**Добрый день, уважаемые студенты!**  

Сегодня мы погрузимся в мир современных API, где скорость разработки, прозрачность взаимодействия и автоматизация играют ключевую роль. Представьте, что вы работаете над крупным проектом с десятками микросервисов. Как обеспечить согласованность между командами? Как избежать ошибок при интеграции? Как быстро объяснить новым разработчикам, как работает ваш API? Ответ на эти вопросы — **OpenAPI**, стандарт, который стал неотъемлемой частью современной разработки.  

Если вы ещё не сталкивались с проблемой «у меня всё работает, но фронтенд не может подключиться» — после этой лекции вы поймёте, как её избежать.

А если говорить о Java-экосистеме, то фреймворк **Spring** предлагает мощные инструменты для интеграции OpenAPI, превращая ваше API из «чёрного ящика» в хорошо структурированный, документированный и легко тестируемый ресурс. В этой лекции мы разберём:  
- Почему документация API критически важна в эпоху микросервисов.  
- Как Spring упрощает генерацию OpenAPI-спецификаций.  
- Практические шаги по внедрению OpenAPI в ваши проекты.  
- Лучшие практики и инструменты для управления жизненным циклом API.  

---

### **Часть 1: Зачем нужна документация API?**  
**Контекст:**  
В 2023 году 83% компаний используют микросервисную архитектуру (источник: O’Reilly). Каждый сервис предоставляет API, и без чёткой документации взаимодействие между ними превращается в хаос.  

**Проблемы без OpenAPI:**  
1. **«Сломанные» интеграции:** Разработчики фронтенда и мобильных приложений тратят дни на расшифровку «загадочных» эндпоинтов.  
2. **Ручное документирование:** Устаревшие PDF-файлы или Wiki-страницы, которые никто не обновляет.  
3. **Ошибки в тестировании:** Непредсказуемые коды ответов и форматы данных приводят к падению продакшена.  

**Пример из практики:**  
В 2016 году компания *Apiwise* провела аудит своих API и обнаружила, что 40% времени разработки уходит на исправление ошибок, вызванных недокументированными изменениями. После внедрения OpenAPI эти затраты сократились в 3 раза.  

---

### **Часть 2: OpenAPI и Spring — идеальный симбиоз**  
**Что такое OpenAPI?**  
OpenAPI (ранее Swagger) — это спецификация на базе YAML/JSON, которая формально описывает:  
- Эндпоинты (GET /users, POST /orders).  
- Параметры запросов и тела.  
- Модели данных (DTO).  
- Коды ответов (200 OK, 404 Not Found).  
- Аутентификацию (OAuth 2, JWT).  

**Инструменты Spring для OpenAPI:**  
1. **Springfox (устаревший):** Первая библиотека для интеграции Swagger 2.0.  
2. **SpringDoc (актуальный):** Поддерживает OpenAPI 3.0, совместим с Spring Boot 3+.  

**Почему SpringDoc?**  
- Генерация документации «на лету» через аннотации.  
- Интеграция с Swagger UI и ReDoc для визуализации.  
- Поддержка кастомизации и расширений.  

---

### **Часть 3: Практика — с нуля до работающего API**  
**Шаг 1: Настройка проекта**  
Добавим зависимости в `pom.xml` (Maven):  
```xml  
<dependency>  
    <groupId>org.springdoc</groupId>  
    <artifactId>springdoc-openapi-starter-webmvc-ui</artifactId>  
    <version>2.1.0</version>  
</dependency>  
```  

**Шаг 2: Аннотации — «магия» SpringDoc**  
Рассмотрим контроллер для управления пользователями:  
```java  
@RestController  
@RequestMapping("/api/users")  
@Tag(name = "User API", description = "Управление пользователями")  
public class UserController {  

    @Operation(summary = "Получить пользователя по ID")  
    @ApiResponse(responseCode = "200", description = "Пользователь найден")  
    @GetMapping("/{id}")  
    public ResponseEntity<User> getUser(@Parameter(description = "ID пользователя") @PathVariable Long id) {  
        // Логика  
    }  
}  
```  

**Шаг 3: Запуск и визуализация**  
После запуска приложения откройте:  
- Swagger UI: `http://localhost:8080/swagger-ui.html`  
- OpenAPI JSON: `http://localhost:8080/v3/api-docs`  

---

### **Часть 4: Лучшие практики**  
1. **Детализация моделей:** Используйте `@Schema` для описания DTO.  
```java  
@Schema(name = "User", description = "Сущность пользователя")  
public class User {  
    @Schema(description = "Уникальный идентификатор", example = "123")  
    private Long id;  
}  
```  

2. **Документирование ошибок:**  
```java  
@ApiResponse(  
    responseCode = "404",  
    description = "Пользователь не найден",  
    content = @Content(schema = @Schema(implementation = ErrorResponse.class))  
)  
```  

3. **Безопасность:** Добавьте описание аутентификации.  
```java  
@SecurityScheme(  
    name = "BearerAuth",  
    type = SecuritySchemeType.HTTP,  
    scheme = "bearer",  
    bearerFormat = "JWT"  
)  
```  

---

### **Часть 5: Интеграция с инструментами**  
- **Postman:** Импортируйте OpenAPI-спецификацию для автоматического создания коллекций.  
- **Генерация клиентского кода:** Используйте `openapi-generator` для создания SDK на Python, TypeScript и других языках.  
- **Мониторинг:** Интеграция с Elasticsearch и Kibana для анализа использования API.  

---

### **Заключение**  
OpenAPI в Spring — это не просто «галочка» в требованиях проекта. Это философия, которая превращает ваше API в прозрачный, надёжный и легко масштабируемый продукт. К концу этой лекции вы не только освоите технические аспекты, но и научитесь мыслить как архитектор, для которого документация — это мост между идеей и её реализацией.  


--- 
## Interface driven controllers

Обычно при определении контроллера в Spring MVC мы декорируем его методы различными аннотациями, которые определяют запрос: URL-адрес конечной точки, метод HTTP-запроса, переменные пути и т. д.

Например, мы можем ввести  конечную точку _/save/{id},_  используя указанные аннотации для простого метода:

```java
@PostMapping("/save/{id}")
@ResponseBody
public Book save(@RequestBody Book book, @PathVariable int id) {
    // implementation
}
```

Конечно, это не проблема, когда у нас есть только один контроллер, который обрабатывает запросы. Ситуация немного меняется, когда у нас есть несколько контроллеров с одинаковыми сигнатурами методов.

Например, у нас могут быть две разные версии контроллера — из-за миграции или чего-то подобного — с одинаковыми сигнатурами методов. В этом случае у нас будет значительное количество дублирующихся аннотаций, сопровождающих определения методов. Очевидно, это нарушит принцип DRY ( _не повторяйся_ ).
Если бы эта ситуация имела место для чистых классов Java, мы бы просто определили интерфейс и заставили классы реализовать этот интерфейс. В контроллерах **основная нагрузка на методы ложится не на сигнатуры методов, а на аннотации методов.**

Однако в версии Spring 5.1 появилась новая [функция:](https://github.com/spring-projects/spring-framework/wiki/What%27s-New-in-Spring-Framework-5.x#general-web-revision-1)

> Аннотации параметров контроллера также обнаруживаются на интерфейсах: что позволяет выполнять полные контракты сопоставления в интерфейсах контроллера.

Давайте рассмотрим, как можно использовать эту функцию.
Мы проиллюстрируем новую функцию на примере очень простого приложения REST, которое управляет книгами. Оно будет состоять всего из одного контроллера с методами, которые позволят нам извлекать и изменять книги.

Давайте определим обычный интерфейс Java, в котором мы определим не только сигнатуры методов, но и тип веб-запросов, которые они должны обрабатывать:

```java
@RequestMapping("/default")
public interface BookOperations {

    @GetMapping("/")
    List<Book> getAll();

    @GetMapping("/{id}")
    Optional<Book> getById(@PathVariable int id);

    @PostMapping("/save/{id}")
    public void save(@RequestBody Book book, @PathVariable int id);
}
```

Обратите внимание, что у нас может быть аннотация на уровне класса, а также на уровне метода. Теперь мы можем создать контроллер, реализующий этот интерфейс:

```java
@RestController
@RequestMapping("/book")
public class BookController implements BookOperations {

    @Override
    public List<Book> getAll() {...}

    @Override
    public Optional<Book> getById(int id) {...}

    @Override
    public void save(Book book, int id) {...}

}
```

**Нам все равно следует добавить аннотацию класса _@RestController_ или _@Controller_ к нашему контроллеру.** Определенный таким образом, контроллер наследует все аннотации, связанные с отображением веб-запросов.

Чтобы проверить, что контроллер теперь работает так, как и ожидалось, запустим приложение и вызовем метод _getAll()_ , выполнив соответствующий запрос:

```java
curl http://localhost:8081/book/
```

Несмотря на то, что контроллер реализует интерфейс, мы можем дополнительно настроить его, добавив аннотации веб-запросов. Мы можем сделать это так же, как мы сделали это для интерфейса: либо на уровне класса, либо на уровне метода. Фактически, мы использовали эту возможность при определении контроллера:

```java
@RequestMapping("/book")
public class BookController implements BookOperations {...}
```

Если мы добавим аннотации веб-запросов к контроллеру, они будут иметь приоритет над аннотациями интерфейса. Другими словами, **Spring интерпретирует интерфейсы контроллера способом, похожим на то, как Java работает с наследованием.**

Мы определяем все общие свойства веб-запросов в интерфейсе, но в контроллере мы всегда можем их точно настроить.

Когда у нас есть интерфейс и различные контроллеры, которые его реализуют, мы можем столкнуться с ситуацией, когда веб-запрос может быть обработан более чем одним методом. Естественно, Spring выдаст исключение:

```java
Caused by: java.lang.IllegalStateException: Ambiguous mapping.
```

Если мы добавим к контроллеру _@RequestMapping_ , мы сможем снизить риск неоднозначных сопоставлений.

---  
## 1 . Введение в End-to-End тестирование  
  
### 1 .1. Определение и цели тестирования  
  
End-to-end тестирование (E2E) – это комплексное тестирование программного обеспечения, направленное на проверку всей цепочки взаимодействий между различными компонентами системы от начала до конца. Цель данного тестирования заключается в том, чтобы убедиться, что все интегрированные модули системы работают корректно в реальных условиях эксплуатации.  
  
В отличие от модульных тестов, где проверяется изолированное поведение отдельных классов или методов, end-to-end тесты имитируют реальный сценарий использования приложения. Это включает в себя:  
- Проверку корректного взаимодействия между фронтендом и бэкендом;  
- Тестирование работы базы данных;  
- Взаимодействие с внешними сервисами;   
- Валидацию бизнес-логики на всех уровнях приложения.  
    
### 1 .2. Роль E2E тестирования в современной разработке  
  
В современных распределённых системах и микросервисной архитектуре особое значение приобретает тестирование на уровне всей системы. Оно позволяет:  
- Обнаруживать ошибки в интеграции между компонентами, которые не выявляются модульными тестами;  
- Гарантировать, что изменения в одном модуле не нарушают работу всей системы;  
- Проверять соответствие конечного результата ожиданиям пользователей.  
  
### 1 .3. Отличие от модульного и интеграционного тестирования  

Для лучшего понимания, рассмотрим кратко три уровня тестирования:  
- Модульное тестирование проверяет отдельные части кода (классы, методы) изолированно. Обычно используются библиотеки вроде JUnit, TestNG.  
- Интеграционное тестирование направлено на проверку взаимодействия между несколькими модулями или сервисами, часто с использованием «подставных» реализаций (mock-объектов).  
- End-to-end тестирование охватывает всю систему, включая внешние зависимости, и тестирует реальные сценарии использования
  
## 2 . Архитектура Java Spring и её особенности для тестирования  
  
### 2 .1. Основы Spring Framework  
  
Spring Framework – это контейнер инверсии управления (IoC), предоставляющий инфраструктуру для разработки корпоративных приложений на языке Java. Основные концепции Spring включают:  
- Инверсию управления (IoC): управление созданием и конфигурацией объектов (бинов) поручается контейнеру.  
- Внедрение зависимостей (Dependency Injection, DI): зависимости между компонентами передаются извне.  
- Аспектно-ориентированное программирование (AOP): позволяет внедрять кросс-секционные функциональности (например, логирование, транзакционное управление).  
  
### 2 .2. IoC контейнер, DI и управление жизненным циклом бинов  
  
Контейнер Spring отвечает за создание, настройку и уничтожение бинов. Рассмотрим кратко основные этапы жизненного цикла Spring Bean:  
  
1. Создание (Instantiation): Контейнер создает объект с помощью конструктора.  
2. Внедрение зависимостей (Dependency Injection): Зависимости (другие бины, значения) внедряются через конструктор, сеттеры или поля.    
3. Инициализация (Initialization): Вызываются методы, помеченные аннотациями @PostConstruct или через интерфейс InitializingBean.    
4. Использование: Бин используется в работе приложения.  
5. Уничтожение (Destruction): При закрытии контекста вызываются методы с аннотацией @PreDestroy или через интерфейс DisposableBean.  
  
Пример класса с полным жизненным циклом:  
``` java

@Component  
public class SampleBean implements InitializingBean, DisposableBean {  
  
	@Autowired  
	private DependencyService dependency;  
	  
	public SampleBean() {  
	System.out.println("Конструктор: SampleBean создан");  
	}  
	  
	@PostConstruct  
	public void initMethod() {  
	System.out.println("Метод @PostConstruct: SampleBean инициализирован");  
	}  
	  
	@Override  
	public void afterPropertiesSet() {  
	System.out.println("InitializingBean: afterPropertiesSet вызван");  
	}  
	  
	public void performAction() {  
	dependency.execute();  
	}  
	@PreDestroy  
	public void preDestroy() {  
	System.out.println("Метод @PreDestroy: SampleBean будет уничтожен");  
	}  
	  
	@Override  
	public void destroy() {  
	System.out.println("DisposableBean: destroy вызван");  
	}  
}  
  
```

  

### 2 .3. Особенности тестирования Spring-приложений  
  
При тестировании Spring-приложений важно учитывать следующие моменты:  
- Контекст приложения: Для E2E тестов зачастую требуется запуск полноценного Spring контекста, что позволяет протестировать все интеграционные зависимости.  
- Изоляция окружения: Использование тестовых конфигураций (например, профили Spring) позволяет изолировать тестовое окружение от продакшн.  
- Управление транзакциями: Часто в тестах используются транзакционные аннотации, чтобы обеспечить откат изменений в базе данных после выполнения теста.  
  
  
Пример настройки тестового класса с использованием Spring Boot Test:  
```java

@RunWith(SpringRunner.class)  
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)  
public class EndToEndTest {  
	  
	@LocalServerPort  
	private int port;  
	  
	@Autowired  
	private TestRestTemplate restTemplate;  
	  
	@Test  
	public void testHomePage() {  
	ResponseEntity<String> response = restTemplate.getForEntity("http://localhost:" + port + "/", String.class);  
	assertEquals(HttpStatus.OK, response.getStatusCode());  
	assertTrue(response.getBody().contains("Welcome"));  
	}  
}  

``` 
  
В приведённом примере: 
@SpringBootTest – загружает полный контекст приложения.  
@LocalServerPort – позволяет использовать случайно назначенный порт для тестового веб-сервера.  
TestRestTemplate – удобный клиент для выполнения HTTP запросов в тестах.  
  
---  

## 3 . Конфигурация тестового окружения в Spring  
  
Настройка тестового окружения является ключевым этапом end-to-end тестирования, поскольку от корректности конфигурации зависит воспроизводимость тестов и изоляция от продакшн-среды.  
  
### 3 .1. Использование аннотаций для загрузки контекста  
  
При написании тестов в Spring-приложениях применяются следующие аннотации:  
``` java

@SpringBootTest  
Запускает полный контекст приложения. Часто используется с параметром webEnvironment, который задаёт способ запуска веб-сервера (например, RANDOM_PORT).  
  
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)  
public class FullContextE2ETest {  
  
@LocalServerPort  
private int port;  
  
@Test  
public void contextLoads() {  
// Тест проверяет, что контекст приложения успешно загружен  
}  
}  

```

```java

@ActiveProfiles("test")  
Позволяет использовать отдельный профиль для тестов. Это удобно для настройки подключения к тестовой базе данных, логирования и прочих параметров.  
  
@SpringBootTest  
@ActiveProfiles("test")  
public class ProfileBasedTest {  
// Тесты, использующие test-профиль  
}  

```


  
### 3 .2. Настройка тестовой базы данных  
  
Для обеспечения изоляции тестов часто используется in-memory база данных (например, H2) или TestContainers для поднятия реальной БД.  
  
Пример настройки H2 в [application-test.properties](https://web.telegram.org/a/application-test.properties):  
  ```
spring.datasource.url=jdbc:h2:mem:testdb;DB_CLOSE_DELAY=-1;DB_CLOSE_ON_EXIT=FALSE  
spring.datasource.username=sa  
spring.datasource.password=  
spring.datasource.driver-class-name=org.h2.Driver  
spring.jpa.database-platform=org.hibernate.dialect.H2Dialect  
  
  ```

  
### 4 . Лучшие практики и рекомендации по end-to-end тестированию
1. Организация тестовой структуры проекта
	**Разделяйте тесты по уровням:**  
	Размещайте модульные, интеграционные и E2E тесты в отдельных пакетах.  
	**Ясное именование тестовых классов и методов:**  
	Имена должны отражать тестируемый сценарий и функциональность.  
	**Изоляция тестового окружения:**  
	Используйте отдельные конфигурации (например, test-профили) для тестов.  
2. Управление тестовыми данными
	**Использование фикстур:**  
	Подготовьте набор данных, который будет использоваться для тестирования.  
	**Транзакционный откат:**  
	Используйте аннотацию @Transactional в тестах, чтобы изменения в базе данных откатывались после выполнения теста.  
	**Моки и стаб-сервисы:**  
	При необходимости изолируйте тесты от внешних зависимостей с помощью моков.  
3. CI/CD и автоматизация запуска тестов  
	**Интеграция в систему сборки:**  
	Настройте запуск end-to-end тестов в рамках CI/CD (например, Jenkins, GitLab CI).  
	**Параллельное выполнение тестов:**  
	Для ускорения прогонов тестов применяйте параллельное выполнение.  
	**Отчёты и логирование:**  
	Настройте подробные отчёты о тестировании для быстрого обнаружения и анализа ошибок.  

  
---  
## 1 . Введение в тестирование MVC слоя  
  
### 1 .1. Понятие и цели тестирования MVC  
  
В Spring Framework MVC (Model-View-Controller) представляет собой паттерн проектирования, где:  
  
- Контроллеры обрабатывают входящие HTTP запросы,  
- Сервисы содержат бизнес-логику,  
- Модель представляет данные,  
- View отвечает за представление данных (JSP, Thymeleaf, и т.д.).  
  
Цель тестирования MVC слоя состоит в проверке корректной обработки HTTP запросов контроллерами, валидации входных данных, работы механизмов биндинга и обработки ошибок, а также в обеспечении того, что маршрутизация и маппинг URL работают согласно требованиям.  
  
### 1 .2. Отличие тестирования MVC от модульного тестирования бизнес-логики  
  
При модульном тестировании основное внимание уделяется отдельным компонентам (сервисам, репозиториям), а тесты контроллеров должны концентрироваться на проверке маршрутизации, параметров запросов, статусов HTTP ответов и содержимого ответа. Это позволяет изолировать веб-слой от остальных компонентов приложения.  
  
### 1 .3. Роль контроллеров в архитектуре Spring MVC  
  
Контроллеры являются входной точкой для обработки запросов. Они:  
  
- Принимают запросы с клиентской стороны,  
- Выполняют предварительную валидацию входных параметров,   
- Делегируют обработку бизнес-логике,    
- Формируют HTTP ответы с соответствующими статусами и данными.  
  
  
  
---  
  
## 2 . Стандартные средства тестирования в Spring  
  
### 2 .1. Аннотация @WebMvcTest  
  
Аннотация @WebMvcTest позволяет создать тестовый контекст, в котором поднимается только веб-слой приложения. Это ускоряет выполнение тестов, так как не загружается полный Spring-контекст.  
  
Пример использования:  
  ```java
import org.junit.jupiter.api.Test;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;  
import org.springframework.test.web.servlet.MockMvc;  
  
@WebMvcTest(controllers = UserController.class)  
public class UserControllerMvcTest {  
  
@Autowired  
private MockMvc mockMvc;  
  
// Тесты ниже будут работать только с компонентами веб-слоя  
}  
  

  ```

### 2 .2. Компонент MockMvc  
  
MockMvc – ключевой инструмент для тестирования MVC в Spring. Он позволяет симулировать HTTP запросы к контроллерам, выполнять проверку статуса ответа, заголовков, содержимого (JSON, XML или HTML) без необходимости поднимать реальный веб-сервер.  
  
Основные возможности MockMvc:  ![[Pasted image 20250210151614.png]]
- Выполнение GET, POST, PUT, DELETE запросов.  
- Настройка параметров запроса и тела.  
- Проверка ответа с использованием matchers (например, status, content, jsonPath).  
  
### 2 .3. Интеграция с JUnit и Spring Test Context


Spring Test Context Framework интегрируется с JUnit (или TestNG) и обеспечивает создание и управление тестовым контекстом, что позволяет внедрять зависимости в тестовые классы. Аннотация @WebMvcTest совместно с @AutoConfigureMockMvc (если требуется дополнительная конфигурация) создают среду, близкую к реальной работе контроллеров.  
  
  
---  
  
## 3 . Основные принципы и подходы  
  
### 3 .1. Изоляция MVC слоя  
  
При тестировании MVC слоя важно изолировать контроллеры от других слоев (например, сервисов или репозиториев). Для этого:  
- Заменяют зависимости на моки (с помощью Mockito или других инструментов).  
- Тестируют исключительно поведение контроллеров: входящие параметры, вызовы сервисных методов, обработку ошибок.  
  
  
### 3 .2. Мокирование зависимостей  
  
При использовании @WebMvcTest можно замокировать сервисы, которые внедряются в контроллеры. Это позволяет сконцентрироваться на тестировании логики маршрутизации и валидации, не затрагивая реализацию бизнес-логики.  
  
Пример:  

```java
import static org.mockito.Mockito.when;  
import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;  
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;  
  
import org.junit.jupiter.api.Test;  
import org.mockito.MockBean;  
import org.springframework.boot.test.autoconfigure.web.servlet.WebMvcTest;  
import org.springframework.test.web.servlet.MockMvc;  
  
@WebMvcTest(controllers = UserController.class)  
public class UserControllerMvcTest {  
  
	@Autowired  
	private MockMvc mockMvc;  
	  
	@MockBean  
	private UserService userService; // Сервис, зависимость которого замокирована  
	  
	@Test  
	public void testGetUserById() throws Exception {  
		// Подготовка тестовых данных  
		User mockUser = new User(1L, "john_doe", "john@example.com");  
		when(userService.getUserById(1L)).thenReturn(mockUser);  
		  
		// Выполнение запроса и проверка результата  
		mockMvc.perform(get("/users/1"))  
		.andExpect(status().isOk())  
		.andExpect(jsonPath("$.id").value(1))  
		.andExpect(jsonPath("$.username").value("john_doe"))  
		.andExpect(jsonPath("$.email").value("john@example.com"));  
	}  
}  

```
  
  
В данном примере:  
  
- @MockBean создаёт мок-объект для UserService, внедряемый в UserController.  
- Выполняется HTTP GET запрос на /users/1.   
- С помощью matchers проверяется, что статус ответа 200 (OK) и что JSON содержит ожидаемые значения.  
  
  
### 3 .3. Проверка HTTP запросов и ответов  
  
MockMvc позволяет задавать параметры запроса, заголовки, содержимое тела запроса, а также проводить подробную проверку ответа. Примеры включают проверку статуса (isOk, isCreated, isNotFound и т.д.), содержимого ответа (jsonPath, contentType) и заголовков.  
  
  
---  
  
## 4 . Практические примеры тестирования MVC  
  
### 4 .1. Тестирование GET запросов  
  
Контроллер:  
  ```java 
  @RestController  
  @RequestMapping("/users")  
  public class UserController {  
    
	  @Autowired  
	  private UserService userService;  
	    
	  @GetMapping("/{id}")  
	  public ResponseEntity<User> getUser(@PathVariable Long id) {  
		  User user = userService.getUserById(id);  
		  return user != null 
		  ? ResponseEntity.ok(user) 
		  : ResponseEntity.notFound().build();  
	  }  
  }  
  
  ```

  
Тестирование GET запроса:  
```java

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.get;  
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;  
  
@Test  
public void whenGetExistingUser_thenReturnUserJson() throws Exception {  
	User mockUser = new User(1L, "alice", "alice@example.com");  
	when(userService.getUserById(1L)).thenReturn(mockUser);  
	  
	mockMvc.perform(get("/users/1"))  
	.andExpect(status().isOk())  
	.andExpect(content().contentType("application/json"))  
	.andExpect(jsonPath("$.username").value("alice"))  
	.andExpect(jsonPath("$.email").value("alice@example.com"));  
}  

```

  
### 4.2. Тестирование POST запросов  
  
Контроллер для создания пользователя:  
```java

@RestController  
@RequestMapping("/users")  
public class UserController {  
  
@Autowired  
private UserService userService;

@PostMapping  
public ResponseEntity<User> createUser(@RequestBody User user) {  
	User createdUser = userService.createUser(user);  
	return ResponseEntity.status(HttpStatus.CREATED).body(createdUser);  
	}  
}  


```

  
Тестирование POST запроса с использованием MockMvc:  
```java

import static org.springframework.test.web.servlet.request.MockMvcRequestBuilders.post
import static org.springframework.test.web.servlet.result.MockMvcResultMatchers.*;  
  
@Test  
public void whenValidInput_thenCreateUser() throws Exception {  
	User inputUser = new User(null, "bob", "bob@example.com");  
	User createdUser = new User(10L, "bob", "bob@example.com");  
	  
	when(userService.createUser(any(User.class))).thenReturn(createdUser);  
	  
	String userJson = "{\"username\":\"bob\",\"email\":\"bob@example.com\"}";  
	  
	mockMvc.perform(post("/users")  
	.contentType("application/json")  
	.content(userJson))  
	.andExpect(status().isCreated())  
	.andExpect(jsonPath("$.id").value(10))  
	.andExpect(jsonPath("$.username").value("bob"));  
}  

```

  
### 4 .3. Проверка валидации и обработки ошибок  
  
Контроллер может использовать валидацию входных данных посредством аннотаций JSR-380 (например, @Valid). При некорректном вводе Spring автоматически возвращает ошибку.  
  
Контроллер с валидацией:  

```java

@RestController  
@RequestMapping("/users")  
public class UserController {  
  
@PostMapping  
public ResponseEntity<User> createUser(@Valid @RequestBody User user) {  
	// Если данные не проходят валидацию, Spring выбросит MethodArgumentNotValidException  
	return ResponseEntity.status(HttpStatus.CREATED).body(user);  
	}  
}  

```
  
  
Тестирование валидации:  
  ```java
@Test  
public void whenInvalidInput_thenReturns400() throws Exception {  
	// Передаём некорректный JSON (например, отсутствует обязательное поле username)  
	String invalidUserJson = "{\"email\":\"invalid@example.com\"}";  
	  
	mockMvc.perform(post("/users")  
	.contentType("application/json")  
	.content(invalidUserJson))  
	.andExpect(status().isBadRequest())  
	.andExpect(jsonPath("$.errors").exists());  
}  
  
  ```

  
  
---  
  
## 5 . Расширенные возможности тестирования  
  
### 5 .1. Тестирование security слоев  
  
При наличии настроек Spring Security для контроллеров можно подключить фильтры безопасности в тестовом контексте. Использование аннотаций типа @WithMockUser позволяет имитировать аутентифицированного пользователя.  
  
Пример:  
  ```java
@Test  
@WithMockUser(username = "admin", roles = {"ADMIN"})  
public void whenAuthenticated_thenAccessGranted() throws Exception {  
	mockMvc.perform(get("/admin/dashboard"))  
	.andExpect(status().isOk());  
}  
  
  ```

  
### 5 .2. Использование кастомных аргумент резолверов  
  
Если в контроллере применяются аргументы, разрешаемые через кастомные аргумент резолверы (например, текущий пользователь из сессии), то в тестовом окружении можно также настроить подобные резолверы либо замокировать их работу.  
  
### 5 .3. Тестирование сериализации/десериализации JSON  
  
Проверка корректности конвертации объектов в JSON и обратно может выполняться с помощью библиотеки Jackson, которая интегрирована в Spring Boot. MockMvc позволяет использовать jsonPath для проверки содержимого ответа.  
  
  
---  
  
## 6 . Заключение и лучшие практики  
  
### 6 .1. Основные рекомендации  
  
1. Изолируйте тестируемый MVC слой: Используйте @WebMvcTest для сокращения времени загрузки контекста.  
2. Замокируйте зависимости: Применяйте @MockBean для сервисов, чтобы тесты контроллеров были независимы от бизнес-логики. 
3. Проверяйте все аспекты HTTP ответа: Статус, заголовки, тело ответа, наличие ошибок и валидационных сообщений.  
  
### 6 .2. Лучшая организация тестов  
  
1. Размещайте тесты контроллеров в отдельном пакете, например, com.example.project.controller. 
2. Поддерживайте единый стиль оформления тестовых классов и методов, чтобы упростить их поддержку.  
3. Документируйте сценарии тестирования и случаи обработки ошибок.  
### 6 .3. Заключительные замечания
Тестирование MVC слоя стандартными средствами Spring позволяет достичь высокой степени изоляции и надежности тестов веб-слоя приложения. Применение MockMvc в сочетании с аннотацией @WebMvcTest обеспечивает быстрый цикл разработки и проверки контроллеров, гарантируя корректную работу маршрутизации, валидации и формирования HTTP ответов. Такие тесты легко интегрируются в конвейер CI/CD и служат надёжным барьером для предотвращения регрессий в веб-слое.  
  
---    
### 1 . Введение в End-to-End тестирование и роль TestContainers  
  
## 1 .1. Цели и задачи End-to-End тестирования  
  
End-to-End (E2E) тестирование представляет собой всестороннюю проверку всего приложения, от пользовательского интерфейса до баз данных и внешних интеграций. Основная цель E2E тестирования — убедиться, что все компоненты системы корректно взаимодействуют друг с другом и в совокупности обеспечивают требуемый функционал при работе в реальных условиях эксплуатации.  
  
Ключевые цели E2E тестирования:  
  
- Проверка интеграции компонентов. Тестируются не только отдельные модули (контроллеры, сервисы, репозитории), но и взаимодействие между ними.  
- Проверка рабочих сценариев. Эмулируются реальные пользовательские сценарии, от авторизации до совершения сложных транзакций.  
- Гарантия качества релиза. Выявление потенциальных проблем, которые могут возникнуть из-за неправильной конфигурации, сетевых задержек, ошибок в миграциях БД и других факторов.  
  
### 1 .2. Роль TestContainers в современном E2E тестировании  
  
При разработке сложных распределённых систем важным аспектом является создание тестового окружения, максимально приближённого к продакшену. Именно здесь на помощь приходят TestContainers — библиотека для создания и управления контейнерами Docker в тестовом окружении. Среди основных преимуществ использования TestContainers можно выделить:  
  
- Изолированность тестовой среды. Каждый тест или набор тестов запускается с собственным экземпляром требуемых сервисов (БД, брокеров сообщений, кэш-серверов), что исключает влияние внешних факторов.   
- Повторяемость. Контейнеры автоматически настраиваются и уничтожаются, обеспечивая одинаковые условия для каждого прогона тестов.  
- Близость к продакшену. Использование реальных образов сервисов (например, PostgreSQL, Redis, Kafka) позволяет моделировать рабочее окружение.  
- Гибкость конфигурации. TestContainers легко интегрируются с популярными фреймворками для тестирования, такими как JUnit и Spring Boot Test.  
  
  
В контексте Spring-приложений TestContainers особенно полезны для интеграционного и E2E тестирования, поскольку позволяют автоматически поднимать необходимые внешние зависимости, без ручной настройки и сложной инфраструктуры.  
  
  
---  
  
### 2 . Базовые концепции интеграционного и E2E тестирования в Spring  
  
### 2 .1. Архитектура Spring Boot приложений  
  
Прежде чем перейти непосредственно к тестированию с использованием TestContainers, кратко рассмотрим основные аспекты архитектуры Spring Boot приложений, имеющие значение для тестирования:  
  
- Контейнер инверсии управления (IoC). Spring управляет созданием и жизненным циклом бинов, что упрощает внедрение зависимостей.  
- Внедрение зависимостей (DI). Позволяет легко заменять реальные реализации на моки или стаб-классы в тестовом окружении.  
- Модулярность. Приложения делятся на слои (контроллеры, сервисы, репозитории), что позволяет проводить тестирование на разных уровнях.  
- Поддержка профилей. Spring позволяет использовать разные конфигурации для тестовой и продакшн-среды через механизмы профилей (например, «test»).  
  
  
### 2 .2. Классификация тестов в Spring-приложениях  
  
Тестирование в Spring-приложениях можно разделить на следующие уровни:  
  
1. Модульные тесты. Проверка отдельных классов или методов (с использованием JUnit, Mockito и т.д.).
2. Интеграционные тесты. Проверка взаимодействия между компонентами приложения. Здесь часто используется поднятие тестового контекста Spring.  
3. End-to-End тесты. Полное тестирование приложения с поднятием реального окружения (в том числе внешних зависимостей) для проверки рабочих сценариев.  
  
В данной лекции мы сосредоточимся на E2E тестировании, где TestContainers играет ключевую роль в обеспечении изолированного и реалистичного окружения.  
  
  
---  
  
## 3 . Обзор TestContainers: концепции и возможности  
  
### 3 .1. Основные принципы работы TestContainers  
  
TestContainers — это Java-библиотека, позволяющая программно управлять Docker-контейнерами во время выполнения тестов. Основные принципы работы включают:  
  
- Программное управление контейнерами. Тесты могут создавать, настраивать и запускатьконтейнеры с нужными параметрами.  
- Изоляция среды. Каждый тест может запускаться в отдельном контейнере, что гарантирует отсутствие конфликтов и повторяемость результатов.    
- Автоматическое уничтожение. После завершения теста контейнеры автоматически останавливаются и удаляются, освобождая ресурсы.  
   
### 3 .2. Поддерживаемые сервисы  
  
![[Pasted image 20250210152628.png]]
  
### 3 .3. Пример использования TestContainers для запуска PostgreSQL  
  
Ниже приведён пример теста, демонстрирующий, как можно использовать TestContainers для автоматического поднятия контейнера с PostgreSQL:  
```java

import org.junit.ClassRule;  
import org.junit.Test;  
import org.springframework.boot.test.context.SpringBootTest;  
import org.testcontainers.containers.PostgreSQLContainer;  
  
@SpringBootTest  
public class PostgresIntegrationTest {  
  
	// Объявляем контейнер как статическое поле с аннотацией @ClassRule, чтобы контейнер поднимался один раз на весь класс тестов  
	@ClassRule  
	public static PostgreSQLContainer<?> postgresContainer = new PostgreSQLContainer<>("postgres:13")  
	.withDatabaseName("testdb")  
	.withUsername("testuser")  
	.withPassword("testpass");  
	  
	@Test  
	public void testDatabaseConnection() {  
		// Получаем параметры подключения из контейнера  
		String jdbcUrl = postgresContainer.getJdbcUrl();  
		String username = postgresContainer.getUsername();  
		String password = postgresContainer.getPassword();  
		  
		System.out.println("Подключаемся к базе данных по адресу: " + jdbcUrl);  
		// Здесь можно написать код для проверки подключения к базе данных и выполнения SQL-запросов  
	}  
}  

```
  
Разбор кода:  
  
- Аннотация @ClassRule гарантирует, что контейнер будет создан один раз для всех тестовых методов в классе.  
- Метод withDatabaseName(), withUsername() и withPassword() задают параметры базы данных.  
- Во время выполнения теста можно использовать данные параметры для создания соединения с базой данных и проверки корректности миграций, выполнения запросов и т.д.  
  
---  
  
## 4 . Интеграция TestContainers с Spring Boot  
  
### 4 .1. Конфигурация Spring Boot Test  
  
При использовании TestContainers в Spring Boot тестах часто применяется аннотация @SpringBootTest, которая загружает полный контекст приложения. Для интеграции с контейнерами важно обеспечить подстановку динамических параметров (например, URL подключения к БД) в конфигурацию Spring.  
  
Одним из подходов является использование механизма «Dynamic Property Sources», который позволяет программно установить свойства в тестовом контексте. Пример:  
```java

import org.junit.ClassRule;  
import org.junit.jupiter.api.Test;  
import org.springframework.boot.test.context.SpringBootTest;  
import org.springframework.test.context.DynamicPropertyRegistry;  
import org.springframework.test.context.DynamicPropertySource;  
import org.testcontainers.containers.PostgreSQLContainer;  
  
@SpringBootTest  
public class SpringBootPostgresE2ETest {
	// Создаем контейнер PostgreSQL  
	static PostgreSQLContainer<?> postgresContainer = new PostgreSQLContainer<>("postgres:13")  
	.withDatabaseName("testdb")  
	.withUsername("testuser")  
	.withPassword("testpass");  
	  
	static {  
	postgresContainer.start();  
	}  
	  
	// Регистрация динамических свойств для Spring  
	@DynamicPropertySource  
	static void registerProperties(DynamicPropertyRegistry registry) {  
		registry.add("spring.datasource.url", postgresContainer::getJdbcUrl);  
		registry.add("spring.datasource.username", postgresContainer::getUsername);  
		registry.add("spring.datasource.password", postgresContainer::getPassword);  
	}  
	  
	@Test  
	public void contextLoads() {  
		// Тест проверяет, что Spring Boot контекст успешно загружается с динамическими настройками  
	}  
}  

```
  
Пояснения:  
  
- При использовании аннотации @DynamicPropertySource мы можем зарегистрировать динамические свойства, которые будут подставлены в Spring Environment перед загрузкой контекста.  
- Это особенно полезно, когда параметры контейнера (например, порт или URL) генерируются динамически.  
- Метод postgresContainer.start() запускает контейнер до загрузки тестового контекста.  
  
  
### 4 .2. Интеграция с JUnit 5  
  
TestContainers прекрасно интегрируются с JUnit 5 благодаря использованию расширений. Например, можно использовать аннотацию @Testcontainers для автоматического управления жизненным циклом контейнеров:  
```java

import org.junit.jupiter.api.Test;  
import org.junit.jupiter.api.extension.ExtendWith;  
import org.testcontainers.junit.jupiter.Container;  
import org.testcontainers.junit.jupiter.Testcontainers;  
import org.testcontainers.containers.MySQLContainer;  
  
@Testcontainers  
public class MySQLContainerTest {  
  
	@Container  
	public MySQLContainer<?> mysqlContainer = new MySQLContainer<>("mysql:8.0")  
	.withDatabaseName("testdb")  
	.withUsername("testuser")  
	.withPassword("testpass");  
	  
	@Test  
	public void testMySQLConnection() {  
		String jdbcUrl = mysqlContainer.getJdbcUrl();  
		System.out.println("MySQL запущен по адресу: " + jdbcUrl);  
		// Реализуйте логику проверки подключения или выполнения SQL-операций  
		}  
}  

``` 

  
В данном примере:  
  
- Аннотация @Testcontainers включает автоматический запуск и остановку контейнеров.  
- Аннотация @Container применяется к полю, которое представляет контейнер, и гарантирует, что контейнер будет запущен перед выполнением тестов.  
  
---  
  
## 5 . Практические примеры использования TestContainers для E2E тестирования  
  
В этой части лекции мы рассмотрим практические сценарии, демонстрирующие, как с помощью TestContainers можно организовать полноценное End-to-End тестирование Spring-приложений.  
  
### 5 .1. Тестирование взаимодействия с базой данных  
  
Одним из наиболее распространённых случаев является проверка корректности работы репозиториев и взаимодействия с базой данных. Ниже приведён пример, демонстрирующий тестирование JPA репозитория с использованием TestContainers и Spring Boot:  
```java

import org.junit.jupiter.api.Test;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.boot.test.autoconfigure.orm.jpa.DataJpaTest;  
import org.springframework.test.context.DynamicPropertyRegistry;  
import org.springframework.test.context.DynamicPropertySource;  
import org.testcontainers.containers.PostgreSQLContainer;  
import org.testcontainers.junit.jupiter.Container;  
import org.testcontainers.junit.jupiter.Testcontainers;  
import static org.assertj.core.api.Assertions.assertThat;  
  
@Testcontainers  
@DataJpaTest  
public class UserRepositoryIntegrationTest {  
	  
	@Container  
	public static PostgreSQLContainer<?> postgresContainer = new PostgreSQLContainer<>("postgres:13")  
	.withDatabaseName("testdb")  
	.withUsername("testuser")  
	.withPassword("testpass");
	
	@DynamicPropertySource  
	static void overrideProperties(DynamicPropertyRegistry registry) {  
		registry.add("spring.datasource.url", postgresContainer::getJdbcUrl);  
		registry.add("spring.datasource.username", postgresContainer::getUsername);  
		registry.add("spring.datasource.password", postgresContainer::getPassword);  
	}  
	  
	@Autowired  
	private UserRepository userRepository;  
	  
	@Test  
	public void whenSaveUser_thenUserIsPersisted() {  
		// Создаем нового пользователя  
		User user = new User();  
		user.setUsername("testuser");  
		user.setEmail("testuser@example.com");  
		  
		// Сохраняем пользователя в БД  
		User savedUser = [userRepository.save](https://web.telegram.org/a/userRepository.save)(user);  
		assertThat(savedUser.getId()).isNotNull();  
		  
		// Проверяем, что пользователь найден по идентификатору  
		User fetchedUser = userRepository.findById(savedUser.getId()).orElse(null);  
		assertThat(fetchedUser).isNotNull();  
		assertThat(fetchedUser.getUsername()).isEqualTo("testuser");  
	}  
}  

```
  
Разбор примера:  
  
- Использование аннотации @DataJpaTest позволяет сконцентрироваться на тестировании слоя доступа к данным.  
- Контейнер PostgreSQL поднимается автоматически, а динамические свойства подставляются в конфигурацию Spring.  
- Тест проверяет сохранение и последующее извлечение сущности из базы данных, что гарантирует корректность работы репозиториев.  
  
### 5 .2. Тестирование взаимодействия с внешними сервисами  
  
Помимо баз данных, TestContainers позволяет тестировать интеграцию с другими внешними сервисами, например, с брокерами сообщений. Рассмотрим пример тестирования взаимодействия с Apache Kafka.  

Пример использования KafkaContainer:  
```java
import org.junit.jupiter.api.Test;  
import org.springframework.boot.test.context.SpringBootTest;  
import org.springframework.kafka.core.KafkaTemplate;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.test.context.DynamicPropertyRegistry;  
import org.springframework.test.context.DynamicPropertySource;  
import org.testcontainers.containers.KafkaContainer;  
import org.testcontainers.utility.DockerImageName;  
import org.testcontainers.junit.jupiter.Container;  
import org.testcontainers.junit.jupiter.Testcontainers;  
  
@SpringBootTest  
@Testcontainers  
public class KafkaE2ETest {  
	  
	@Container  
	public static KafkaContainer kafkaContainer = new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:7.2.1"));  
	  
	@DynamicPropertySource  
	static void setKafkaProperties(DynamicPropertyRegistry registry) {  
	registry.add("spring.kafka.bootstrap-servers", kafkaContainer::getBootstrapServers);  
	}  
	  
	@Autowired  
	private KafkaTemplate<String, String> kafkaTemplate;  
	  
	@Test  
	public void testKafkaSendAndReceive() throws Exception {  
		// Отправляем сообщение в Kafka  
		kafkaTemplate.send("test-topic", "key", "Test message");  
		  
		// Реализуйте логику проверки получения сообщения,  
		// например, используя специализированного consumer-а или сторонний инструмент.  
		// Здесь можно добавить задержку и проверку через consumer API.  
	}  
}  

```
  
Основные моменты:  
  
- Контейнер Kafka запускается с использованием образа Confluent.    
- Динамическое свойство spring.kafka.bootstrap-servers подставляется в конфигурацию Spring.    
- Тест демонстрирует отправку сообщения через KafkaTemplate, а получение и проверка сообщения может быть реализована через consumer API или встроенными средствами Spring Kafka.  

---  
  
## 6 . Преимущества и лучшие практики использования TestContainers в E2E тестировании  
  
### 6 .1. Лучшие практики при использовании TestContainers  
  
При организации E2E тестирования с использованием TestContainers рекомендуется соблюдать следующие практики:  
  
- Разделяйте тесты по уровням. Модульные тесты следует выполнять отдельно от интеграционных и E2E тестов, чтобы минимизировать время их выполнения.  
- Используйте динамические свойства. Применяйте @DynamicPropertySource для автоматической подстановки параметров контейнеров в конфигурацию Spring.  
- Минимизируйте время поднятия контейнеров. Организуйте запуск контейнеров на уровне класса или пакета, чтобы избежать повторного создания контейнера для каждого теста, если это допустимо.  
- Логируйте состояние контейнеров. Для отладки полезно выводить параметры контейнеров (например, JDBC URL или bootstrap-сервер Kafka) в лог, что облегчает диагностику проблем.  
- Интегрируйте с CI/CD. Обеспечьте, чтобы окружение Docker на CI-сервере соответствовало требованиям для запуска TestContainers.  
  
## 6 .3. Расширенные возможности и интеграция  
  
TestContainers также поддерживают расширенные сценарии, такие как:  
  
- Мультиконтейнерные тестовые среды. Используйте библиотеку TestContainers Compose для поднятия нескольких взаимосвязанных сервисов по описанию docker-compose файла. 
- Пользовательские образы. При необходимости можно создавать собственные образы Docker, настроенные для специфических тестовых сценариев.  
- Интеграция с мониторингом. С помощью дополнительных инструментов можно отслеживать производительность и состояние контейнеров во время выполнения тестов.    
  
---  
  
## 7 . Структура и организация тестового проекта с TestContainers  
  
### 7 .1. Организация исходного кода тестов  
  
При построении проекта с использованием TestContainers рекомендуется придерживаться следующих рекомендаций по организации кода тестов:  
  
- Разделение по слоям. Организуйте тесты по модулям (например, репозитории, сервисы, контроллеры, интеграционные тесты) в отдельных пакетах.  
- Использование базовых классов. Создайте абстрактные базовые классы для интеграционных тестов, которые будут содержать общие настройки TestContainers (например, инициализацию PostgreSQL или Kafka).  
- Консистентность именования. Имена тестовых классов и методов должны отражать тестируемую функциональность и сценарии.  
  
  
### 7 .2. Пример базового класса для интеграционных тестов с PostgreSQL  
  
Ниже приведён пример базового класса, который можно использовать для интеграционных тестов с использованием PostgreSQL:  
  ```java
import org.junit.jupiter.api.BeforeAll;  
import org.junit.jupiter.api.extension.ExtendWith;  
import org.springframework.test.context.DynamicPropertyRegistry;  
import org.springframework.test.context.DynamicPropertySource;  
import org.testcontainers.containers.PostgreSQLContainer;  
import org.testcontainers.junit.jupiter.Testcontainers;  
  
@Testcontainers  
public abstract class AbstractPostgresTest {  
	  
	public static PostgreSQLContainer<?> postgresContainer = new PostgreSQLContainer<>("postgres:13")  
	.withDatabaseName("testdb")  
	.withUsername("testuser")  
	.withPassword("testpass");  
	  
	@BeforeAll  
	public static void startContainer() {  
		if (!postgresContainer.isRunning()) {  
		postgresContainer.start();  
		}  
	}  
	  
	@DynamicPropertySource  
	public static void registerProperties(DynamicPropertyRegistry registry) {  
		registry.add("spring.datasource.url", postgresContainer::getJdbcUrl);  
		registry.add("spring.datasource.username", postgresContainer::getUsername);  
		registry.add("spring.datasource.password", postgresContainer::getPassword);  
	}  
}  
  ```

  
Все интеграционные тесты, требующие доступа к базе данных, могут наследоваться от данного класса, что позволяет централизованно управлять настройками и жизненным циклом контейнера.  
  
  
---
## 8 . Примеры E2E тестирования бизнес-логики с использованием TestContainers  
  
### 8 .1. Тестирование полного сценария работы приложения  
  
В E2E тестировании важно проверить не только отдельные компоненты, но и полный рабочий сценарий. Рассмотрим пример теста, который эмулирует создание нового заказа в системе интернет-магазина, используя TestContainers для базы данных и брокера сообщений.  
  
#### 8 .1.1. Контекст приложения  
  
Предположим, что в приложении реализована следующая функциональность:  
  
1. Пользователь отправляет HTTP запрос на создание заказа. 
2. Заказ сохраняется в базе данных.  
3. После успешного сохранения в очередь отправляется сообщение для дальнейшей обработки.  
  
#### 8 .1.2. Пример контроллера и сервиса  
  
Контроллер:  

```java

@RestController  
@RequestMapping("/api/orders")  
public class OrderController {  
  
	@Autowired  
	private OrderService orderService;  
	  
	@PostMapping  
	public ResponseEntity<Order> createOrder(@RequestBody OrderRequest orderRequest) {  
		Order order = orderService.createOrder(orderRequest);  
		return ResponseEntity.status(HttpStatus.CREATED).body(order);  
	}  
}  
  

```

Сервис:  
```java
@Service  
public class OrderService {  
  
	@Autowired  
	private OrderRepository orderRepository;  
	  
	@Autowired  
	private KafkaTemplate<String, String> kafkaTemplate;  
	  
	public Order createOrder(OrderRequest request) {  
		Order order = new Order();  
		order.setCustomerName(request.getCustomerName());  
		order.setTotalAmount(request.getTotalAmount());  
		Order savedOrder = [orderRepository.save](https://web.telegram.org/a/orderRepository.save)(order);  
		  
		// Отправка сообщения в Kafka для дальнейшей обработки заказа  
		kafkaTemplate.send("orders-topic", "OrderCreated:" + savedOrder.getId());  
		return savedOrder;  
	}  
}  
```

  
#### 8 .1.3. E2E тест с использованием TestContainers для PostgreSQL и Kafka  

```java
import org.junit.jupiter.api.Test;  
import org.springframework.beans.factory.annotation.Autowired;  
import org.springframework.boot.test.context.SpringBootTest;  
import org.springframework.boot.test.web.client.TestRestTemplate;  
import org.springframework.http.HttpEntity;  
import org.springframework.http.HttpStatus;  
import org.springframework.http.ResponseEntity;  
import org.testcontainers.containers.KafkaContainer;  
import org.testcontainers.containers.PostgreSQLContainer;  
import org.testcontainers.junit.jupiter.Container;  
import org.testcontainers.junit.jupiter.Testcontainers;  
import static org.assertj.core.api.Assertions.assertThat;  
  
@SpringBootTest(webEnvironment = SpringBootTest.WebEnvironment.RANDOM_PORT)  
@Testcontainers  
public class OrderE2ETest extends AbstractPostgresTest {  
	  
	@Container  
	public static KafkaContainer kafkaContainer = new KafkaContainer(DockerImageName.parse("confluentinc/cp-kafka:7.2.1"));  
	  
	@Autowired  
	private TestRestTemplate restTemplate;  
	  
	@DynamicPropertySource  
	static void registerKafkaProperties(DynamicPropertyRegistry registry) {  
		registry.add("spring.kafka.bootstrap-servers", kafkaContainer::getBootstrapServers);  
	}  
	  
	@Test  
	public void whenCreateOrder_thenOrderPersistedAndMessageSent() {  
		// Формирование запроса для создания заказа  
		String orderRequestJson = "{\"customerName\": \"Alice\", \"totalAmount\": 250.0}";  
		HttpEntity<String> requestEntity = new HttpEntity<>(orderRequestJson);  
		  
		// Отправка запроса через TestRestTemplate  
		ResponseEntity<Order> response = restTemplate.postForEntity("/api/orders", requestEntity, Order.class);  
		assertThat(response.getStatusCode()).isEqualTo(HttpStatus.CREATED);  
		  
		Order createdOrder = response.getBody();  
		assertThat(createdOrder).isNotNull();  
		assertThat(createdOrder.getId()).isNotNull();  
		assertThat(createdOrder.getCustomerName()).isEqualTo("Alice");  
		  
		// Здесь можно добавить проверку того, что сообщение было отправлено в Kafka.  
		// Например, реализовать consumer для проверки содержимого очереди.  
	}  
}  

```

  
Объяснение:  
  
- В данном тесте используются TestContainers для одновременного поднятия PostgreSQL (наследуемого от базового класса) и Kafka.
- Тестовый HTTP запрос отправляется через TestRestTemplate к контроллеру создания заказа.  
- После выполнения запроса проверяется, что заказ сохранён в базе данных, а также (опционально) отправлено сообщение в Kafka.  
  
---  
  
## 9 . Заключение первой части лекции  
  
В данной части лекции мы подробно рассмотрели:  
  
- Основные цели и задачи End-to-End тестирования в контексте Java Spring приложений. 
- Роль TestContainers в создании изолированных тестовых окружений, позволяющих моделировать реальные условия работы системы.  
- Базовые принципы работы TestContainers, поддерживаемые сервисы и способы интеграции с Spring Boot через динамические свойства.  
- Примеры практического применения TestContainers для поднятия контейнеров с PostgreSQL, Kafka и другими сервисами.  
- Организацию тестового проекта, использование базовых классов и лучшие практики написания интеграционных и E2E тестов.  
  

Данный материал является отправной точкой для понимания того, как можно построить надежное и повторяемое тестовое окружение для сложных Spring-приложений.