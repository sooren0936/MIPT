# План запроса

## Что такое план запроса?
SQL - это декларативный язык: вместо указания конкретных шагов по получению данных мы описываем,
какие данные нам нужны. Postgres сам решает, как он должен найти эти данные и вернуть их нам.

Для большинства запросов Postgres рассматривает множество вариантов, возвращающих требуемые данные. 
Он оценивает стоимость этих различных подходов и останавливается на одном, который он считает наиболее эффективным. 
Все эти варианты для получения данных и есть то, что называется планами выполнения запроса.

В основном этот процесс работает хорошо, и Postgres выбирает такой план запроса, который быстро возвращает затребованные данные.
Однако это не означает, что всегда выбирается "наиболее эффективный" план запроса.
Поиски самого эффективного плана могут затянуться, поэтому Postgres использует план, который "достаточно хорош".

Проблемы возникают тогда, когда выбранный план не очень хороший.
Это может привести к высокой нагрузке на сервер и длительному времени выполнения запроса.

## Команда EXPLAIN

У Postgres есть отличные инструменты для понимания причин медленной работы запросов - 
вы можете просто попросить базу данных сказать вам, что занимает так много времени.

Для этого нужно выполнить команду EXPLAIN.
К примеру, если вы хотите понять ход выполнения запроса, который ищет людей с именем «Алиса», вы должны выполнить:

```sql
EXPLAIN
SELECT first_name, last_name 
FROM people
WHERE first_name = 'Алиса';
```

Строки со 2 по 4 - это просто любой (DML) запрос Postgres, который мы хотим улучшить.
EXPLAIN - это команда, которую мы здесь запускаем. 
Она возвращает план запроса, который описывает то, как БД собирается выполнять этот запрос. Но сам запрос при этом не выполняется.

Если вы запустите эту команду, то получите примерно такой текстовый вывод:
```sql
Seq Scan on people(cost=0.00..10.88 rows=2 width=1032)
  Filter: ((first_name)::text = 'Алиса'::text)
```
Кому-то подобный формат может показаться неудобным. 
К счастью, Postgres поддерживает и другие форматы: JSON, XML и YAML.

Если выполнить команду `EXPLAIN (formal json) ...`, то результат будет выглядеть вот так:

```sql
[
  {
    "Plan": {
      "Node Type": "Seq Scan",
      "Parallel Aware": false,
      "Relation Name": "people",
      "Alias": "people",
      "Filter": "((first_name)::text = 'Алиса'::text)",
      "Startup Cost": 0.00,
      "Total Cost": 16.49,
      "Plan Rows": 2,
      "Plan Width": 1032
    }
  }
]
```
Некоторые поля здесь заслуживают отдельного внимания.
В "Node type" содержится способ, которым будет осуществляться доступ к данным. Наиболее часто встречающиеся значения:
- "Seq Scan" (последовательное сканирование) говорит о том, что будет просканирована вся таблица целиком.
"Seq Scan" - это наиболее эффективный способ прочитать всю таблицу или значительную её часть.
Это бывает полезно при низкой селективности. При высокой селективности, когда из всей таблицы нужна лишь небольшая часть записей, 
предпочтительнее будет использование индекса.
- "Index Scan" (индексное сканирование) говорит о том, что для получения записей из таблицы будет использовано B-дерево.
Благодаря этому поиск подходящих записей будет быстрее, чем при последовательном переборе.
- "Index Only Scan", как и "Index Only", выполняет поиск по B-дереву, однако при этом не считывает (fetch) данные из таблицы,
так как сам индекс содержит все данные, нужные для удовлетворения запроса.  

Значения в полях "Startup Cost" и "Total Cost" дадут вам приблизительное представление об относительном времени (в абстрактных единицах),
затраченном на каждую операцию, в то время как "Plan Rows" и "Plan Width" сообщат вам ожидаемое количество строк и размер каждой строки (в байтах).

Cost - это "стоимость" выполнения операции на основе ожидаемой нагрузки на ресурсы, которую она может создать.
Postgres позволяет настраивать сервер так, чтобы указывать, какие операции дороже, а какие дешевле.
К примеру, возможно выполнить такую настройку, при которой чтение с диска будет считаться очень дорогой операцией.
Тогда в ходе построения плана запроса сервер предпочтёт считать миллион записей из памяти, чем одну запись с диска.

Важно помнить, что данные величины являются оценочными. 
Планировщик запросов имеет доступ к различной информации о вашей базе данных, 
благодаря которой он может оценить, сколько времени займет та или иная операция
и какой подход лучше выбрать. 

Часто эти оценки бывают довольно точными, особенно для небольших наборов данных. 
Но определенно полезно иметь возможность получить более реалистичную картину.

## EXPLAIN ANALYZE
Добавив опцию `ANALYZE` в команду `EXPLAIN`, мы получим более конкретную информацию.
В этом случае БД не просто построит план, а выполнит запрос (то есть UPDATE в самом деле обновит данные в БД) 
и покажет реальную статистику его выполнения.

Выполнение `EXPLAIN (FORMAT JSON, ANALYZE)` на нашем запросе вернёт следующее:
```
[
  {
    "Plan": {
      "Node Type": "Seq Scan",
      "Parallel Aware": false,
      "Relation Name": "people",
      "Alias": "people",
      "Filter": "((first_name)::text = 'Алиса'::text)",
      "Startup Cost": 0.00,
      "Total Cost": 16.49,
      "Plan Rows": 2,
      "Plan Width": 1032,
      "Actual Startup Time": 0.099,
      "Actual Total Time": 0.357,
      "Actual Rows": 2,
      "Actual Loops": 1,
      "Rows Removed by Filter": 2684
    },
    "Planning Time": 0.108,    
    "Execution Time": 0.381,
    "Triggers": []
  }
]
```
Обратите внимание на новые поля, начиная с "Actual Startup Time".

## BUFFERS
Добавив опцию BUFFERS, мы получим некоторую информацию о попаданиях и промахах в кеш,
которая может многое рассказать вам о количестве времени, затраченного на операции ввода-вывода.
`EXPLAIN (FORMAT JSON, ANALYZE, BUFFERS)` для нашего примера вернёт следующее:

```sql
[
  {
    "Plan": {
      "Node Type": "Seq Scan",
      "Parallel Aware": false,
      "Relation Name": "people",
      "Alias": "people",      
      "Filter": "((first_name)::text = 'Alice'::text)",
      "Startup Cost": 0.00,
      "Total Cost": 16.49,
      "Plan Rows": 2,
      "Plan Width": 1032,
      "Actual Startup Time": 0.026,
      "Actual Total Time": 0.106,
      "Actual Rows": 2,
      "Actual Loops": 1,
      "Rows Removed by Filter": 2684,
      "Shared Hit Blocks": 9,
      "Shared Read Blocks": 0,
      "Shared Dirtied Blocks": 0,
      "Shared Written Blocks": 0,
      "Local Hit Blocks": 0,
      "Local Read Blocks": 0,
      "Local Dirtied Blocks": 0,
      "Local Written Blocks": 0,
      "Temp Read Blocks": 0,
      "Temp Written Blocks": 0
    },
    "Planning Time": 0.120, 
    "Execution Time": 0.125,
    "Triggers": []
  }
]
```
Обратите внимание на новые поля, начиная с "Shared Hit Blocks".

Это может быть полезно, когда вы пытаетесь посмотреть, как используется кеш при выполнении запроса, и убедиться,
что как можно больше операций происходит в оперативной памяти.
