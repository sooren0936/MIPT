# Инструменты миграции

Приложения не статичны. Мы постоянно добавляем в них новую функциональность. Иногда это может
сопровождаться изменением структуры базы данных: созданием новых таблиц, колонок. Возникает вопрос:
как автоматизировать эти изменения? Конечно, мы можем предварительно подключиться к серверу БД,
выполнять нужные `ALTER` выражения и деплоить новую версию продукта. А если вам нужно задеплоить
сервис на новую среду? Создавать структуру каждый раз с нуля не очень приятно (к тому же, есть
большой риск допустить ошибку). Было бы гораздо удобнее, если при запуске новой версии приложения
изменения в структуру БД накатывались автоматически. К счастью, такой инструмент есть.

## Flyway

[Flyway](https://flywaydb.org/) - это библиотека, которая позволяет фиксировать изменения в БД в
виде отдельных changeset-файлов. Рассмотрим подробнее принцип ее работы.

> В Java-мире есть еще одно популярное решение - [Liquibase](https://contribute.liquibase.com/extensions-integrations/directory/database-tutorials/mongodb/).
> Flyway и Liquibase очень похожи и работают по одинаковым принципам. Примеры в курсе будут на Flyway, но вы можете использовать Liquibase.

При использовании Flyway мы храним историю изменений структуры БД в виде набора SQL-файлов, которые
должны следовать определенному формату: `V{ID}__{DESCRIPTION}.sql`. `{ID}` - это порядковый номер
миграции (обычно просто число, увеличивающееся по инкременту). `{DESCRIPTION}` - краткое описание
миграции. Например, вот так может выглядеть список миграций Flyway:

1. `V1__create_organization_table.sql`.
2. `V2__create_department_table.sql`.
3. `V3__create_employee_table.sql`.

Здесь мы последовательно создаем три таблицы: `organization`, `department`, `employee`.

> Обратите внимание, что у каждой миграции должен быть уникальный ID.

Также при первом запуске Flyway создает специальную таблицу - `flyway_schema_history`. В ней
сохраняется информация о тех миграциях, которые **уже** были применены. Когда мы запускаем наш
сервис повторно, выполняются лишь новые. Проще говоря, алгоритм работы Flyway можно изобразить так:

1. Вычитываются файлы из директории с миграциями (обычно хранятся в `src/main/resources`).
2. Проверяем каждую, начиная с первой. Если она уже была применена (запись присутствует
   во `flyway_schema_history`), пропускаем и идем к следующей.
3. Если запись отсутствует, запускаем миграцию и фиксируем информацию о ее выполнении
   во `flyway_schema_history`.

Можно сделать следующие важные выводы:

1. Изменения в схеме БД сопровождаются добавлением **новых** миграций. Старые менять нельзя, если
   они уже были применены: Flyway сравнивает хэш и при несовпадении завершает работу с ошибкой.
2. У каждой новой миграции ID должен быть больше предыдущего.

## Использование Flyway в Java-приложении

Добавьте зависимость в `pom.xml`:

```xml

<dependency>
  <groupId>org.flywaydb</groupId>
  <artifactId>flyway-core</artifactId>
  <version>9.21.1</version>
</dependency>
```

Создайте новую БД, либо удалите таблицу `users` из существующей. Теперь добавьте
файл `V1__create_organization_table.sql` в директорию `src/main/resources/db/migrations`:

```sql
CREATE TABLE organization
(
    id   BIGSERIAL PRIMARY KEY,
    name TEXT NOT NULL
);
```

Теперь напишите такой код в `main`:

```java
import org.flywaydb.core.Flyway;

public class Main {

  public static void main(String[] args) {
    Flyway flyway =
        Flyway.configure()
            .locations("classpath:db/migrations")
            .dataSource("jdbc:postgresql://localhost:5432/postgres", "user", "password")
            .load();
    flyway.migrate();
  }
}
```

Метод `Flyway.configure` возращает [билдер](https://www.geeksforgeeks.org/builder-design-pattern/),
который позволяет настроить экземпляр `Flyway`. В нем мы указываем параметры соединения с БД, а
также путь, по которому нужно искать миграции.

Запустите программу и увидите в логах строчку:

```
INFO: Migrating schema "public" to version "1 - create organization"
```

Это значит, что миграция с `ID = 1` успешно отработала. Теперь откройте базу данных с помощью
клиента, и вы увидите, что там появилось две новых таблицы: `flyway_schema_history` и `organization`.
Выполните `SELECT` из `flyway_schema_history` и увидите там примерно такое содержимое.

| installed\_rank | version | description         | type | script                         | checksum   | installed\_by | installed\_on              | execution\_time | success |
|:----------------|:--------|:--------------------|:-----|:-------------------------------|:-----------|:--------------|:---------------------------|:----------------|:--------|
| 1               | 1       | create organization | SQL  | V1\_\_create\_organization.sql | 1665251039 | user          | 2023-08-06 11:18:42.349728 | 38              | true    |

Как видите, Flyway хранит историю о примененных миграциях. Теперь запустите программу на Java
повторно. Обратите внимание, что в структуре БД ничего не изменилось: Flyway видит, что миграция `1`
уже применилась и нет необходимости запускать ее снова.

Добавим еще одну миграцию `V2__create_department_table.sql`:

```sql
CREATE TABLE department
(
    id          BIGSERIAL PRIMARY KEY,
    name        TEXT NOT NULL,
    description TEXT NOT NULL
);
```

Запустите программу повторно. В логах появится новая строчка:

```
INFO: Migrating schema "public" to version "2 - create department table"
```

Посмотрите в БД: там действительно появилась новая таблица `deparment`. Более того, контент
в `flyway_schema_history` также изменился:

| installed\_rank | version | description             | type | script                              | checksum   | installed\_by | installed\_on              | execution\_time | success |
|:----------------|:--------|:------------------------|:-----|:------------------------------------|:-----------|:--------------|:---------------------------|:----------------|:--------|
| 1               | 1       | create organization     | SQL  | V1\_\_create\_organization.sql      | 1665251039 | user          | 2023-08-06 11:18:42.349728 | 38              | true    |
| 2               | 2       | create department table | SQL  | V2\_\_create\_department\_table.sql | 601689949  | user          | 2023-08-06 11:29:24.904080 | 42              | true    |

Теперь у нас есть информация о двух миграциях. Для верности запустите программу снова. Как видите,
никаких ошибок нет, и записей в таблице `flyway_schema_history` по-прежнему две.

Последний шаг - добавим миграцию `V3__create_employee.sql`:

```sql
CREATE TABLE employee
(
    id         BIGSERIAL PRIMARY KEY,
    first_name TEXT NOT NULL,
    last_name  TEXT NOT NULL
);
```

Запустим программу еще раз. Теперь есть такая запись в логах:

```
INFO: Migrating schema "public" to version "3 - create employee table"
```

В БД появилась новая таблица `employee`, а во `flyway_schema_history` добавилась соответсвующая
запись:

| installed\_rank | version | description             | type | script                              | checksum   | installed\_by | installed\_on              | execution\_time | success |
|:----------------|:--------|:------------------------|:-----|:------------------------------------|:-----------|:--------------|:---------------------------|:----------------|:--------|
| 1               | 1       | create organization     | SQL  | V1\_\_create\_organization.sql      | 1665251039 | user          | 2023-08-06 11:18:42.349728 | 38              | true    |
| 2               | 2       | create department table | SQL  | V2\_\_create\_department\_table.sql | 601689949  | user          | 2023-08-06 11:29:24.904080 | 42              | true    |
| 3               | 3       | create employee table   | SQL  | V3\_\_create\_employee\_table.sql   | 1268934449 | user          | 2023-08-06 11:33:45.544035 | 34              | true    |

Flyway - отличный инструмент для фиксации изменений структуры БД. Главный плюс в том, что вам не
нужно беспокоиться о создании всей схемы с нуля. Если вы запускаете сервис на новой среде, Flyway
прогонит все миграции с самого начала (особенно это будет важно, когда мы перейдем к тестированию
кода взаимодействия с БД).

> Проблема с миграциями в БД не новая и известна уже давно.
> Если хотите понять проблему глубже, рекомендуем ознакомиться со статьей
> Мартина Фаулера [Evolutionary Database Design](https://www.martinfowler.com/articles/evodb.html).

## Нюансы по использованию Flyway

Когда вы начнете применять Flyway, есть вероятность, что вы столкнетесь с определенными моментами,
которые могут вызвать затруднения. Пройдемся по некоторым из них и выработаем подходы.

### Параметр outOfOrder

Предположим, что у нас есть следующий набор миграций:

1. `V1__create_user.sql`.
2. `V2__create_role.sql`.
3. `V4__create_group.sql`.

Flyway не требует, чтобы миграции шли без пробелов. Главное, чтобы ID каждой следующей был
лексикографически наибольшим. Так что такая комбинация миграций отработает корректно.

> Более того, как мы увидим далее, ID необязательно должен стоять только из чисел.

Что будет, если мы добавим новую миграцию `V3__create_permission.sql`? Учитывая лексикографический
порядок, она попадет между `V2` и `V4`. Вот только при запуске вы обнаружите, что Flyway
проигнорировал миграцию `V3` (можете повторить эксперимент самостоятельно для лучшего понимания).
Дело в том, что по умолчанию Flyway не позволяет добавлять новые миграции посередине. Если вы
работаете над проектом один, то кажется, что в этом нет необходимости. Но если на проекте хотя бы
два человека, то уже могут возникнуть затруднения.

Допустим, на стенде, куда сервис разворачивается каждый раз, когда мы вливаем Pull Request в `master`,
применен такой набор миграций:

1. `V1__create_user.sql`.
2. `V2__create_role.sql`.

> Если подзабыли, как работает развертывание при слиянии PR, обратитесь к [этому уроку](../01_git/07_ci_cd_basic_principles.md).

Два человека работают параллельно в разных ветках. Вася в своей ветке
добавил `V3__create_permission.sql`, а Петя - `V4__create_group.sql`. Предположим, что Петя влил
свой PR раньше. Теперь на стенде миграции такие:

1. `V1__create_user.sql`.
2. `V2__create_role.sql`.
3. `V4__create_group.sql`.

Когда подойдет очередь Васи, его миграция не применится, потому что файл окажется между существующими:
Flyway его проигнорирует. Эту проблему можно решить строгим контролем порядка мержа PR-ов, но в
реальности это сложно осуществить (особенно в большой команде). К тому же, такая практика будет
тормозить разработку.

Более правильным вариантом является активация
параметра [outOfOrder](https://documentation.red-gate.com/fd/out-of-order-184127522.html).
Посмотрите на пример кода ниже:

```java
public class Main {

  public static void main(String[] args) {
    Flyway flyway =
        Flyway.configure()
            .outOfOrder(true)
            .locations("classpath:db/migrations")
            .dataSource("jdbc:postgresql://localhost:5432/postgres", "user", "password")
            .load();
    flyway.migrate();
  }
}
```

Если вы активируете `outOfOrder`, то Flyway не будет игнорировать новые миграции посередине, а
применит их при запуске.

### Присваивание уникальных ID

Эта проблема вытекает из предыдущей. Если у нас в команде несколько человек, где каждый в своей
ветке может добавить новую миграцию, как гарантировать уникальность распределения ID? Как вариант,
можно создать страницу в каком-то онлайн документе, где каждый человек "застолбит" за собой
определенный номер миграции, чтобы его не брали другие. Такой подход может сработать, но он не очень
удобен. К тому же, здесь всегда может быть ошибка (кто-то забудет про этот док и возьмет номер,
который кто-то уже успел занять в соседней ветке).

Нам нужен способ децентрализованного определения ID: каждый человек генерирует значение и точно
знает, что оно никем не будет задано. Один из вариантов может выглядеть так:

```
V20230806.6784__some_migration_description.sql
```

ID состоит из двух частей:

1. `20230806` - дата, когда миграция была создана.
2. `6784` - номер задачи, для решения которой необходима миграция. Номер может ссылаться на тикет в
   таких системах, как: 
   [GitHub Issues](https://github.com/features/issues),
   [GitLab Issues](https://docs.gitlab.com/ee/user/project/issues/),
   [Jira](https://www.atlassian.com/software/jira) или [Trello](https://trello.com/).

Если мы исходим из того, что над каждой задачей работает только один человек (а так и должно быть),
то ID каждой миграции будет гарантированно уникален без лишних коллабораций между участниками.

> Подробнее об этом подходе можете [почитать в статье](https://dev.to/kirekov/flyway-migrations-naming-strategy-in-a-big-project-51fp).