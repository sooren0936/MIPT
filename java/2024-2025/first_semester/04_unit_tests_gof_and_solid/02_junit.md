# JUnit 5

## Настройка

JUnit является наиболее популярным фреймворком для модульного тестирования в экосистеме Java.
Давайте настроим JUnit в нашем проекте. Сначала довавьте зависимость на JUnit 5 в `pom.xml`, посмотрите на пример ниже:

```xml
<dependencies>
    <dependency>
      <groupId>org.junit.jupiter</groupId>
      <artifactId>junit-jupiter-engine</artifactId>
      <version>5.9.2</version>
      <scope>test</scope>
    </dependency>
  </dependencies>
```

Теперь нужно настроить Maven так, чтобы при запуске команды `test` тесты также выполнялись.

> При запуске `package` команда `test` также выполняется автоматически.

Для этого добавим еще один плагин в `<build><plugins>...`. Посмотрите на пример кода ниже:

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>3.1.2</version>
</plugin>
```

Теперь напишем простой тест. Они добавляются в директорию `src/test`. Тем не менее, Idea позволяет сделать это проще.
Нажмите правой кнопкой мыши на класс `Main` и выберите пункт `Generate`, а там уже кнопку `Test...`.
Среда разработки предложит создать вам класс `MainTest` в том же самом пакете, но в `src/test`. Это очень удобно, чтобы создавать тесты для разных классов.

Посмотрите на пример теста ниже:

```java
package com.example.demo;

import org.junit.jupiter.api.Test;

import static org.junit.jupiter.api.Assertions.assertEquals;

class MainTest {
    @Test
    void testSum() {
        assertEquals(2, 1 + 1);
    }
}
```

Этот тест очень простой: он всего лишь проверяет, что `2 = 1 + 1`. Но для первого знакомства этого будет достаточно.
Теперь выполните команду `test` для Maven. Вы заметите следующую строчку в логах:

```
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.076 s -- in org.example.MainTest
```

Один тест выполнился успешно. Здорово!

Попробуем "сломать" тест так, чтобы он был неправильным. Замените код на `assertEquals(3, 1 + 1)` и запустите команду `package`.
Вы увидите, что она завершилась ошибкой. То есть Maven не дал нам собрать наш проект, если хотя бы один тест падает.
Здесь и кроется суть. Тесты проверяют работоспособность кода. Если один начал падать, значит, что-то не так.

Повторите этот эксперимент, но уже на GitHub. Создайте новую ветку и сделайте Pull Request. Вы увидите, что если тесты проходят, билд зеленый.
Если же он падает, билд становится красным, и вы не можете влить Pull Request.

> Как владелец репозитория вы всегда можете вливать Pull Request-ы, даже если билд упал.
> Но те люди, которых вы пригласили, или те, что работают по модели Fork + Pull Request (об этом мы упоминали в первом модуле),
> не смогут нажать `Merge`. Таким образом, вы можете гарантировать, что некорректный код не сможет попасть в `master` ветку.

> Если у вас возникли сложности с настройкой, можете ознакомиться с примером готового проекта [по этой ссылке](https://github.com/SimonHarmonicMinor/java-unit-tests-example).

Обычно названия для классов тестов выбирается как `'Class under test name' + Test.java`, но это не обязательное условие. 
Помните, мы раньше обсуждали, что тест определяет какой-то один *'unit'* работы? Можно выбирать имя на основе этого факта: `FeatureNameTest.java`. 
Главное, чтобы имя было осмысленным, а не просто `Test1.java`.

Чтобы запустить единственный тест, а не все сразу, есть несколько способов.
Самый простой - через IDE. Большинство современных IDE имеют хорошую интеграцию с JUnit, и тест можно просто запустить из нее.
Также можно использовать Maven, чтобы запустить не все, а только конкретные тесты:

* `mvnw test` - выполнить все тесты в проекте. 
* `mvnw -Dtest=MainTest test` - выполнить все тесты из класса.
* `mvnw -Dtest=MainTest#testSum test` - выполнить отдельный тест.

Любой тест состоит из следующих частей:

* Название теста
* Подготовка окружения
* Совершение интересующего нас действия
* Проверка результата
* Освобождение ресурсов

**Название теста**. Очень важный пункт, к нему стоит отнестись с большим вниманием. 
Название теста - это первое, что вы увидите в отчете, когда что-то пойдет не так. 
Вы должны по одному названию теста уже получить примерное представление о том, что он проверяет. 
Поэтому стоит подумать о том, как вложить в несколько слов смысл того, что вы проверяете.
Давать тестам имена Тест1, Тест2, Тест3 - это плохая идея.

**Подготовка окружения и Освобождение ресурсов**. 
Необязательные части. У некоторых тестов (как у нас в примере) их может не быть. Зачем они тогда вообще нужны? Во-первых, надо подготовить тестовые данные, например, открыть и прочитать их из файла. Во-вторых, у вашего кода могут быть зависимости, которые надо как-то настроить или подменить (об этом позже). 
Наши тесты должны быть независимыми, поэтому важно откатить все действия, которые могут повлиять на другие тесты. Также важно правильно закрыть файлы, соединение к БД и т.д.

**Совершение действия и Проверка результата**. То, ради чего все и затевалось. Чтобы что-то проверить, нам нужно что-то сделать. 
Выполняем какое-то воздействие на систему. К примеру, вызываем функцию, дергаем ручку. 
Получив результат этого действия, переходим к проверке результатов. 
Именно здесь вы проверяете, что мир изменился таким образом, как вы ожидали. 
Что функция посчитала нужные цифры, ручка вернула нужные данные, в БД записались правильные данные, и при этом не стерлось ничего, что не должно было стереться.

## А что тестировать?

Есть ряд типичных практик, которые постоянно применяются. 
Первое, что стоить проверить, это типовой путь выполнения вашего кода (happy path),
то есть то, что если вызвать функцию, то она вернет данные. 
Вы сначала проверяете его: что действительно вызвали функцию, и она действительно вернула данные.
Вы знаете, как это должно работать, вы ожидаете, что это будет работать именно так, но на всякий случай пишете на это тест. 
Потому что если вдруг это сломается, будет плохо.
Даже если вам в моменте кажется очевидным и простым, как функция работает, все равно стоит написать на это тест. Потому что завтра вы будете разрабатывать другую фичу и случайно сломаете эту, а без тестов вы узнаете об этом очень поздно.

Затем стоит проверить все краевые случаи. 
К примеру, если пользователь введет свое имя японскими иероглифами или в графу возраста введет строку. Что код должен делать в такой ситуации? Справится ли он с этим?
Пишем по отдельному тесту на каждый такой случай.

Ну и всегда стоит проверить самую банальную ситуацию. Что будет, если запихивать null в любое место кода, куда только можно?
Есть функция? Давайте попробуем отправить туда null. Ваш код, по-хорошему, должен быть устойчив к тому, что вместо аргументов придет null. Например, вернет более осмысленную ошибку.
