Вам необходимо разработать структуру классов, которые предоставят возможность сортировать `List`
элементов разными алгоритмами. Так как наш модуль посвящен тестированию и паттернам, а не
алгоритмам, то писать их самим нет необходимости. Для примера нам хватит двух вариантов сортировки.
В качестве первого вы можете просто вызвать `Collections.sort(list)`
(внутри Java
использует [сортировку слиянием](https://ru.wikipedia.org/wiki/%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0_%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC#:~:text=%D0%A1%D0%BE%D1%80%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%BA%D0%B0%20%D1%81%D0%BB%D0%B8%D1%8F%D0%BD%D0%B8%D0%B5%D0%BC%20(%D0%B0%D0%BD%D0%B3%D0%BB.,%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D0%B0%20%C2%AB%D1%80%D0%B0%D0%B7%D0%B4%D0%B5%D0%BB%D1%8F%D0%B9%20%D0%B8%20%D0%B2%D0%BB%D0%B0%D1%81%D1%82%D0%B2%D1%83%D0%B9%C2%BB.)), 
а для второго реализовать простую сортировку пузырьком (смотрите пример в приложении 1).

Пользовательский путь следующий:

1. Создаем список элементов.
2. Выбираем алгоритм сортировки из представленных.
3. Передаем список вместе с типом алгоритма в функцию.
4. На выходе получаем отсортированный список.

> Задание "Зоопарк", которое вы реализовали в прошлом модуле, нам больше не нужно.
> Вы можете либо добавить новые классы в отдельный package, либо предварительно удалить Зоопарк.
> Если пойдете по второму варианту, то удалите классы заранее в отдельном Pull Request, прежде чем отправлять работу на ревью ментору.
> Потому что иначе в изменениях Pull Request-а будет видно удаленные классы с прошлого задания,
> что усложнит процесс проверки.

Требования к реализации следующие:

1. Построенное решение должно уметь сортировать элементы типа `Integer`. То есть оперируем типом `List<Integer>`.
2. Инициализация всей программы должна происходить в `main`.
3. На каждый класс, кроме `Main`, должен быть написан отдельный unit-тест.
4. Необходимо выставить процент покрытия кода в Jacoco на 55%. При этом следует поправить запуск
   билда в `.github/workflows/build.yml`
   так, чтобы Jacoco не позволял влить Pull Request с недостаточным покрытием (то есть
   запустить `verify` вместо `package`).
5. Несмотря на то, что алгоритмов сортировки всего два, нужно предусмотреть архитектуру так, чтобы
   всегда можно было добавить новый алгоритм или поправить старый.
6. Если клиент передает `List` для сортировки, то он не должен редактироваться на месте - в ответ
   нужно возвращать новый, но уже отсортированный список. Подумайте, как бы вы это реализовали.
   Возможно, стоит сделать какую-то обертку над `List`?
7. У каждой реализации алгоритма может быть задано ограничение на максимальное количество элементов. Если массив превышает это значение,
   то алгоритм кидает исключение. При этом если какой-то алгоритм кинул такое исключение, мы все равно должны проходиться по циклу
   в надежде на то, что в списке будет еще один алгоритм с тем же типом сортировки. Если здесь вам сложно понять суть,
   перечитайте еще раз модуль в части примеров с `NotificationService` и `NotificationAction`.

## Приложение 1

Алгоритм сортировки пузырьком для простого массива типа `int`.

```java
class Sorts {

  public static void bubbleSort(int[] arr) {
     for (int i = 0; i < arr.length; i++) {
        for (int j = i + 1; j < arr.length; j++) {
           if (arr[i] > arr[j]) {
             int temp = arr[i];
             arr[i] = arr[j];
             arr[j] = temp;
           }
        }
     }
  }
}
```