# Enum

## Необходимость в Enum

Enum (или перечисления) - еще один удобный концепт в Java, позволяющий писать более понятный и поддерживаемый код.
Чтобы понять его преимущества, давайте вернемся к определению класса `Airplane`:

```java
public class Airplane {
    private final int year;
    private final String color;

    public Airplane(int year, String color) {
        this.year = year;
        this.color = color;
    }
    
    /* другие методы */
}
```

Давайте подумаем: может ли быть самолет абсолютно любого цвета в нашем приложении? Скорее всего, ответ - нет.
Наверняка есть допустимый набор цветов, которые мы считаем правильными. Один из способов решения проблемы - использование констант.
Посмотрите на пример кода ниже:

```java
public class Color {
    public static final String WHITE = "WHITE";
    public static final String BLUE = "BLUE";
}
```

> В Java нет ключевого слова для определения констант, так что этой цели служит комбинация `static final`.

Теперь мы можем ссылаться на конкретные цвета при создании экземпляров класса `Airplane` следующим образом:

```java
public class Main {
    public static void main(String[] args) {
        Airplane airplane = new Airplane(1985, Color.WHITE);
        /* действия с airplane... */
    }
}
```

Проблема решена, не так ли? Не совсем. Хотя мы и зафиксировали список цветов в классе `Color`,
конструктор `Airplane` по-прежнему принимает `String` в качестве параметра.
А значит, что технически мы не обязаны передавать одну из констант `Color`, а можем указать любую другую строку.
Посмотрите на пример кода ниже:

```java
public class Main {
    public static void main(String[] args) {
        Airplane airplane1 = new Airplane(1985, Color.WHITE);
        Airplane airplane2 = new Airplane(1985, "white");
        System.out.println(airplane1.equals(airplane2));
    }
}
```

> Предполагаем, что мы корректно определили equals/hashCode для Airplane по примеру прошлых модулей.

В консоли мы получим результат `false`. Почему? Ведь в обоих случаях цвета одинаковые.
Вот только в `Color.WHITE` записана строка `"WHITE"`, а при создании `airplane2` мы передаем `"white"`.
Технически эти строки не равны по `equals`, следовательно, объекты `airplane1` и `airplane2` также не равны.

Как вы понимаете, вместо `"white"` мы могли передать и другую строку. Например, `"not valid color"`.

## Разбираемся с Enum

Давайте вместо констант объявим `enum`. Посмотрите на пример кода ниже:

```java
public enum Color {
    WHITE, BLUE;
}
```

На первый взгляд может показаться, что `enum` - это какой-то специальный тип как `class` или `interface`.
На самом же деле, `enum` - это обычный класс. А такое объявление является [синтаксическим сахаром](https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D1%81%D0%B0%D1%85%D0%B0%D1%80).

Чтобы суть `enum` стала понятнее, посмотрите на пример кода ниже. Это то, чем на **самом деле** является `enum Color`.

```java
public class Color extends Enum<Color> {
    public static final Color WHITE = new Color("WHITE", 0);
    public static final Color BLUE = new Color("BLUE", 1);
    
    private Color(String name, int ordinal) {
        super(name, ordinal);
    }
    
    /* другие методы из класса Enum */
}
```

Все `enum'ы` в Java наследуют абстрактный класс `Enum`, в качестве дженерика которого передается текущий же класс.
Каждое значение `enum'а` - это константа с типом данного класса.
Конструктор `enum'а` приватный, чтобы в runtime не было возможности добавлять новые значения.
На вход он принимает два параметра:

1. Название `enum'а`. Его можно получить во время выполнения программы, вызвав у значения `enum` метод `name()`.
2. Порядковый номер `enum'а`. Считается в зависимости от того, как вы расположили `enum'ы` друг за другом.

> Важное уточнение. Пример с классом `enum` - это лишь иллюстрация того, во что в итоге превращается тип `enum`.
> Писать так не нужно. Используйте обычное определение `public enum Color {...}`

Уже здесь мы можем сделать два важных вывода:

1. `Enum'ы` не могут наследовать классы, потому что у каждого неявно есть предок `Enum<T>`.
2. `Enum'ы` - это обычные классы. Значит, они могут содержать поля и реализовывать интерфейсы.

> Второй пункт является killer feature Java. Во многих языка есть `enum-ы`, но обычно они превращаются в тип `int` при компиляции.
> С одной стороны, это избавляет от накладных расходов при создании объектов, с другой же, ограничивает функциональность.
> Java воспринимает `enum-ы` как обычные классы, и мы можем использовать это себе на благо.

Посмотрите на пример того, как в полях `enum-а` можно хранить значения:

```java
public enum Color {
    WHITE("белый"), BLUE("синий");
  
    private final String ru;

    Color(String ru) {
        this.ru = ru;
    }

    public String getRu() {
        return ru;
    }
}
```

Каждое значение `enum'а` (иначе говоря, каждый экземпляр класса `Color`) хранит название текущего цвета на русском языке.

> Скобки возле значения enum'а - это вызов конструктора, который мы объявили ниже.

Также мы добавили геттер `getRu`. А это значит, что конструкция `Color.WHITE.getRu()` будет валидна.
Посмотрите на пример кода ниже, где мы перебираем все значения `enum'а`:

```java
public class Main {
    public static void main(String[] args) {
        for (Color color : Color.values()) {
            System.out.println(color.getRu());
        }
    }
}
```

Статический метод `.values()` автоматически генерируется для каждого `enum-а` и возвращает массив всех значений, которые там есть.
Если в процессе работы над кодом мы добавим новое значение, метод также будет его возвращать.

> Нужно отметить, что хотя `enum'ы` и позволяют хранить значения в полях, важно следить за тем, чтобы они были иммутабельны.
> Поскольку каждое значение `enum` существует в программе в единственном экземпляре, одно изменение поля повлечет то,
> что все участки кода также это увидят.

## Внедрение enum

Давайте перепишем класс `Airplane` так, чтобы поле `color` было `enum`.

```java
public class Airplane {
    private final int year;
    private final Color color;

    public Airplane(int year, String color) {
        this.year = year;
        this.color = color;
    }
    
    /* другие методы */
}
```

Теперь попробуем создать экземпляр `Airplane`:

```java
public class Main {
    public static void main(String[] args) {
        Airplane airplane = new Airplane(1985, Color.WHITE);
        /* действия с airplane... */
    }
}
```

Визуально кажется, что ничего не изменилось относительно примера с константами.
Но посмотрите, что будет, если мы попытаемся создать экземпляр `Airplane`, передав в качестве `Color` строку.

```java
public class Main {
    public static void main(String[] args) {
        Airplane airplane1 = new Airplane(1985, Color.WHITE);
        Airplane airplane2 = new Airplane(1985, "white"); // COMPILE ERROR!
        System.out.println(airplane1.equals(airplane2));
    }
}
```

При попытке передачи строки туда, где ожидался `enum`, мы получим ошибку компиляции. 
То есть использование `enum` гарантирует, что мы сможем передать туда лишь одно из его значений или `null`.

Каждый раз, когда у вас возникает желание добавить константы, подумайте, можно ли вместо этого внедрить `enum`?

## Сравнение enum по ==

Есть один важный момент с `enum`, о котором вы уже могли догадаться. 
Несмотря на то, что `enum` - это класс, каждое его значение создается в единственном экземпляре и используется по всей программе.
А это значит, что сравнение `Color.WHITE == Color.WHITE` даст `true` точно так же, как и `Color.WHITE.equals(Color.WHITE)`.

Как бы то ни было, мы рекомендуем всегда использовать `equals`, чтобы код выглядел более единообразно.