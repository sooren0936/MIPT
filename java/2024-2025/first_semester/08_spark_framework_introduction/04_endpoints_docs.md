# Endpoint-ы в протоколе HTTP

Прежде чем двигаться дальше с Java-кодом, нужно разобраться с endpoint'ами в HTTP. Один мы уже
создали - `GET` endpoint. В протоколе HTTP представлено много методов. Но в рамках курса нас будут
интересовать лишь следующие:

1. `GET`
2. `POST`
3. `PUT`
4. `PATCH`
5. `DELETE`

Каждый из них отвечает за определенный тип операции. Разберемся подробнее.

> Стоит отметить, что отличие здесь не столько техническое, сколько семантическое.
> Проще говоря, никто вам не запретит использовать `PUT` для получения данных, `GET` - для их изменения.
> Тем не менее, такое решение введет в заблуждение и других программистов, которые пишут код вместе с вами,
> и людей, которые обращаются к вашему API (Application Programming Interface).
> Поэтому важно следовать тем принципам, о которых мы сейчас расскажем.

## GET

Этот метод служит для получения информации с сервера без изменения контента. `GET` должен
быть [идемпотентным](https://ru.wikipedia.org/wiki/%D0%98%D0%B4%D0%B5%D0%BC%D0%BF%D0%BE%D1%82%D0%B5%D0%BD%D1%82%D0%BD%D0%BE%D1%81%D1%82%D1%8C). 
То есть при повторном вызове возвращать те же данные (при условии, что между вызовами никто их не
изменил). Помимо прочего, `GET` должен быть безопасным: поскольку он никак не меняет данные на
сервере, то его можно вызвать сколько угодно раз и не бояться что-то сломать.

> Когда вы вбиваете какой-то адрес в браузере и нажимаете Enter, выполняется именно `GET` запрос.
> Поэтому и мы проверяли работоспособность нашего тестового endpoint-а именно так.

Пример `GET` запроса может выглядеть вот так:

```
GET /api/books
```

По названию можно догадаться, что он возвращает список книг.

> Добавление единого префикса (`/api`, `/rest` и так далее) считается хорошей практикой.

Помните мы добавляли `GET` запрос на путь `/hello` с помощью Spark? То же самое можно сделать и
с `/api/books`. Посмотрите на пример кода ниже:

```java
import spark.Request;
import spark.Response;
import spark.Spark;

public class Main {

  public static void main(String[] args) {
    Spark.get("/api/books",
        (Request request, Response response) -> "Какой-то список книг в виде строки");
  }
}
```

Метод `GET` следует использовать для получения не только списка, но и конкретной сущности. Здесь мы
запрашиваем книгу с конкретным ID:

```
GET /api/books/1
```

В данном случае мы хотим узнать информацию о книге с ID равным 1. При этом `1` не является
статической частью пути. Мы можем подставить `2`, `3`, `4`, `247` и так далее. То есть ID - это
плейсхолдер, в который подставляется конкретное значение при вызове. Значит, правильнее обозначить
endpoint будет так:

```
GET /api/books/:bookId
```

Строка `:bookId` символизирует динамический параметр, вместо которого ожидается конкретное значение.

> Как работать с плейсхолдерами в Java с помощью Spark Framework, мы обсудим далее.

Еще есть дополнительные параметры, которые не являются частью пути. Допустим, мы хотим
вызвать `/api/books`, но нас не интересуют все существующие книги. Нам нужно получить лишь те, у
которых в качестве жанра содержится один из перечисленных. Посмотрите на пример ниже:

```
GET /api/books?genre=horror
```

После знака `?` мы указали связку `genre=horror`. Здесь `genre` - название параметра, а `horror` -
его значение. Иначе говоря, мы хотим получить список лишь тех книг, у которых указан жанр "Ужасы".

В таких параметрах можно указывать несколько значений через запятую. Посмотрите на пример кода ниже:

```
GET /api/books?genre=horror,comedy
```

> Строго говоря, использовать именно запятую необязательно, потому что на backend'е при парсинге
> по названию параметра `genre` вы все равно получите строку `horror,comedy`. То есть это может быть любой другой символ (`|`, `;` и так далее).
> Но использование запятой считается общепринятым.

Если внедрить плейсхолдеры, путь преобразится так:

```
GET /api/books?genre=:genre
```

Следует отметить, что таких именованных параметров может быть сколько угодно. Если их несколько,
указываем их через знак `&`. Посмотрите на пример ниже:

```
GET /api/books?genre=:genre&author=:author
```

Тут мы указали параметры `genre` и `author`.

Главное отличие именованных параметров от тех, что находятся внутри пути, в том, что путь считывается до
знака вопроса. То есть все, что идет после - дополнительная информация, которая может отсутствовать.

Чтобы это понять, посмотрите еще раз на пример кода со Spark ниже:

```java
import spark.Request;
import spark.Response;
import spark.Spark;

public class Main {

  public static void main(String[] args) {
    Spark.get("/api/books",
        (Request request, Response response) -> "Какой-то список книг в виде строки");
  }
}
```

Откройте в браузере `http://localhost:4567/api/books` и вы увидите
ответ `Какой-то список книг в виде строки`. Теперь добавьте какие-нибудь именованные параметры и
обновите страницу. Например, `http://localhost:4567/api/books?genre=detective`. Заметьте, что ответ
не изменился. Согласно протоколу HTTP, путь - это лишь часть `/api/books`. Все остальное -
параметры. Spark соблюдает эти правила, поэтому запрос вызывает ту же самую функцию в коде.

А теперь немного изменим путь. Попробуйте вписать в браузере `http://localhost:4567/api/books/123` и
обновите страницу. Вы получили `404 NOT FOUND`. Потому что путь теперь равен `/api/books/123`, а для
него мы никаких хэндлеров пока не регистрировали.

## POST

Запрос `POST` служит для добавления новых данных. Он не является идемпотентным (то есть вызов
подразумевает наличие изменений между вызовами).

Все вещи относительно параметров запроса, которые мы обсуждали выше, применимы и для `POST`, 
`DELETE`, `PUT` и `PATCH`. То есть, если вы хотите создать новую книгу на сервере, это можно
сделать так:

```
POST /api/books?name=Solaris
```

Здесь мы сообщаем backend-у, что хотим создать книгу с названием "Солярис". Но такой подход
используется редко. Добавление новой сущности может потребовать передачи сложной структуры, которую
тяжело отобразить в name-value значениях. Поэтому в `POST` вы можете передавать еще тело запроса.
Она является обычной строкой, так что теоретически туда можно записать любую информацию. Но так работать с
данными неудобно. Поэтому чаще всего данные отправляются в
формате [JSON](https://www.w3schools.com/whatis/whatis_json.asp).

Предположим, что мы хотим при создании книги передавать еще и список ее жанров. Посмотрите на пример
ниже:

```
POST /api/books

{
  "name": "Solaris",
  "genres": ["drama", "sci-fi"]
}
```

Давайте сделаем небольшое демо. Через строку браузера отправлять `POST` запросы не получится. 
Лучше установить HTTP-клиент. Можно использовать [Postman](https://www.postman.com/). Если же у вас
IDEA Ultimate, то откройте `Tools -> HTTP Client`, чтобы отправлять запросы прямо из IDE.

Теперь добавим обработку `POST` запроса на Java. Сначала нам пригодится удобный инструмент для
парсинга JSON-ов. Для этого добавьте в зависимости
библиотеку [Jackson](https://habr.com/ru/companies/otus/articles/687004/).

```xml

<dependency>
  <groupId>com.fasterxml.jackson.core</groupId>
  <artifactId>jackson-databind</artifactId>
  <version>2.15.2</version>
</dependency>
```

Она преобразовывает JSON-строку в POJO (Plain Old Java Class): структуру данных с полями и
геттерами. Теперь добавим `POST` endpoint на создание книги:

```java
import com.fasterxml.jackson.databind.ObjectMapper;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import spark.Request;
import spark.Response;
import spark.Spark;

public class Main {

  private static final Logger LOG = LoggerFactory.getLogger(Main.class);

  public static void main(String[] args) {
    ObjectMapper objectMapper = new ObjectMapper();

    Spark.post("/api/books", (Request request, Response response) -> {
      BookCreateRequest bookCreateRequest = objectMapper.readValue(request.body(),
          BookCreateRequest.class);

      LOG.info("Вместо логирования здесь будет процесс создания книги... {}", bookCreateRequest);

      response.type("application/json");
      String bookCreatedJson = objectMapper.writeValueAsString(new BookCreateResponse(1));
      return bookCreatedJson;
    });
  }
}

///

public class BookCreateRequest {

  private final String name;
  private final Set<String> genres;

  @JsonCreator
  public BookCreateRequest(
      @JsonProperty("name") String name,
      @JsonProperty("genres") Set<String> genres
  ) {
    this.name = name;
    this.genres = genres;
  }

  // getters, toString, equals/hashCode
}

///

public class BookCreateResponse {

  private final long id;

  public BookCreateResponse(long id) {
    this.id = id;
  }

  public long getId() {
    return id;
  }
}
```

Давайте поэтапно разберемся в том, что здесь происходит:

1. Когда клиент отправляет `POST` запрос, его перехватывает хэндлер `Spark.post`.
2. Из `response` мы вычитываем тело, которое является обычной строкой, и с помощью `ObjectMapper`
   (класс из библиотеки Jackson) преобразуем строку в экземпляр класса `BookCreatRequest`.
   Аннотация `@JsonCreator` говорит о том, что `ObjectMapper` создаст экземпляр класса именно с
   помощью этого конструктора.
   `@JsonProperty` же - это названия полей, которые мы попытаемся вычитать из JSON.
3. После этого логируем сообщение о создании книги (в реальном коде здесь мы бы вызвали
   соответствующую функцию).
4. В `response` устанавливаем заголовок `Content-Type` в `application/json`. Это указание для
   клиента, что в body он получил ответ в формате JSON.
5. Преобразуем экземпляр класса `BookCreateResponse` в JSON и возвращаем его в качестве ответа.

> Обратите внимание, что при сериализации (преобразовании экземпляра класса в JSON-строку) наличие публичного геттера обязательно.
> Если его не будет, Jackson просто не запишет это поле в качестве ответа.
> Для десериализации же (преобразования JSON в экземпляр класса) наличие геттера необязательно.

Как видите, ничего сложного. Благодаря Jackson мы из сырого JSON получили обычный экземпляр
Java-класса, который можно передавать в другие методы и выполнять нужные операции.

> Такие классы как `BookCreateResponse` и `BookCreateRequest` называют DTO (data transfer object).

Еще небольшая ремарка. Начиная с Java 17 `BookCreateResponse` и `BookCreateRequest` можно
упростить. Посмотрите на пример кода ниже:

```java
public record BookCreateRequest(String name, Set<String> genres) {

}

public record BookCreateResponse(long id) {

}
```

Records - это дата-классы, у которых все поля по умолчанию `final`. Для каждого генерируется
геттер (правда, без префикса `get`). Помимо этого, автоматически добавляется `toString`, `equals`
и `hashCode`. Records - удобный инструмент для DTO в Java.

Если вы отправите такой `POST` запрос:

```
POST http://localhost:4567/api/books
Accept: application/json
Content-Type: application/json

{
  "name": "Solaris",
  "genres": [
    "drama",
    "sci-fi"
  ]
}
```

То увидите следующее сообщение в логах:

```
Вместо логирования здесь будет процесс создания книги... BookCreateRequest{name='Solaris', genres=[drama, sci-fi]}
```

> Кроме Jackson есть еще другая популярная библиотека от Google - [GSON](https://github.com/google/gson).
> По большему счету, это вкусовщина, так что выбор оставляем за вами.

## PUT

Эти запросы нужны для обновления существующих данных, но не для создания новых. Поэтому его вызов также
должен быть идемпотентным. Обычно `PUT` запросы выглядят так:

```
PUT /api/books/34

{
  "name": "Числа",
  "genres": ["Современная проза"]
}
```

Тут мы обновляем книгу с ID `34` (он указан в пути). В качестве данных же запишется то, что мы
передали в теле. Посмотрите на пример кода ниже:

```java
public class Main {

  private static final Logger LOG = LoggerFactory.getLogger(Main.class);

  public static void main(String[] args) {
    ObjectMapper objectMapper = new ObjectMapper();

    Spark.put("/api/books/:bookId", (Request request, Response response) -> {
      long bookId = Long.parseLong(request.params("bookId"));
      BookUpdateRequest bookUpdateRequest = objectMapper.readValue(request.body(),
          BookUpdateRequest.class);

      LOG.info("Вместо логирования здесь будет процесс обновления книги... {}: {}", bookId,
          bookUpdateRequest);

      response.type("application/json");
      String bookCreatedJson = objectMapper.writeValueAsString(new BookUpdateResponse(bookId));
      return bookCreatedJson;
    });
  }
}
```

Как видите, он почти такой же, как и для `POST`. Разница в том, что теперь мы указываем плейсхолдер
как часть запроса, потому что оттуда вычитываем ID книги. После этого ID мы запрашиваем с
помощью `request.params("bookId"")`.

## PATCH

Запросы `PATCH` и `PUT` одинаковые по смыслу, но разные по семантике. `PUT` предполагает полную
замену объектами тех данных, которые мы получили из тела запроса. `PATCH` же обновляет только те
поля, которые в теле заполнены и не равняются `null`. Проще говоря, это частичное обновление
сущности на сервере.

В большинстве случаев вам хватит `PUT` запросов, так что мы не будем здесь останавливаться.

## DELETE

Этот запрос, как понятно из названия, удаляет какие-то данные с сервера. Чаще всего в запросе
указывается ID сущности, которую нужно удалить. Посмотрите на пример ниже:

```
DELETE /api/books/7891
```

Тут мы хотим удалить книгу с ID `7891`.

> Чтобы добавить соответствующий endpoint на Java, нужно вызвать `Spark.delete(...)`.

## Выводы по методам HTTP

Все эти методы HTTP нужны для того, чтобы на один и тот же ресурс (путь), можно было передавать
разные запросы. Посмотрите на пример ниже:

```
GET /api/books
GET /api/books/5
POST /api/books
PUT /api/books/3
DELETE /api/books/6
```

Во всех случаях речь идет о книге, но операции разные:

1. Получаем список все книг.
2. Получаем книгу с ID `5`.
3. Создаем новую книгу.
4. Обновляем книгу с ID `3`.
5. Удаляем книгу с ID `6`.

Представьте, что в нашем распоряжении был бы только `POST` запрос. Тогда те же операции могли
выглядеть так:

```
POST /api/books/get/all
POST /api/books/get/5
POST /api/books/create
POST /api/books/update/3
POST /api/books/delete/6
```

Заметили, насколько снизилась читаемость? Нам приходится в пути самого запроса указывать операцию, с
которой мы имеем дело. Вывод здесь такой: не используйте глаголы в пути запроса. Он всегда должен
представлять название ресурса (то есть существительное). Тип операции же нужно выбирать с помощью
метода (`GET`, `POST`, `PUT` и так далее).